{\rtf1 \mac \ansicpg10000 \nisusversion40007 \deff0 {\fonttbl {\f0 \froman \fcharset77 Times-Roman{\*\falt Times};}{\f1 \fswiss \fcharset77 LucidaGrande-Bold{\*\falt Lucida Grande};}{\f2 \fswiss \fcharset77 LucidaGrande{\*\falt Lucida Grande};}{\f3 \fmodern \fcharset77 Courier;}{\f4 \fnil \fcharset77 Courier-Bold{\*\falt Courier};}{\f5 \froman \fcharset77 TimesNewRomanPSMT{\*\falt Times New Roman};}{\f6 \fnil \fcharset77 Tahoma-Bold{\*\falt Tahoma};}{\f7 \fswiss \fcharset77 Tahoma;}}{\colortbl ;\red0 \green0 \blue233 ;\red0 \green0 \blue108 ;\red106 \green0 \blue108 ;\red14 \green109 \blue108 ;\red0 \green0 \blue153 ;\red15 \green111 \blue1 ;\red0 \green0 \blue0 ;\red0 \green0 \blue255 ;}{\*\revtbl {Unknown;}{ ;}}\nisusrevtypes0 \donotshowinsdel1 {\*\nisustoctable {\nisustoc \tcf68 {\nisustocname Default TOC}{\*\nisustoctabrep  }{\*\nisustocretrep  }{\nisustoclevelstyle TOC 1}{\nisustoclevelstyle TOC 2}{\nisustoclevelstyle TOC 3}{\nisustoclevelstyle TOC 4}{\nisustoclevelstyle TOC 5}{\nisustoclevelstyle TOC 6}{\nisustoclevelstyle TOC 7}{\nisustoclevelstyle TOC 8}{\nisustoclevelstyle TOC 9}}\nisusactivetoc68
}{\*\nisusxetable {\nisusxe \xef68 {\nisusxename Default Index}{\nisusxeheaderstyle Index Heading}{\nisusxelevelstyle Index 1}{\nisusxelevelstyle Index 2}{\nisusxelevelstyle Index 3}{\nisusxelevelstyle Index 4}{\nisusxelevelstyle Index 5}{\nisusxelevelstyle Index 6}{\nisusxelevelstyle Index 7}{\nisusxelevelstyle Index 8}{\nisusxelevelstyle Index 9}{\*\fldinst INDEX \\k ". " \\g \endash  \\e "\tab " \\l ", " \\f D}}\nisusactivexe68
}{\stylesheet {\s463 \nisusnoteplacement0 \nisusnotespanheight1300 \nisusnotespanlines5 \nisusnotedocrefstyle464 \nisusnoterefstyle465 \nisusnotegutterh60 {\*\nisusnotedefaulttext .\u160 ?}\nisusnotedivalign2
\nisusnotedivpercent25 \nisusnotedivoverpercent75 {\*\nisusnotedivstyle \nisusbrdredge \brdrs \brdrw20 \brdrcf7 }\sbasedon466 \f0\fs24 \ql\nowidctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar
\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Footnote;}{\*\cs464 \super Note Reference;}{\*\cs465 \sbasedon464 \nosupersub Note Reference in Note;}{\s466 \snext466 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Normal;}{\s467 \nisusnoteplacement2 \nisusnotespanheight1300 \nisusnotespanlines5 \nisusnotedocrefstyle464 \nisusnoterefstyle465 \nisusnotegutterh60 {\*\nisusnotedefaulttext .\u160 ?}\nisusnotedivalign2
\nisusnotedivpercent25 \nisusnotedivoverpercent75 {\*\nisusnotedivstyle \nisusbrdredge \brdrs \brdrw20 \brdrcf7 }\sbasedon466 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar
\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Endnote;}{\s468 \snext466 \sbasedon466 \f6\fs28\b \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl1 Heading 1;}{\s469 \snext466 \sbasedon468 \f6\fs26\b \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl2 Heading 2;}{\s470 \snext466 \sbasedon469 \f6\fs26\b\i \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl3 Heading 3;}{\s471 \snext471 \sbasedon466 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Header;}{\s472 \snext466 \sbasedon466 \f6\fs28\b \qc\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Title;}{\s473 \snext473 \sbasedon466 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Footer;}{\s474 \snext474 \sbasedon466 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li1080\lin1080\fi0\ri1020\rin1020 Block Quote;}{\*\cs475 \i Emphatic;}{\s476 \snext466 \sbasedon470 \f7\fs26\b0\i0 \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl4 Heading 4;}{\s477 \snext466 \sbasedon476 \f7\fs26\b0\i0\ul \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl5 Heading 5;}{\s478 \snext466 \sbasedon477 \f7\fs26\b0\i\ul \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl6 Heading 6;}{\*\cs479 \b Strong;}{\*\cs803 \ul\cf8 Hyperlink;}}{\*\listtable {\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid1088387561 \nisuslistcontnum1 {\*\liststylename Bullet List 1;}}{\list \listsimple1 {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid1645347854 \nisuslistcontnum1 {\*\liststylename Number List 4;}}{\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid937357732 \nisuslistcontnum1 {\*\liststylename Bullet List 4;}}{\list \listhybrid {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li576
\lin576 \fi-576 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'04\'00.\'01.;}{\levelnumbers \'01\'03;}\li796
\lin796 \fi-796 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'06\'00.\'01.\'02.;}{\levelnumbers \'01\'03\'05;}\li1016
\lin1016 \fi-1016 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'08\'00.\'01.\'02.\'03.;}{\levelnumbers \'01\'03\'05\'07;}\li1236
\lin1236 \fi-1236 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0a\'00.\'01.\'02.\'03.\'04.;}{\levelnumbers \'01\'03\'05\'07\'09;}\li1456
\lin1456 \fi-1456 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0c\'00.\'01.\'02.\'03.\'04.\'05.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b;}\li1676
\lin1676 \fi-1676 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0e\'00.\'01.\'02.\'03.\'04.\'05.\'06.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d;}\li1896
\lin1896 \fi-1896 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'10\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d\'0f;}\li2116
\lin2116 \fi-2116 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'12\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\li2336
\lin2336 \fi-2336 \ri0 \rin0 }{\listname ;}\listid214459759 \nisuslistcontnum1 {\*\liststylename Headings;}}{\list \listsimple1 {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid2045329870 \nisuslistcontnum1 {\*\liststylename Number List 1;}}{\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid1508545802 \nisuslistcontnum1 {\*\liststylename Bullet List 3;}}{\list \listhybrid {\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li648
\lin648 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'01.;}{\levelnumbers \'01;}\li1008
\lin1008 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'02.;}{\levelnumbers \'01;}\li1368
\lin1368 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'03);}{\levelnumbers \'02;}\li1728
\lin1728 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'04);}{\levelnumbers \'02;}\li2088
\lin2088 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'05);}{\levelnumbers \'02;}\li2448
\lin2448 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'06);}{\levelnumbers \'01;}\li2808
\lin2808 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'07);}{\levelnumbers \'01;}\li3168
\lin3168 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'08);}{\levelnumbers \'01;}\li3528
\lin3528 \fi-360 \ri0 \rin0 }{\listname ;}\listid947609847 \nisuslistcontnum0 {\*\liststylename Lettered List;}}{\list \listhybrid {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li648
\lin648 \fi-648 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'04\'00.\'01.;}{\levelnumbers \'01\'03;}\li868
\lin868 \fi-868 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'06\'00.\'01.\'02.;}{\levelnumbers \'01\'03\'05;}\li1088
\lin1088 \fi-1088 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'08\'00.\'01.\'02.\'03.;}{\levelnumbers \'01\'03\'05\'07;}\li1308
\lin1308 \fi-1308 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0a\'00.\'01.\'02.\'03.\'04.;}{\levelnumbers \'01\'03\'05\'07\'09;}\li1528
\lin1528 \fi-1528 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0c\'00.\'01.\'02.\'03.\'04.\'05.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b;}\li1748
\lin1748 \fi-1748 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0e\'00.\'01.\'02.\'03.\'04.\'05.\'06.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d;}\li1968
\lin1968 \fi-1968 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'10\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d\'0f;}\li2188
\lin2188 \fi-2188 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'12\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\li2408
\lin2408 \fi-2408 \ri0 \rin0 }{\listname ;}\listid739972377 \nisuslistcontnum0 {\*\liststylename Tiered List;}}{\list \listhybrid {\listlevel \levelnfc1 \levelnfcn1 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li360
\lin360 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc3 \levelnfcn3 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'01.;}{\levelnumbers \'01;}\li720
\lin720 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'02.;}{\levelnumbers \'01;}\li1080
\lin1080 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'03);}{\levelnumbers \'01;}\li1440
\lin1440 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'04);}{\levelnumbers \'02;}\li1800
\lin1800 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'05);}{\levelnumbers \'02;}\li2160
\lin2160 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'06);}{\levelnumbers \'02;}\li2520
\lin2520 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'07);}{\levelnumbers \'02;}\li2880
\lin2880 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'08);}{\levelnumbers \'02;}\li3240
\lin3240 \fi-360 \ri0 \rin0 }{\listname ;}\listid637940462 \nisuslistcontnum0 {\*\liststylename Outline;}}{\list \listsimple1 {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid264032581 \nisuslistcontnum1 {\*\liststylename Number List 2;}}{\list \listhybrid {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li720
\lin720 \fi-432 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'01.;}{\levelnumbers \'01;}\li1080
\lin1080 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'02.;}{\levelnumbers \'01;}\li1440
\lin1440 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'03);}{\levelnumbers \'02;}\li1800
\lin1800 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'04);}{\levelnumbers \'02;}\li2160
\lin2160 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'05);}{\levelnumbers \'02;}\li2520
\lin2520 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'06);}{\levelnumbers \'01;}\li2880
\lin2880 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'07);}{\levelnumbers \'01;}\li3240
\lin3240 \fi-432 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'08);}{\levelnumbers \'01;}\li3600
\lin3600 \fi-432 \ri0 \rin0 }{\listname ;}\listid1626979010 \nisuslistcontnum0 {\*\liststylename Number List;}}{\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid894374165 \nisuslistcontnum1 {\*\liststylename Bullet List 2;}}{\list \listhybrid {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li648
\lin648 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li1008
\lin1008 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li1368
\lin1368 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li1728
\lin1728 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li2088
\lin2088 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li2448
\lin2448 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li2808
\lin2808 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li3168
\lin3168 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li3528
\lin3528 \fi-360 \ri0 \rin0 }{\listname ;}\listid726943819 \nisuslistcontnum0 {\*\liststylename Bullet List;}}{\list \listsimple1 {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat5 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid231367332 \nisuslistcontnum1 {\*\liststylename Number List 3;}}}{\*\listoverridetable {\listoverride \listid2045329870 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls1
}{\listoverride \listid2045329870 \listoverridecount0 \ls2 }{\listoverride \listid1088387561 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls3
}{\listoverride \listid1088387561 \listoverridecount0 \ls4 }{\listoverride \listid264032581 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls5
}{\listoverride \listid264032581 \listoverridecount0 \ls6 }{\listoverride \listid894374165 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls7
}{\listoverride \listid894374165 \listoverridecount0 \ls8 }{\listoverride \listid1508545802 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls9
}{\listoverride \listid1508545802 \listoverridecount0 \ls10 }{\listoverride \listid937357732 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls11
}{\listoverride \listid937357732 \listoverridecount0 \ls12 }{\listoverride \listid231367332 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat5 \nisuslistsoftoverridestartat }\ls13
}{\listoverride \listid231367332 \listoverridecount0 \ls14 }{\listoverride \listid1645347854 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls15
}{\listoverride \listid1645347854 \listoverridecount0 \ls16 }{\listoverride \listid214459759 \listoverridecount0 \ls17 }{\listoverride \listid947609847 \listoverridecount0 \ls18 }{\listoverride \listid739972377 \listoverridecount0 \ls19 }{\listoverride \listid637940462 \listoverridecount0 \ls20 }{\listoverride \listid1626979010 \listoverridecount0 \ls21 }{\listoverride \listid726943819 \listoverridecount0 \ls22 }}\defformat {\info {\*\nisusgmtoffset -5:00}{\author  }{\creatim \yr2014 \mo2 \dy16 \hr23 \min15 }{\revtim \yr2014 \mo2 \dy16 \hr23 \min34 }}{\*\userprops }\viewkind1 \viewzk1 \nisusviewruler1 \nisusviewrulerh1
\nisusviewrulerv0 \nisusviewtoolbar1 \nisusviewtooldrawer1 \nisusviewpagenumtype1 \nisusviewrulericons0 {\*\nisusviewsettings \viewkind4 \viewscale125 }{\*\nisusviewsettings \viewkind1 \viewzk1 {\nisusnavsettings {\*\mode toc}{\*\closedtochandles }{\*\visible 0}}}{\*\nisuswindow \x299 \y120 \w840 \h720 }\nisusrulerunits0
\nshwinv0 \nshwpg1 \nisusinlinespell1 \hyphauto0 \hyphhotz10800 \nisusselectstart111064 \nisusselectlength0 \ftnstart1 \ftnnar \aftnstart1 \aftnnar \aenddoc \fet2 \ftnbj \paperw12240 \paperh15840 \margl720 \margr720 \margt720 \margb720 \gutter0 \pgnstart1 \nocolbal \widowctrl \f0 \sectd \endnhere \sftnnar \saftnnar \linemod0 \cols1 \ltrsect \colbalsxn0 \pgwsxn12240 \pghsxn15840 \marglsxn720 \margrsxn720 \margtsxn720 \margbsxn720 \guttersxn0 \headery320 \footery258 \pgnstarts1 \pgnrestart \pgndec \sxnstarts1 \sxnrestart \sxndec {\header \plain \pard \s471 \f0\fs24 }{\footer \plain \pard \s473 \f0\fs24 }\deftab720
{\pard \s466 {\f1\fs28\b Eli Bendersky, Python internals: Working with Python ASTs\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 November 28th, 2009 at 1:02 pm\fs24 \par
Starting with Python 2.5, the Python compiler (the part that takes your source-code and translates it to Python VM code for the VM to execute) works as follows }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id7"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 1.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls1\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Parse source code into a parse tree (\f3\fs20 Parser/pgen.c\f2\fs24 )\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 2.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Transform parse tree into an Abstract Syntax Tree (\f3\fs20 Python/ast.c\f2\fs24 )\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 3.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Transform AST into a Control Flow Graph (\f3\fs20 Python/compile.c\f2\fs24 )\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 4.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Emit bytecode based on the Control Flow Graph (\f3\fs20 Python/compile.c\f2\fs24 )\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 Previously, the only place one could tap into the compilation process was to obtain the parse tree with the \f3\fs20 parser\f2\fs24  module. But parse trees are }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 much less convenient to use}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  than ASTs for code transformation and generation. This is why the addition of the \f3\fs20 _ast\f2\fs24  module in Python 2.5 was welcome \endash  it became much simpler to play with ASTs created by Python and even modify them. Also, the python built-in \f3\fs20 compile\f2\fs24  function can now accept an AST object in addition to source code.\par
Python 2.6 then took another step forward, including the higher-level \f3\fs20 ast\f2\fs24  module in its standard library. \f3\fs20 ast\f2\fs24  is a convenient Python-written toolbox to aid working with \f3\fs20 _ast\f2\fs24  }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id8"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . All in all we now have a very convenient framework for processing Python source code. A full Python-to-AST parser is included with the standard distribution \endash  what more could we ask? This makes all kinds of language transformation tasks with Python very simple.\par
What follows are a few examples of cool things that can be done with the new \f3\fs20 _ast\f2\fs24  and \f3\fs20 ast\f2\fs24  modules.\par
{\f1\b Manually building ASTs\par
}{\f4\fs20\b\cf2 import}\f3
\fs20  {\cf2 ast}\par
node = ast.Expression(ast.BinOp(\par
                ast.Str({\cf3 'xy'}),\par
                ast.Mult(),\par
                ast.Num({\cf4 3})))\par
fixed = ast.fix_missing_locations(node)\par
codeobj = {\cf2 compile}(fixed, {\cf3 '<string>'}, {\cf3 'eval'})\par
{\f4\b\cf2 print} {\cf2 eval}(codeobj)\f0
\fs24 \par
\f2 Let\rquote s see what is going on here. First we manually create an AST node, using the AST node classes exported by \f3\fs20 ast\f2\fs24  }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id9"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [3]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . Then the convenient \f3\fs20 fix_missing_locations\f2\fs24  function is called to patch the \f3\fs20 lineno\f2\fs24  and \f3\fs20 col_offset\f2\fs24  attributes of the node and its children.\par
Another useful function that can help is \f3\fs20 ast.dump\f2\fs24 . Here\rquote s a formatted dump of the node we\rquote ve created:\par
\f3\fs20 Expression(\par
  body=BinOp(\par
         left=Str(s='xy'),\par
         op=Mult(),\par
         right=Num(n=3)))\f0\fs24 \par
\f2 The most useful single-place reference for the various AST nodes and their structure is \f3\fs20 Parser/Python.asdl\f2\fs24  in the source distribution.\par
{\f1\b Breaking compilation into pieces\par
}Given some source code, we first parse it into an AST, and then compile this AST into a code object that can be evaluated:\par
{\f4\fs20\b\cf2 import}\f3
\fs20  {\cf2 ast}\par
source = {\cf3 '6 + 8'}\par
node = ast.parse(source, mode={\cf3 'eval'})\par
{\f4\b\cf2 print} {\cf2 eval}({\cf2 compile}(node, {\cf3 '<string>'}, mode={\cf3 'eval'}))\f0
\fs24 \par
\f2 Again, \f3\fs20 ast.dump\f2\fs24  can be helpful to show the AST that was created:\par
\f3\fs20 Expression(\par
  body=BinOp(\par
         left=Num(n=6),\par
         op=Add(),\par
         right=Num(n=8)))\f0\fs24 \par
{\f1\b Simple visiting and transformation of ASTs\par
}{\f4\fs20\b\cf2 import}\f3
\fs20  {\cf2 ast}\par
{\f4\b\cf2 class} {\cf2 MyVisitor}(ast.NodeVisitor):\par
    {\f4\b\cf2 def} {\cf2 visit_Str}({\cf2 self}, node):\par
        {\f4\b\cf2 print} {\cf3 'Found string "%s"'} % node.s\par
{\f4\b\cf2 class} {\cf2 MyTransformer}(ast.NodeTransformer):\par
    {\f4\b\cf2 def} {\cf2 visit_Str}({\cf2 self}, node):\par
        {\f4\b\cf2 return} ast.Str({\cf3 'str: '} + node.s)\par
node = ast.parse({\cf3 '''}\par
{\cf3 favs = ['berry', 'apple']}\par
{\cf3 name = 'peter'}\par
{\cf3 for item in favs:}\par
{\cf3     print '%s likes %s' % (name, item)}\par
{\cf3 '''})\par
MyTransformer().visit(node)\par
MyVisitor().visit(node)\f0
\fs24 \par
\f2 This prints:\par
\f3\fs20 Found string "str: berry"\par
Found string "str: apple"\par
Found string "str: peter"\par
Found string "str: %s likes %s"\f0\fs24 \par
\f2 The visitor class implements methods that are called for relevant AST nodes (for example \f3\fs20 visit_Str\f2\fs24  is called for \f3\fs20 Str\f2\fs24  nodes). The transformer is a bit more complex. It calls relevant methods for AST nodes and then replaces them with the returned value of the methods.\par
To prove that the transformed code is perfectly valid, we can just compile and execute it:\par
\f3\fs20 node = ast.fix_missing_locations(node)\par
{\f4\b\cf2 exec} {\cf2 compile}(node, {\cf3 '<string>'}, {\cf3 'exec'})\f0
\fs24 \par
\f2 As expected }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id10"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [4]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , this prints:\par
\f3\fs20 str: str: peter likes str: berry\par
str: str: peter likes str: apple\f0\fs24 \par
{\f1\b Reproducing Python source from AST nodes\par
}\f2
Armin Ronacher }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id11"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [5]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  wrote a module named \f3\fs20 codegen\f2\fs24  that uses the facilities of \f3\fs20 ast\f2\fs24  to print back Python source from an AST. Here\rquote s how to show the source for the node we transformed in the previous example:\par
{\f4\fs20\b\cf2 import}\f3
\fs20  {\cf2 codegen}\par
{\f4\b\cf2 print} codegen.to_source(node)\f0\fs24 \par
\f2 And the result:\par
\f3\fs20 favs = [{\cf3 'str: berry'}, {\cf3 'str: apple'}]\par
name = {\cf3 'str: peter'}\par
{\f4\b\cf2 for} item {\cf5 in} favs:\par
    {\f4\b\cf2 print} {\cf3 'str: %s likes %s'} % (name, item)\f0
\fs24 \par
\f2 Yep, looks right. \f3\fs20 codegen\f2\fs24  is very useful for debugging or tools that transform Python code and want to save the results }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id12"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [6]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . Unfortunately, the version you get from Armin\rquote s website isn\rquote t suitable for the \f3\fs20 ast\f2\fs24  that made it into the standard library. A slightly patched version of \f3\fs20 codegen\f2\fs24  that works with the standard 2.6 library can be downloaded }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/wp-content/uploads/2009/11/codegen.py"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 here}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
{\f1\b So why is this useful?\par
}Many tools require parsing the source code of the language they operate upon. With Python, this task has been trivialized by the built-in methods to parse Python source into convenient ASTs. Since there\rquote
s very little (if any) type checking done in a Python compiler, in classical terms we can say that a complete Python front-end is provided. This can be utilized in:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls3\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 IDEs for various "intellisense" needs\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Static code checking tools like pylint and pychecker\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Python code generators like pythoscope\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Alternative Python interpreters\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Compilers from Python to other languages\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 There are surely other uses I\rquote m missing. If you\rquote re aware of a library/tool that uses \f3\fs20 ast\f2\fs24 , let me know.\par
}}{\pard \nisusnos \qc\nowidctlpar\sb240 \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Taken from the excellent }}{\field {\*\fldinst HYPERLINK "http://www.python.org/dev/peps/pep-0339/"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl PEP 339}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 . This PEP is well worth the read \endash  it explains each of the 4 steps in details with useful pointers into the source code where more information can be obtained.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10440
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f3\fs20 \intbl _ast\f2\fs24  is implemented in \f3\fs20 Python/Python-ast.[ch]\f2\fs24  which can be obtained from the source distribution.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10440
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id3"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [3]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Actually, they are exported by \f3\fs20 _ast\f2\fs24 , but \f3\fs20 ast\f2\fs24  does \f3\fs20 from _ast import *\cell }}\row }\trowd
\trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id4"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [4]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Why so many \f3\fs20 str:\f2\fs24 ? It\rquote s not a mistake!\cell }}\row }\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3
\clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id5"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [5]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl The author of the \f3\fs20 ast\f2\fs24  module.\cell }}\row }\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20
\clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/#id6"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [6]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl For example, the }}{\field {\*\fldinst HYPERLINK "http://pythoscope.org/"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl pythoscope tool}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2  for auto generating unit-tests from code could probably benefit from \f3\fs20 ast\f2\fs24  and \f3\fs20 codegen\f2\fs24 . Currently it seems to be working on the level of Python parse trees instead.\cell }}\row
}\pard \plain {\pard \s466 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f0 \par
{\f1\fs28\b Python internals: adding a new statement to Python\fs36 \par
}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 June 30th, 2010 at 7:18 pm\fs24 \par
This article is an attempt to better understand how the front-end of Python works. Just reading documentation and source code may be a bit boring, so I\rquote m taking a hands-on approach here: I\rquote m going to add an \f3\fs20 until\f2\fs24  statement to Python.\par
All the coding for this article was done against the cutting-edge Py3k branch in the }}{\field {\*\fldinst HYPERLINK "http://code.python.org/hg/branches/py3k/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 Python Mercurial repository mirror}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
{\f1\fs28\b The \f4\fs20 until\f1\fs28  statement\par
}Some languages, like Ruby, have an \f3
\fs20 until\f2\fs24  statement, which is the complement to \f3\fs20 while\f2\fs24  (\f3\fs20 until num == 0\f2\fs24  is equivalent to \f3\fs20 while num != 0\f2\fs24 ). In Ruby, I can write:\par
\f3\fs20 num = {\cf4 3}\par
{\f4\b\cf2 until} num == {\cf4 0} {\f4\b\cf2 do}\par
  {\cf2 puts} num\par
  num -= {\cf4 1}\par
{\f4\b\cf2 end}\f0
\fs24 \par
\f2 And it will print:\par
\f3\fs20 3\par
2\par
1\f0\fs24 \par
\f2 So, I want to add a similar capability to Python. That is, being able to write:\par
\f3\fs20 num = {\cf4 3}\par
until num == {\cf4 0}:\par
  {\f4\b\cf2 print}(num)\par
  num -= {\cf4 1}\f0
\fs24 \par
{\f1\fs28\b A language-advocacy digression\par
}\f2 This article doesn\rquote t attempt to suggest the addition of an \f3\fs20 until\f2\fs24  statement to Python. Although I think such a statement would make some code clearer, and this article displays how easy it is to add, I completely respect Python\rquote
s philosophy of minimalism. All I\rquote m trying to do here, really, is gain some insight into the inner workings of Python.\par
{\f1\fs28\b Modifying the grammar\par
}Python uses a custom parser generator named \f3
\fs20 pgen\f2\fs24 . This is a LL(1) parser that converts Python source code into a parse tree. The input to the parser generator is the file \f3\fs20 Grammar/Grammar\f2\fs24  }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/#id4"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . This is a simple text file that specifies the grammar of Python.\par
Two modifications have to be made to the grammar file. The first is to add a definition for the \f3\fs20 until\f2\fs24  statement. I found where the \f3\fs20 while\f2\fs24  statement was defined (\f3\fs20 while_stmt\f2\fs24 ), and added \f3\fs20 until_stmt\f2\fs24  below }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/#id5"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
\f3\fs20 compound_stmt: if_stmt | while_stmt | until_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated\par
if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\par
while_stmt: 'while' test ':' suite ['else' ':' suite]\par
until_stmt: 'until' test ':' suite\f0\fs24 \par
\f2 Note that I\rquote ve decided to exclude the \f3\fs20 else\f2\fs24  clause from my definition of \f3\fs20 until\f2\fs24 , just to make it a little bit different (and because frankly I dislike the \f3\fs20 else\f2\fs24  clause of loops and don\rquote t think it fits well with the Zen of Python).\par
The second change is to modify the rule for \f3\fs20 compound_stmt\f2\fs24  to include \f3\fs20 until_stmt\f2\fs24 , as you can see in the snippet above. It\rquote s right after \f3\fs20 while_stmt\f2\fs24 , again.\par
When you run \f3\fs20 make\f2\fs24  after modifying \f3\fs20 Grammar/Grammar\f2\fs24 , notice that the \f3\fs20 pgen\f2\fs24  program is run to re-generate \f3\fs20 Include/graminit.h\f2\fs24  and \f3\fs20 Python/graminit.c\f2\fs24 , and then several files get re-compiled.\par
{\f1\fs28\b Modifying the AST generation code\par
}After the Python parser has created a parse tree, this tree is converted into an AST, since ASTs are }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 much simpler to work with}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  in subsequent stages of the compilation process.\par
So, we\rquote re going to visit \f3\fs20 Parser/Python.asdl\f2\fs24  which defines the structure of Python\rquote s ASTs and add an AST node for our new \f3\fs20 until\f2\fs24  statement, again right below the \f3\fs20 while\f2\fs24 :\par
\f3\fs20 | While(expr test, stmt* body, stmt* orelse)\par
| Until(expr test, stmt* body)\f0\fs24 \par
\f2 If you now run \f3\fs20 make\f2\fs24 , notice that before compiling a bunch of files, \f3\fs20 Parser/asdl_c.py\f2\fs24  is run to generate C code from the AST definition file. This (like \f3\fs20 Grammar/Grammar\f2\fs24 ) is another example of the Python source-code using a mini-language (in other words, a DSL) to simplify programming. Also note that since \f3\fs20 Parser/asdl_c.py\f2\fs24  is a Python script, this is a kind of }}{\field {\*\fldinst HYPERLINK "http://en.wikipedia.org/wiki/Bootstrapping_(compilers)"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 bootstrapping}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  \endash  to build Python from scratch, Python already has to be available.\par
While \f3\fs20 Parser/asdl_c.py\f2\fs24  generated the code to manage our newly defined AST node (into the files \f3\fs20 Include/Python-ast.h\f2\fs24  and \f3\fs20 Python/Python-ast.c\f2\fs24 ), we still have to write the code that converts a relevant parse-tree node into it by hand. This is done in the file \f3\fs20 Python/ast.c\f2\fs24 . There, a function named \f3\fs20 ast_for_stmt\f2\fs24  converts parse tree nodes for statements into AST nodes. Again, guided by our old friend \f3\fs20 while\f2\fs24 , we jump right into the big \f3\fs20 switch\f2\fs24  for handling compound statements and add a clause for \f3\fs20 until_stmt\f2\fs24 :\par
{\f4\fs20\b\cf2 case}\f3
\fs20  while_stmt:\par
    {\f4\b\cf2 return} ast_for_while_stmt(c, ch);\par
{\f4\b\cf2 case} until_stmt:\par
    {\f4\b\cf2 return} ast_for_until_stmt(c, ch);\f0\fs24 \par
\f2 Now we should implement \f3
\fs20 ast_for_until_stmt\f2\fs24 . Here it is:\par
{\f4\fs20\b\cf2 static}\f3\fs20  stmt_ty\par
{\cf2 ast_for_until_stmt}({\f4\b\cf2 struct} compiling *c, {\f4\b\cf2 const} node *n)\par
\{\par
    {\cf6 /* until_stmt: 'until' test ':' suite */}\par
    REQ(n, until_stmt);\par
    {\f4\b\cf2 if} (NCH(n) == {\cf4 4}) \{\par
        expr_ty expression;\par
        asdl_seq *suite_seq;\par
        expression = ast_for_expr(c, CHILD(n, {\cf4 1}));\par
        {\f4\b\cf2 if} (!expression)\par
            {\f4\b\cf2 return} {\cf2 NULL};\par
        suite_seq = ast_for_suite(c, CHILD(n, {\cf4 3}));\par
        {\f4\b\cf2 if} (!suite_seq)\par
            {\f4\b\cf2 return} {\cf2 NULL};\par
        {\f4\b\cf2 return} Until(expression, suite_seq, LINENO(n), n->n_col_offset, c->c_arena);\par
    \}\par
    PyErr_Format(PyExc_SystemError,\par
                 {\cf3 "wrong number of tokens for 'until' statement: %d"},\par
                 NCH(n));\par
    {\f4\b\cf2 return} {\cf2 NULL};\par
\}\f0
\fs24 \par
\f2 Again, this was coded while closely looking at the equivalent \f3\fs20 ast_for_while_stmt\f2\fs24 , with the difference that for \f3\fs20 until\f2\fs24  I\rquote ve decided not to support the \f3\fs20 else\f2\fs24  clause. As expected, the AST is created recursively, using other AST creating functions like \f3\fs20 ast_for_expr\f2\fs24  for the condition expression and \f3\fs20 ast_for_suite\f2\fs24  for the body of the \f3\fs20 until\f2\fs24  statement. Finally, a new node named \f3\fs20 Until\f2\fs24  is returned.\par
Note that we access the parse-tree node \f3\fs20 n\f2\fs24  using some macros like \f3\fs20 NCH\f2\fs24  and \f3\fs20 CHILD\f2\fs24 . These are worth understanding \endash  their code is in \f3\fs20 Include/node.h\f2\fs24 .\par
{\f1\fs28\b Digression: AST composition\par
}I chose to create a new type of AST for the \f3
\fs20 until\f2\fs24  statement, but actually this isn\rquote t necessary. I could\rquote ve saved some work and implemented the new functionality using composition of existing AST nodes, since:\par
\f3\fs20 until condition:\par
   {\cf6 # do stuff}\f0
\fs24 \par
\f2 Is functionally equivalent to:\par
{\f4\fs20\b\cf2 while}\f3\fs20  {\cf5 not} condition:\par
  {\cf6 # do stuff}\f0\fs24 \par
\f2 Instead of creating the \f3\fs20 Until\f2
\fs24  node in \f3\fs20 ast_for_until_stmt\f2\fs24 , I could have created a \f3\fs20 Not\f2\fs24  node with an \f3\fs20 While\f2\fs24  node as a child. Since the AST compiler already knows how to handle these nodes, the next steps of the process could be skipped.\par
{\f1\fs28\b Compiling ASTs into bytecode\par
}The next step is compiling the AST into Python bytecode. The compilation has an intermediate result which is a CFG (Control Flow Graph), but since the same code handles it I will ignore this detail for now and leave it for another article.\par
The code we will look at next is \f3
\fs20 Python/compile.c\f2\fs24 . Following the lead of \f3\fs20 while\f2\fs24 , we find the function \f3\fs20 compiler_visit_stmt\f2\fs24 , which is responsible for compiling statements into bytecode. We add a clause for \f3\fs20 Until\f2\fs24 :\par
{\f4\fs20\b\cf2 case}\f3
\fs20  While_kind:\par
    {\f4\b\cf2 return} compiler_while(c, s);\par
{\f4\b\cf2 case} Until_kind:\par
    {\f4\b\cf2 return} compiler_until(c, s);\f0\fs24 \par
\f2 If you wonder what \f3
\fs20 Until_kind\f2\fs24  is, it\rquote s a constant (actually a value of the \f3\fs20 _stmt_kind\f2\fs24  enumeration) automatically generated from the AST definition file into \f3\fs20 Include/Python-ast.h\f2\fs24 . Anyway, we call \f3\fs20 compiler_until\f2\fs24  which, of course, still doesn\rquote t exist. I\rquote ll get to it an a moment.\par
If you\rquote re curious like me, you\rquote ll notice that \f3\fs20 compiler_visit_stmt\f2\fs24  is peculiar. No amount of \f3\fs20 grep\f2\fs24 -ping the source tree reveals where it is called. When this is the case, only one option remains \endash  C macro-fu. Indeed, a short investigation leads us to the \f3\fs20 VISIT\f2\fs24  macro defined in \f3\fs20 Python/compile.c\f2\fs24 :\par
{\f3\fs20\cf6 #define VISIT(C, TYPE, V) \{\\}\f3
\fs20 \par
{\cf6     if (!compiler_visit_ ## TYPE((C), (V))) \\}\par
{\cf6         return 0; \\}\f0\fs24 \par
\f2 It\rquote s used to invoke \f3\fs20 compiler_visit_stmt\f2\fs24  in \f3
\fs20 compiler_body\f2\fs24 . Back to our business, however\u8230 ?\par
As promised, here\rquote s \f3\fs20 compiler_until\f2\fs24 :\par
{\f4\fs20\b\cf2 static}\f3\fs20  {\f4\b\cf2 int}\par
{\cf2 compiler_until}({\f4\b\cf2 struct} compiler *c, stmt_ty s)\par
\{\par
    basicblock *loop, *end, *anchor = {\cf2 NULL};\par
    {\f4\b\cf2 int} constant = expr_constant(s->v.Until.test);\par
    {\f4\b\cf2 if} (constant == {\cf4 1}) \{\par
        {\f4\b\cf2 return} {\cf4 1};\par
    \}\par
    loop = compiler_new_block(c);\par
    end = compiler_new_block(c);\par
    {\f4\b\cf2 if} (constant == -{\cf4 1}) \{\par
        anchor = compiler_new_block(c);\par
        {\f4\b\cf2 if} (anchor == {\cf2 NULL})\par
            {\f4\b\cf2 return} {\cf4 0};\par
    \}\par
    {\f4\b\cf2 if} (loop == {\cf2 NULL} || end == {\cf2 NULL})\par
        {\f4\b\cf2 return} {\cf4 0};\par
    ADDOP_JREL(c, SETUP_LOOP, end);\par
    compiler_use_next_block(c, loop);\par
    {\f4\b\cf2 if} (!compiler_push_fblock(c, LOOP, loop))\par
        {\f4\b\cf2 return} {\cf4 0};\par
    {\f4\b\cf2 if} (constant == -{\cf4 1}) \{\par
        VISIT(c, expr, s->v.Until.test);\par
        ADDOP_JABS(c, POP_JUMP_IF_TRUE, anchor);\par
    \}\par
    VISIT_SEQ(c, stmt, s->v.Until.body);\par
    ADDOP_JABS(c, JUMP_ABSOLUTE, loop);\par
    {\f4\b\cf2 if} (constant == -{\cf4 1}) \{\par
        compiler_use_next_block(c, anchor);\par
        ADDOP(c, POP_BLOCK);\par
    \}\par
    compiler_pop_fblock(c, LOOP, loop);\par
    compiler_use_next_block(c, end);\par
    {\f4\b\cf2 return} {\cf4 1};\par
\}\f0
\fs24 \par
\f2 I have a confession to make: this code wasn\rquote t written based on a deep understanding of Python bytecode. Like the rest of the article, it was done in imitation of the kin \f3\fs20 compiler_while\f2\fs24  function. By reading it carefully, however, keeping in mind that the Python VM is stack-based, and glancing into the documentation of the \f3\fs20 dis\f2\fs24  module, which has }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/py3k/library/dis.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 a list of Python bytecodes}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  with descriptions, it\rquote s possible to understand what\rquote s going on.\par
{\f1\fs28\b That\rquote s it, we\rquote re done\u8230 ? Aren\rquote t we?\par
}After making all the changes and running \f3
\fs20 make\f2\fs24 , we can run the newly compiled Python and try our new \f3\fs20 until\f2\fs24  statement:\par
\f3\fs20 >>> until num == {\cf4 0}:\par
...   {\f4\b\cf2 print}(num)\par
...   num -= {\cf4 1}\par
...\par
{\cf4 3}\par
{\cf4 2}\par
{\cf4 1}\f0
\fs24 \par
\f2 Voila, it works! Let\rquote s see the bytecode created for the new statement by using the \f3\fs20 dis\f2\fs24  module as follows:\par
{\f4\fs20\b\cf2 import}\f3\fs20  {\cf2 dis}\par
{\f4\b\cf2 def} {\cf2 myfoo}(num):\par
    until num == {\cf4 0}:\par
        {\f4\b\cf2 print}(num)\par
        num -= {\cf4 1}\par
dis.dis(myfoo)\f0
\fs24 \par
\f2 Here\rquote s the result:\par
\f3\fs20 4           0 SETUP_LOOP              36 (to 39)\par
      >>    3 LOAD_FAST                0 (num)\par
            6 LOAD_CONST               1 (0)\par
            9 COMPARE_OP               2 (==)\par
           12 POP_JUMP_IF_TRUE        38\par
5          15 LOAD_NAME                0 (print)\par
           18 LOAD_FAST                0 (num)\par
           21 CALL_FUNCTION            1\par
           24 POP_TOP\par
6          25 LOAD_FAST                0 (num)\par
           28 LOAD_CONST               2 (1)\par
           31 INPLACE_SUBTRACT\par
           32 STORE_FAST               0 (num)\par
           35 JUMP_ABSOLUTE            3\par
      >>   38 POP_BLOCK\par
      >>   39 LOAD_CONST               0 (None)\par
           42 RETURN_VALUE\f0\fs24 \par
\f2 The most interesting operation is number 12: if the condition is true, we jump to after the loop. This is correct semantics for \f3\fs20 until\f2\fs24 . If the jump isn\rquote t executed, the loop body keeps running until it jumps back to the condition at operation 35.\par
Feeling good about my change, I then tried running the function (executing \f3\fs20 myfoo(3)\f2\fs24 ) instead of showing its bytecode. The result was less than encouraging:\par
\f3\fs20 Traceback (most recent call last):\par
  File "zy.py", line 9, in <module>\par
    myfoo(3)\par
  File "zy.py", line 5, in myfoo\par
    print(num)\par
SystemError: no locals when loading 'print'\f0\fs24 \par
\f2 Whoa\u8230 ? this can\rquote t be good. So what went wrong?\par
{\f1\fs28\b The case of the missing symbol table\par
}One of the steps the Python compiler performs when compiling the AST is create a symbol table for the code it compiles. The call to \f3
\fs20 PySymtable_Build\f2\fs24  in \f3\fs20 PyAST_Compile\f2\fs24  calls into the symbol table module (\f3\fs20 Python/symtable.c\f2\fs24 ), which walks the AST in a manner similar to the code generation functions. Having a symbol table for each scope helps the compiler figure out some key information, such as which variables are global and which are local to a scope.\par
To fix the problem, we have to modify the \f3\fs20 symtable_visit_stmt\f2\fs24  function in \f3\fs20 Python/symtable.c\f2\fs24 , adding code for handling \f3\fs20 until\f2\fs24  statements, after the similar code for \f3\fs20 while\f2\fs24  statements }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/#id6"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [3]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
{\f4\fs20\b\cf2 case}\f3
\fs20  While_kind:\par
    VISIT(st, expr, s->v.While.test);\par
    VISIT_SEQ(st, stmt, s->v.While.body);\par
    {\f4\b\cf2 if} (s->v.While.orelse)\par
        VISIT_SEQ(st, stmt, s->v.While.orelse);\par
    {\f4\b\cf2 break};\par
{\f4\b\cf2 case} Until_kind:\par
    VISIT(st, expr, s->v.Until.test);\par
    VISIT_SEQ(st, stmt, s->v.Until.body);\par
    {\f4\b\cf2 break};\f0
\fs24 \par
\f2 And now we really are done. Compiling the source after this change makes the execution of \f3\fs20 myfoo(3)\f2\fs24  work as expected.\par
{\f1\fs28\b Conclusion\par
}In this article I\rquote
ve demonstrated how to add a new statement to Python. Albeit requiring quite a bit of tinkering in the code of the Python compiler, the change wasn\rquote t difficult to implement, because I used a similar and existing statement as a guideline.\par
The Python compiler is a sophisticated chunk of software, and I don\rquote t claim being an expert in it. However, I am really interested in the internals of Python, and particularly its front-end. Therefore, I found this exercise a very useful companion to theoretical study of the compiler\rquote s principles and source code. It will serve as a base for future articles that will get deeper into the compiler.\par
{\f1\fs28\b References\par
}I used a few excellent references for the construction of this article. Here they are, in no particular order:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2\cf1 \bullet \tab }}}{\field {\*\fldinst HYPERLINK "http://www.python.org/dev/peps/pep-0339/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\cs803 \f2\ul\cf1 PEP 339: Design of the CPython compiler}}}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2  \endash  probably the most important and comprehensive piece of official documentation for the Python compiler. Being very short, it painfully displays the scarcity of good documentation of the internals of Python.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 "Python Compiler Internals" \endash  an article by Thomas Lee\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 "Python: Design and Implementation" \endash  a presentation by Guido van Rossum\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Python (2.5) Virtual Machine, A guided tour \endash  a presentation by Peter Tr\u246 ?ger\par
}}{\pard \nisusnos \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10480 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10880 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl From here on, references to files in the Python source are given relatively to the root of the source tree, which is the directory where you run \f3\fs20 configure\f2\fs24  and \f3\fs20 make\f2\fs24  to build Python.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10480
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10880 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl This demonstrates a common technique I use when modifying source code I\rquote m not familiar with: work by similarity. This principle won\rquote t solve all your problems, but it can definitely ease the process. Since everything that has to be done for \f3\fs20 while\f2\fs24  also has to be done for \f3\fs20 until\f2\fs24 , it serves as a pretty good guideline.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10480
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10880 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/#id3"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [3]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl By the way, without this code there\rquote s a compiler warning for \f3\fs20 Python/symtable.c\f2\fs24 . The compiler notices that the \f3\fs20 Until_kind\f2\fs24  enumeration value isn\rquote t handled in the switch statement of \f3\fs20 symtable_visit_stmt\f2\fs24  and complains. It\rquote s always important to check for compiler warnings!\cell }}\row
}\pard \plain {\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b Python internals: Symbol tables, part 1\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 September 18th, 2010 at 8:03 am\fs24 \par
{\f1\fs28\b Introduction\par
}This article is the first in a short series in which I intend to explain how CPython }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/#id5"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  implements and uses symbol tables in its quest to compile Python source code into bytecode. In this part I will explain what a symbol table is and show how the general concepts apply to Python. In the second part I will delve into the implementation of symbol tables in the core of CPython.\par
{\f1\fs28\b So what is a symbol table?\par
}As usual, it\rquote
s hard to beat }}{\field {\*\fldinst HYPERLINK "http://en.wikipedia.org/wiki/Symbol_table"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 Wikipedia}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  for a succinct definition:\par
In computer science, a symbol table is a data structure used by a language translator such as a compiler or interpreter, where each identifier in a program\rquote s source code is associated with information relating to its declaration or appearance in the source, such as its type, scope level and sometimes its location.\par
Symbol tables are used by practically all compilers. They\rquote re especially important in statically typed languages where all variables have types and type checking by the compiler is an important part of the front-end.\par
Consider this C code:\par
{\f4\fs20\b\cf2 int}\f3
\fs20  {\cf2 main}()\par
\{\par
    {\f4\b\cf2 int} aa, bb;\par
    bb = *aa;\par
    \{\par
        {\f4\b\cf2 int}* aa;\par
        bb = *aa;\par
    \}\par
    {\f4\b\cf2 return} {\cf4 0};\par
\}\f0
\fs24 \par
\f2 There are two distinct assignments of the form \f3\fs20 bb = *aa\f2\fs24  here, but only the second one is legal. The compiler throws the following error when it sees the first one:\par
\f3\fs20 error: invalid type argument of \lquote unary *\rquote  (have \lquote int\rquote )\f0\fs24 \par
\f2 How does the compiler know that the \f3\fs20 *\f2\fs24  operator is given an argument of type \f3\fs20 int\f2\fs24 , which is invalid for this operator? The answer is: the symbol table. The compiler sees \f3\fs20 *aa\f2\fs24  and asks itself what the type of \f3\fs20 aa\f2\fs24  is. To answer this question it consults the symbol table it constructed earlier. The symbol table contains the declared types for all variables the compiler encountered in the code.\par
This example demonstrates another important concept \endash  for most languages a single symbol table with information about all variables won\rquote t do. The second assignment is valid, because in the internal scope created by the curly braces \f3\fs20 aa\f2\fs24  is redefined to be of a pointer type. Thus, to correctly compile such code the C compiler has to keep a separate symbol table per scope }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/#id6"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
{\f1\fs28\b A digression: "variables" in Python\par
}So far I\rquote
ve been using the term "variable" liberally. Just to be on the safe side, let\rquote s clarify what is meant by variable in Python. Formally, Python doesn\rquote t really have variables in the sense C has. Rather, Python has symbolic names bound to objects:\par
\f3\fs20 aa = [{\cf4 1}, {\cf4 2}, {\cf4 3}]\par
bb = aa\par
aa[{\cf4 0}] = {\cf4 666}\f0
\fs24 \par
\f2 In this code, \f3\fs20 aa\f2\fs24  is a name bound to a list object. \f3\fs20 bb\f2\fs24  is a name bound to the same object. The third line modifies the list through \f3\fs20 aa\f2\fs24 , and if we print out \f3\fs20 bb\f2\fs24  we\rquote ll see the modified list as well.\par
Now, once this is understood, I will still use the term "variable" from time to time since it\rquote s occasionally convenient and everybody\rquote s used to it anyway.\par
{\f1\fs28\b Symbol tables for Python code\par
}Alright, so symbol tables are very useful for type checking. But Python doesn\rquote
t have compile-time type checking (duck typing FTW!), so what does CPython need symbol tables for?\par
The CPython compiler still has to resolve what kinds of variables are used in the code. Variables in Python can be local, global or even bound by a lexically enclosing scope. For example:\par
{\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 outer}(aa):\par
    {\f4\b\cf2 def} {\cf2 inner}():\par
        bb = {\cf4 1}\par
        {\f4\b\cf2 return} aa + bb + cc\par
    {\f4\b\cf2 return} inner\f0\fs24 \par
\f2
The function \f3\fs20 inner\f2\fs24  uses three variables: \f3\fs20 aa\f2\fs24 , \f3\fs20 bb\f2\fs24  and \f3\fs20 cc\f2\fs24 . They\rquote re all different from Python\rquote s point of view: \f3\fs20 aa\f2\fs24  is lexically bound in \f3\fs20 outer\f2\fs24 , \f3\fs20 bb\f2\fs24  is locally bound in \f3\fs20 inner\f2\fs24  itself, and \f3\fs20 cc\f2\fs24  is not bound anywhere in sight, so it\rquote s treated as global. The bytecode generated for \f3\fs20 inner\f2\fs24  shows clearly the different treatment of these variables:\par
\f3\fs20 5           0 LOAD_CONST               1 (1)\par
            3 STORE_FAST               0 (bb)\par
6           6 LOAD_DEREF               0 (aa)\par
            9 LOAD_FAST                0 (bb)\par
           12 BINARY_ADD\par
           13 LOAD_GLOBAL              0 (cc)\par
           16 BINARY_ADD\par
           17 RETURN_VALUE\f0\fs24 \par
\f2 As you can see, different opcodes are used for loading the variables onto the stack prior to applying \f3\fs20 BINARY_ADD\f2\fs24 . \f3\fs20 LOAD_DEREF\f2\fs24  is used for \f3\fs20 aa\f2\fs24 , \f3\fs20 LOAD_FAST\f2\fs24  for \f3\fs20 bb\f2\fs24  and \f3\fs20 LOAD_GLOBAL\f2\fs24  for \f3\fs20 cc\f2\fs24 .\par
At this point, there are three different directions we can pursue on our path to deeper understanding of Python:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 5.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Figure out the exact semantics of variables in Python \endash  when are they local, when are they global and what exactly makes them lexically bound.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 6.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Understand how the CPython compiler knows the difference.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 7.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Learn about the different bytecode opcodes for these variables and how they affect the way the VM runs code.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 I won\rquote t even try going into (1) since it\rquote s a broad topic completely out of the scope of this article. There are plenty of resources online \endash  start with the }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/py3k/reference/executionmodel.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 official}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  and continue Googling until you\rquote re fully enlightened. (3) is also out of scope as I\rquote m currently focusing on the front-end of CPython. If you\rquote re interested, there\rquote s an excellent series of in-depth articles on Python focusing on the back-end, with }}{\field {\*\fldinst HYPERLINK "http://tech.blog.aknin.name/2010/06/05/pythons-innards-naming"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 a nice treatment}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  of this very issue.\par
To answer (2) we need to understand how CPython uses symbol tables, which is what this series of articles is about.\par
{\f1\fs28\b Where symbol tables fit in\par
}A high-level view of the front-end of CPython is:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 1.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls5\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Parse source code into a parse tree\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 2.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls6\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Transform parse tree into an Abstract Syntax Tree\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 3.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls6\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Transform AST into a Control Flow Graph\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 4.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls6\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Emit bytecode based on the Control Flow Graph\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 Symbol tables are created in step 3. The compiler builds a symbol table from the AST representing the Python source code. This symbol table, in conjunction with the AST is then used to generate the control flow graph (CFG) and ultimately the bytecode.\par
{\f1\fs28\b Exploring the symbol table\par
}CPython does a great job exposing some of its internals via standard-library modules }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/#id7"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [3]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . Symbol tables is yet another internal data structure that can be explored from the outside in pure Python code, with the help of the \f3\fs20 symtable\f2\fs24  module. From its description:\par
Symbol tables are generated by the compiler from AST just before bytecode is generated. The symbol table is responsible for calculating the scope of every identifier in the code. symtable provides an interface to examine these tables.\par
The \f3\fs20 symtable\f2\fs24  module provides a lot of information on the various identifiers encountered in Python code. Apart from telling their scope, it allows us to find out which variables are referenced in their scope, assigned in their scope, define new namespaces (like functions) and so on. To help with exploring the symbol table I\rquote ve written the following function that simplifies working with the module:\par
{\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 describe_symbol}(sym):\par
    {\f4\b\cf2 assert} {\cf2 type}(sym) == symtable.Symbol\par
    {\f4\b\cf2 print}({\cf3 "Symbol:"}, sym.get_name())\par
    {\f4\b\cf2 for} prop {\cf5 in} [\par
            {\cf3 'referenced'}, {\cf3 'imported'}, {\cf3 'parameter'},\par
            {\cf3 'global'}, {\cf3 'declared_global'}, {\cf3 'local'},\par
            {\cf3 'free'}, {\cf3 'assigned'}, {\cf3 'namespace'}]:\par
        {\f4\b\cf2 if} {\cf2 getattr}(sym, {\cf3 'is_'} + prop)():\par
            {\f4\b\cf2 print}({\cf3 '    is'}, prop)\f0
\fs24 \par
\f2 Let\rquote s see what it has to say about the \f3\fs20 inner\f2\fs24  function from the example above:\par
\f3\fs20 Symbol: aa\par
    is referenced\par
    is free\par
Symbol: cc\par
    is referenced\par
    is global\par
Symbol: bb\par
    is referenced\par
    is local\par
    is assigned\f0\fs24 \par
\f2 Indeed, we see that the symbol table marks \f3\fs20 aa\f2\fs24  as lexically bound, or "free" (more on this in the next section), \f3\fs20 bb\f2\fs24  as local and \f3\fs20 cc\f2\fs24  as global. It also tells us that all these variables are referenced in the scope of \f3\fs20 inner\f2\fs24  and that \f3\fs20 bb\f2\fs24  is assigned in that scope.\par
The symbol table contains other useful information as well. For example, it can help distinguish between explicitly declared globals and implicit globals:\par
{\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 outer}():\par
    {\f4\b\cf2 global} gg\par
    {\f4\b\cf2 return} ff + gg\f0\fs24 \par
\f2 In this code both \f3\fs20 ff\f2\fs24  and \f3\fs20 gg\f2\fs24  are global to \f3
\fs20 outer\f2\fs24 , but only \f3\fs20 gg\f2\fs24  was explicitly declared \f3\fs20 global\f2\fs24 . The symbol table knows this \endash  the output of \f3\fs20 describe_symbol\f2\fs24  for this function is:\par
\f3\fs20 Symbol: gg\par
    is referenced\par
    is global\par
    is declared_global\par
Symbol: ff\par
    is referenced\par
    is global\f0\fs24 \par
{\f1\fs28\b Free variables\par
}\f2
Unfortunately, there\rquote s a shorthand in the core of Python that may initially confuse readers as to exactly what constitutes a "free" variable. Fortunately, it\rquote s a very slight confusion that\rquote s easy to put in order. The }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/py3k/reference/executionmodel.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 execution model}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  reference says:\par
If a variable is used in a code block but not defined there, it is a free variable.\par
This is consistent with the }}{\field {\*\fldinst HYPERLINK "http://en.wikipedia.org/wiki/Free_variables_and_bound_variables"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 formal definition}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . In the source, however, "free" is actually used as a shorthand for "lexically bound free variable" (i.e. variables for which a binding has been found in an enclosing scope), with "global" being used to refer to all remaining free variables. So when reading the CPython source code it is important to remember that the full set of free variables includes both the variables tagged specifically as "free", as well as those tagged as "global".\par
Thus, to avoid a confusion I say "lexically bound" when I want to refer to the variables actually treated in CPython as free.\par
{\f1\fs28\b Catching errors\par
}Although Python is duck-typed, some things can still be enforced at compile-time. The symbol table is a powerful tool allowing the compiler to catch some errors }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/#id8"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [4]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
For example, it\rquote s not allowed to declare function parameters as global:\par
{\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 outer}(aa):\par
    {\f4\b\cf2 global} aa\f0\fs24 \par
\f2 When compiling this function, the error is caught while constructing the symbol table:\par
\f3\fs20 Traceback (most recent call last):\par
  File "symtab_1.py", line 33, in <module>\par
    table = symtable.symtable(code, '<string>', 'exec')\par
  File "symtable.py", line 13, in symtable\par
    raw = _symtable.symtable(code, filename, compile_type)\par
  File "<string>", line 2\par
SyntaxError: name 'aa' is parameter and global\f0
\fs24 \par
\f2 The symbol table is useful here since it knows that \f3\fs20 aa\f2\fs24  is a parameter in the scope of \f3\fs20 outer\f2\fs24  and when \f3\fs20 global aa\f2\fs24  is encountered it\rquote s a sure sign of an error.\par
Other errors are handled by the symbol table: duplicate argument names in functions, using \f3\fs20 import *\f2\fs24  inside functions, returning values inside generators, and a few more.\par
{\f1\fs28\b Conclusion\par
}This article serves mainly as an introduction for the next one, where I plan to explore the actual implementation of symbol tables in the core of CPython. A symbol table is a tool designed to solve some problems for the compiler, and I hope this article did a fair job describing a few of these problems and related terminology.\par
Special thanks to Nick Coghlan for reviewing this article.\par
}}{\pard \nisusnos \qc\nowidctlpar\sb240 \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10460 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10860 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl You\rquote ll note that in this article I\rquote m using the terms Python and CPython interchangeably. They\rquote re not the same \endash  by Python I mean the language (version 3.x) and by CPython I mean the official C implementation of the compiler + VM. There are several implementations of the Python language in existence, and while they all implement the same specification they may do it differently.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10460
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10860 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl It\rquote s even more complex than that, but we\rquote re not here to talk about C compilers. In the next article I will explain exactly the structure of symbol tables used by CPython.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10460
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10860 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/#id3"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [3]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl I\rquote ve }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2009/11/28/python-internals-working-with-python-asts/"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl previously discussed}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2  how to use the \f3\fs20 ast\f2\fs24  module to tap into the compilation process of CPython.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10460
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10860 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/#id4"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [4]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Actually, if you \f3\fs20 grep\f2\fs24  the CPython source, you\rquote ll find out that a good proportion of \f3\fs20 SyntaxError\f2\fs24  exceptions thrown by the compiler are from \f3\fs20 Python/symtable.c\f2\fs24 .\cell }}\row
}\pard \plain {\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b Python internals: Symbol tables, part 2\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 September 20th, 2010 at 7:59 am\fs24 \par
This is the second part of the article. Make sure you read the }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 first part}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  before this one.\par
In this article I will explain how symbol tables are implemented in the CPython core }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id10"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . The implementation itself is contained mainly in two files, the header \f3\fs20 Include/symtable.h\f2\fs24  and the C source file \f3\fs20 Python/symtable.c\f2\fs24 .\par
My strategy for understanding the implementation will follow Fred Brooks\rquote  advice from his book The Mythical Man-Month:\par
Show me your flowchart and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won\rquote t usually need your flowchart; it\rquote ll be obvious.\par
A more modern translation would be: "The key to understanding a program is to understand its data structures. With that in hand, the algorithms usually become obvious."\par
This is especially true when the data structures of some module closely model the problem this module intends to solve, and the algorithms\rquote  job is to correctly create and use these data structures. Fortunately, this is exactly the case in CPython\rquote s implementation of symbol tables. Without further ado, let\rquote s delve in.\par
{\f1\fs28\b Symbol table entries\par
}The key data structure to study is the symbol table entry, named \f3
\fs20 PySTEntryObject\f2\fs24  }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id11"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
{\f4\fs20\b\cf2 typedef}\f3
\fs20  {\f4\b\cf2 struct} _symtable_entry \{\par
    PyObject_HEAD\par
    PyObject *ste_id;\par
    PyObject *ste_symbols;\par
    PyObject *ste_name;\par
    PyObject *ste_varnames;\par
    PyObject *ste_children;\par
    _Py_block_ty ste_type;\par
    {\f4\b\cf2 int} ste_unoptimized;\par
    {\f4\b\cf2 int} ste_nested;\par
    {\f4\b\cf2 unsigned} ste_free : {\cf4 1};\par
    {\f4\b\cf2 unsigned} ste_child_free : {\cf4 1};\par
    {\f4\b\cf2 unsigned} ste_generator : {\cf4 1};\par
    {\f4\b\cf2 unsigned} ste_varargs : {\cf4 1};\par
    {\f4\b\cf2 unsigned} ste_varkeywords : {\cf4 1};\par
    {\f4\b\cf2 unsigned} ste_returns_value : {\cf4 1};\par
    {\f4\b\cf2 int} ste_lineno;\par
    {\f4\b\cf2 int} ste_opt_lineno;\par
    {\f4\b\cf2 int} ste_tmpname;\par
    {\f4\b\cf2 struct} symtable *ste_table;\par
\} PySTEntryObject;\f0
\fs24 \par
\f2 Before I explain what each field in the structure means, some background is in order. An entry object is created for each block in the Python source code. A block }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/reference/executionmodel.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 is defined}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  as:\par
[...] A piece of Python program text that is executed as a unit. The following are blocks: a module, a function body and a class definition. [...]\par
Therefore, if we have the following definition in our Python source:\par
{\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 outer}(aa):\par
    {\f4\b\cf2 def} {\cf2 inner}():\par
        bb = {\cf4 1}\par
        {\f4\b\cf2 return} aa + bb + cc\par
    dd = aa + inner()\par
    {\f4\b\cf2 return} dd\f0
\fs24 \par
\f2 The definition of \f3\fs20 outer\f2\fs24  creates a block with its body. So does the definition of \f3\fs20 inner\f2\fs24 . In addition, the top-level module in which \f3\fs20 outer\f2\fs24  is defined is also a block. All these blocks are represented by symbol table entries.\par
In essence, each entry is a symbol table on its own, containing information on the symbols in the block it represents. These entries are linked together into hierarchies, to represent nested blocks.\par
Once again, the \f3\fs20 symtable\f2\fs24  module can be used to explore these entries. In the first part of the article I used it to show what CPython knows about the symbols, but here I want to show how entries work. Here\rquote s a function that uses \f3\fs20 symtable\f2\fs24  to show how entries nest:\par
{\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 describe_symtable}(st, recursive={\cf2 True}, indent={\cf4 0}):\par
    {\f4\b\cf2 def} {\cf2 print_d}(s, *args):\par
        prefix = {\cf3 ' '} * indent\par
        {\f4\b\cf2 print}(prefix + s, *args)\par
    {\f4\b\cf2 assert} {\cf2 isinstance}(st, symtable.SymbolTable)\par
    print_d({\cf3 'Symtable: type=%s, id=%s, name=%s'} % (\par
                st.get_type(), st.get_id(), st.get_name()))\par
    print_d({\cf3 '  nested:'}, st.is_nested())\par
    print_d({\cf3 '  has children:'}, st.has_children())\par
    print_d({\cf3 '  identifiers:'}, {\cf2 list}(st.get_identifiers()))\par
    {\f4\b\cf2 if} recursive:\par
        {\f4\b\cf2 for} child_st {\cf5 in} st.get_children():\par
            describe_symtable(child_st, recursive, indent + {\cf4 5})\f0
\fs24 \par
\f2 When executed on the symbol table created from the Python code we saw earlier, it prints out:\par
\f3\fs20 Symtable: type=module, id=164192096, name=top\par
  nested: False\par
  has children: True\par
  identifiers: ['outer']\par
     Symtable: type=function, id=164192056, name=outer\par
       nested: False\par
       has children: True\par
       identifiers: ['aa', 'dd', 'inner']\par
          Symtable: type=function, id=164191736, name=inner\par
            nested: True\par
            has children: False\par
            identifiers: ['aa', 'cc', 'bb']\f0\fs24 \par
\f2 Note how entries are nested. The top-level entry representing the module has the entry for \f3\fs20 outer\f2\fs24  as its child, which in turn has the entry for \f3\fs20 inner\f2\fs24  as its child.\par
With this understood, we can go over the fields of the \f3\fs20 PySTEntryObject\f2\fs24  struct and explain what each one means }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id12"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [3]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . Note that I use the terms "block" and "entry" interchangeably.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_id\f2\fs24 : a unique integer ID for the entry taken as the Python object ID of the AST node it was created from.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_symbols\f2\fs24 : the actual symbol table of this entry, a Python \f3\fs20 dict\f2\fs24  object mapping symbol names to flags that describe them. See the \f3\fs20 describe_symbol\f2\fs24  function }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\cs803 \f2\ul\ulc1\cf1 in part 1 of the article}}}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2  to understand what information is stored in the flags for each symbol. All the symbols that are used in the block (whether defined or only referenced) are mapped here.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_name\f2\fs24 : block name (if applicable). For example, for the function \f3\fs20 outer\f2\fs24 , the name is \f3\fs20 outer\f2\fs24 . Used primarily for debugging and error reporting.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_varnames\f2\fs24 : the name of the field (as well as the comment that follows it) is somewhat misleading }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id13"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\cs803 \f2\ul\ulc1\cf1 [4]}}}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 . It\rquote s actually a list of the parameters of the block. For example, for the \f3\fs20 outer\f2\fs24  function in the example it\rquote s a list with the single name \f3\fs20 aa\f2\fs24 .\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_children\f2\fs24 : list of child blocks (also \f3\fs20 PySTEntryObject\f2\fs24  objects). As we saw earlier, blocks are nested, modeling the nesting of scopes in the Python source.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_type\f2\fs24 : a value of the enumeration type \f3\fs20 _Py_block_ty\f2\fs24  which has three possible values: \f3\fs20 FunctionBlock\f2\fs24 , \f3\fs20 ClassBlock\f2\fs24 , \f3\fs20 ModuleBlock\f2\fs24  for the three kinds of blocks supported by the symbol table.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_unoptimized\f2\fs24 : this flag helps deal with some special blocks (top-level and those containing \f3\fs20 import *\f2\fs24 ). It\rquote s safe to ignore it for our purposes.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_nested\f2\fs24 : An integer flag: 1 if it\rquote s a function block nested in some other function block (like our \f3\fs20 inner\f2\fs24  function), 0 otherwise.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Next come some other flags with information about the block: \f3\fs20 ste_free\f2\fs24 , \f3\fs20 ste_child_free\f2\fs24 , \f3\fs20 ste_generator\f2\fs24 , \f3\fs20 ste_varargs\f2\fs24 , \f3\fs20 ste_varkeywords\f2\fs24  and \f3\fs20 ste_returns_value\f2\fs24 . The comments after these flags describe them quite well.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_lineno\f2\fs24 : number of the first line of the block in the Python source \endash  taken directly from the AST.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_opt_lineno\f2\fs24 : related to the \f3\fs20 ste_unoptimized\f2\fs24  flag. Again, we\rquote ll ignore it for now.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_tmpname\f2\fs24 : used to generate temporary names of variables in comprehensions\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste_table\f2\fs24 : link to the \f3\fs20 symtable\f2\fs24  object this entry is part of.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 As I mentioned above, the entry is the key data structure in CPython\rquote s symbol table code. When the symbol table creation algorithm finishes running, we get a set of inter-linked (for nesting) entries which contain information about all the symbols defined and used in our code. These entries are used in later stages of the compiler to generate bytecode from the AST.\par
{\f1\fs28\b symtable\par
}\f3
\fs20 symtable\f2\fs24  is less important for the usage of symbol tables by the compiler, but it\rquote s essential for the initial construction of a symbol table from the AST.\par
The symbol table construction algorithm uses an instance of the \f3\fs20 symtable\f2\fs24  structure to keep its state as it walks the AST recursively and builds entries for the blocks it finds.\par
Here are the fields of \f3\fs20 symtable\f2\fs24  annotated:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls7\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 st_filename\f2\fs24 : name of the file being compiled \endash  used for generating meaningful warnings and errors.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 st_cur\f2\fs24 : the current entry (\f3\fs20 PySTEntryObject\f2\fs24 ) the construction algorithm is in. Think of it (together with \f3\fs20 st_stack\f2\fs24 ) as the current state of the algorithm as it walks the AST nodes recursively to create new entries.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 st_top\f2\fs24 : top-level entry for the module. Serves as the entry-point for the second pass of the symbol table construction algorithm.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 st_blocks\f2\fs24 : a dict mapping entry IDs (\f3\fs20 ste_id\f2\fs24 ) to entry objects. Can be used to find the entry for some AST node.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 st_stack\f2\fs24 : a list representing a stack of entries. Used when working on nested blocks.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 st_global\f2\fs24 : direct link to the \f3\fs20 ste_symbols\f2\fs24  dict of the top-level module entry (\f3\fs20 st_top\f2\fs24 ). Useful for accessing global (module-level) definitions from anywhere.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 st_nblocks\f2\fs24  / \f3\fs20 st_future\f2\fs24 : these fields aren\rquote t being used anywhere in the source so we\rquote ll ignore them.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 st_private\f2\fs24 : the name of the current class. This field is used for "mangling" private variables in classes }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id14"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\cs803 \f2\ul\ulc1\cf1 [5]}}}}{\pard \nisusnos \nowidctlpar\sb240\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 .\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f1\fs28\b Midway recap: what we have so far\par
}{\f2 Now that we have the data structures covered, it should be much simpler to understand the code implementing symbol table construction. There\rquote s no need to memorize the meanings of all fields \endash  they can serve as a reference when reading the rest of the article and/or the source code. But it\rquote s definitely recommended to go over them at least once to have a general sense of what each data structure contains.\par
{\f1\fs28\b Constructing the symbol table: algorithm outline\par
}Once we have a clear notion in our head of what information the symbol table eventually contains, the algorithm for constructing it is quite obvious. In the following diagram I\rquote
ve sketched an outline:\par
The algorithm is divided into two passes }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id15"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [6]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . The first pass creates the basic structure of entries modeling the blocks in the source code and marks some of the simple information easily available directly in the AST \endash  for example, which symbols are defined and referenced in each block.\par
The second pass walks the symbol table and infers the less obvious information about symbols: which symbols are free, which are implicitly global, etc.\par
{\f1\fs28\b Constructing the symbol table: first pass\par
}The implementation of the first pass of the algorithm consumes a good chunk of the source-code of \f3
\fs20 Python/symtable.c\f2\fs24 , but it\rquote s actually quite simple to understand, because the bulk of it exists to deal with the large variety of AST nodes Python generates.\par
First, let\rquote s take a look at how new blocks get created. When a new block-defining-statement (such as the top-level module or a function/class definition) is encountered, \f3\fs20 symtable_enter_block\f2\fs24  is called. It creates a new block and handles nesting by using \f3\fs20 st->st_stack\f2\fs24  }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id16"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [7]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , making sure \f3\fs20 st->st_cur\f2\fs24  always points to the currently processed block. The complementary function \f3\fs20 symtable_exit_block\f2\fs24  is called when a block has been processed. It uses \f3\fs20 st->st_stack\f2\fs24  to roll \f3\fs20 st->st_cur\f2\fs24  back to the enclosing block.\par
The next function that\rquote s important to understand is \f3\fs20 symtable_add_def\f2\fs24 . Its name could be clearer, though, since it\rquote s being called not only for symbol definitions but also for symbol uses (recall that the symbol table keeps track of which symbols are being used in which blocks). What it does is basically add a flag to the symbols dict (\f3\fs20 ste_symbols\f2\fs24 ) of an entry that specifies the symbol\rquote s definition or use.\par
The rest of the code of the first pass is just a bunch of AST visiting functions that are implemented in a manner similar to other AST walkers in the CPython code base. There\rquote s a \f3\fs20 symtable_visit_<type>\f2\fs24  function for every major \f3\fs20 <type>\f2\fs24  of AST node the symbol table is interested in, along with a family of \f3\fs20 VISIT_*\f2\fs24  macros that help keep the code shorter.\par
I will pick a couple of examples to demonstrate the stuff explained earlier.\par
The most interesting would be handling function definitions in \f3\fs20 symtable_visit_stmt\f2\fs24 , under \f3\fs20 case FunctionDef_kind\f2\fs24 :\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls9\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 First the function\rquote s name is added as a definition to the current block\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls10\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Next, default values, annotations and decorators are recursively visited.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls10\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Since the function definition creates a new block, \f3\fs20 symtable_enter_block\f2\fs24  is called, only after which the actual function arguments and body get visited. Then, \f3\fs20 symtable_exit_block\f2\fs24  is called to get back to the parent block.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 Another interesting example is the \f3\fs20 case Yield_kind\f2\fs24  code of \f3\fs20 symtable_visit_expr\f2\fs24  that handles \f3\fs20 yield\f2\fs24  statements. After visiting the yielded value (if any), the current block is marked as a generator. Since returning values from generators isn\rquote t allowed, the algorithm raises a syntax error if the block is also marked as returning a value }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id17"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [8]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
The output of the first pass is a structurally complete symbol table, consisting of nested entries that model the blocks in the source code. At this stage the symbol table contains only partial information about symbols, however. Although it already maps all symbols defined and used in the code, and even flags special cases such as global symbols and generators, it still lacks some information, such as the distinction between free symbols that are defined in enclosing scopes and implicitly global symbols. This is the job of the second pass }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id18"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [9]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
{\f1\fs28\b Constructing the symbol table: second pass\par
}The second pass is actually documented not badly in the comments inside \f3
\fs20 Python/symtable.c\f2\fs24 . However, these comments are scattered all over the place, so I\rquote ll try to provide a quick summary that should serve as a good starting point for reading the commented source. I will use a concrete example along with my explanation to aid understanding.\par
Here\rquote s our sample Python code once again:\par
{\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 outer}(aa):\par
    {\f4\b\cf2 def} {\cf2 inner}():\par
        bb = {\cf4 1}\par
        {\f4\b\cf2 return} aa + bb + cc\par
    dd = aa + inner()\par
    {\f4\b\cf2 return} dd\f0
\fs24 \par
\f2 Let\rquote s focus on the symbols used in \f3\fs20 inner\f2\fs24 . After the first pass, the algorithm knows the following:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 8.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 bb\f2\fs24  is bound in \f3\fs20 inner\f2\fs24 \par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 9.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 aa\f2\fs24  is bound (as a parameter) in \f3\fs20 outer\f2\fs24 \par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 10.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 aa\f2\fs24 , \f3\fs20 bb\f2\fs24 , \f3\fs20 cc\f2\fs24  are used in \f3\fs20 inner\f2\fs24 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 With this information, the algorithm should infer that \f3\fs20 aa\f2\fs24  is free and \f3\fs20 cc\f2\fs24  is global. For this, it runs another analysis, this time on the entries, pushing information from parent blocks into child blocks and back up again.\par
For example, when it analyzes \f3\fs20 inner\f2\fs24 , the second pass takes along a set of all variables bound in \f3\fs20 inner\f2\fs24 \lquote s parent (enclosing) scopes \endash  \f3\fs20 aa\f2\fs24  and \f3\fs20 dd\f2\fs24 . In the analysis of \f3\fs20 inner\f2\fs24 , seeing that \f3\fs20 aa\f2\fs24  is used but not defined in \f3\fs20 inner\f2\fs24  but is defined in an enclosing scope, it can go on and mark \f3\fs20 aa\f2\fs24  as a free variable in the \f3\fs20 ste_symbols\f2\fs24  dict for \f3\fs20 inner\f2\fs24 \lquote s entry. Similarly, seeing that \f3\fs20 cc\f2\fs24  is not defined in any enclosing scope, it marks it global.\par
The information has to travel back up as well. An implementation detail of CPython which we won\rquote t get into in this article is "cells" which are used to implement free variables. For the purposes of the symbol table, all we need to know is that the symbol table is required to mark which variables serve as cells in an enclosing scopes for free variables in child scopes. So the algorithm should mark \f3\fs20 aa\f2\fs24  as a cell variable in \f3\fs20 outer\f2\fs24 . For this, it should first analyze \f3\fs20 inner\f2\fs24  and find out it\rquote s free there.\par
The most important function of the second pass is \f3\fs20 analyze_block\f2\fs24  \endash  it is being called over and over again for each block in the symbol table. The arguments of \f3\fs20 analyze_block\f2\fs24  are:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls11\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 ste\f2\fs24 : The symbol table entry for the block to analyze\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls12\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 bound\f2\fs24 : a set of all variables bound in enclosing scopes\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls12\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 global\f2\fs24 : a set of all variables declared global in enclosing scopes\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls12\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 free\f2\fs24 : output from the function \endash  the set of all free variables in this entry and its enclosed scopes\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 Using a couple of auxiliary functions, \f3\fs20 analyze_block\f2\fs24  calls itself recursively on the child blocks of the given block, passing around and gathering the required information. Apart from creating the \f3\fs20 free\f2\fs24  set for the enclosing scope, \f3\fs20 analyze_block\f2\fs24  modifies \f3\fs20 ste\f2\fs24  as it finds new information about symbols in it.\par
Special thanks to Nick Coghlan for reviewing this article.\par
}}{\pard \nisusnos \qc\nowidctlpar\sb240 \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx440 \clvertalt \clftsWidth3 \clwWidth10400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl The specific version I\rquote m describing is a relatively up-to-date snapshot of the \f3\fs20 py3k\f2\fs24  branch, in other words the "cutting edge" of CPython.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx440 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl The struct declaration in \f3\fs20 Include/symtable.h\f2\fs24  has short comments after each field. I\rquote ve removed those intentionally.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx440 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id3"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [3]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl It helps to have the relevant code open in a separate window while reading this article, in particular this section. Also keep in mind that many of the fields are implemented as actual Python objects (created by the CPython C API), so when I say a list or a dict it\rquote s an actual Python list or a dict, the interaction with which is via its C API.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx440 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id4"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [4]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl The reason for the confusing name may be this list\rquote s later role in the compiler\rquote s flow in the creation of a code object. The \f3\fs20 co_varnames\f2\fs24  field of a code object contains the names of all local variables in a block starting with the parameter names (actually taken by the compiler from the \f3\fs20 ste_varnames\f2\fs24  field of the symbol table).\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx440 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id5"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [5]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Look up "python private name mangling" on Google if you\rquote re not familiar with the mangling of private (marked by starting with two or more underscores) identifiers in Python classes.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx440 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id6"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [6]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl You may be wondering why two passes are required and a single one isn\rquote t enough. It\rquote s a good question that ponders some philosophical and stylistic issues behind the practice of software development. My guess is that while the task could\rquote ve been accomplished in a single pass, the multi-pass approach allows the code to be simplified at the cost of a very modest (if any) hit in performance. Sometimes splitting algorithms into multiple steps makes them much easier to grasp \endash  readability and maintainability are important traits of well-written code.\cell }}\row
}\pard \plain {\pard \nisusnos \nowidctlpar\sb240 {\f2 Consider, for example, this code:\par
{\f4\fs20\b\cf2 def}\f3\fs20  {\cf2 outer}():\par
    {\f4\b\cf2 def} {\cf2 inner}():\par
        bb = {\cf4 1}\par
        {\f4\b\cf2 return} aa + bb + cc\par
    aa = {\cf4 2}\par
    {\f4\b\cf2 return} inner\f0
\fs24 \par
\f2 Here, \f3\fs20 aa\f2\fs24  is free in \f3\fs20 inner\f2\fs24 , lexically bound to the \f3\fs20 aa\f2\fs24  defined in \f3\fs20 outer\f2\fs24 . But a one-pass algorithm would see \f3\fs20 inner\f2\fs24  before it ever saw the definition of \f3\fs20 aa\f2\fs24 , so to implement this correctly it would be forced to use some complex data structure to remember the variable uses it saw. With a two-pass algorithm, handling this case is much simpler.}}{\pard \nisusnos \nowidctlpar\sb240 \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id7"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [7]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Throughout the code \f3\fs20 st\f2\fs24  refers to the \f3\fs20 symtable\f2\fs24  object that\rquote s being passed into functions, and \f3\fs20 ste\f2\fs24  to an entry object.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10440
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id8"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [8]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl As an exercise, think whether this ensures that all generators returning values are caught as errors. Hint #1: what happens if the \f3\fs20 yield\f2\fs24  is found before the \f3\fs20 return\f2\fs24 ? Hint #2: Locate the code for the handling of \f3\fs20 return\f2\fs24  statements by the first pass.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10440
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10840 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/#id9"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [9]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Here and on I\rquote m presenting a somewhat simplified view of the second pass. There are further complications like variables declared global in enclosing scopes and referenced in enclosed scopes, that affect the results. I\rquote m ignoring this on purpose to try and focus on the main aim of the second pass. Any source code has important special cases and trying to accurately summarize 1000 lines of code in a few paragraphs of text is an endeavor destined to fail.\cell }}\row
}\pard \plain {\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b Understanding UnboundLocalError in Python\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 May 15th, 2011 at 5:43 am\fs24 \par
If you\rquote re closely following the }}{\field {\*\fldinst HYPERLINK "http://stackoverflow.com/questions/tagged/python"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 Python tag on StackOverflow}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , you\rquote ll notice that the same question comes up at least once a week. The question goes on like this:\par
\f3\fs20 x = {\cf4 10}\par
{\f4\b\cf2 def} {\cf2 foo}():\par
    x += {\cf4 1}\par
    {\f4\b\cf2 print} x\par
foo()\f0
\fs24 \par
\f2 Why, when run, this results in the following error:\par
\f3\fs20 Traceback (most recent call last):\par
  File "unboundlocalerror.py", line 8, in <module>\par
    foo()\par
  File "unboundlocalerror.py", line 4, in foo\par
    x += 1\par
UnboundLocalError: local variable 'x' referenced before assignment\f0\fs24 \par
\f2 There are a few variations on this question, with the same core hiding underneath. Here\rquote s one:\par
\f3\fs20 lst = [{\cf4 1}, {\cf4 2}, {\cf4 3}]\par
{\f4\b\cf2 def} {\cf2 foo}():\par
    lst.append({\cf4 5})   {\cf6 # OK}\par
    {\cf6 #lst += [5]     # ERROR here}\par
foo()\par
{\f4\b\cf2 print} lst\f0
\fs24 \par
\f2 Running the \f3\fs20 lst.append(5)\f2\fs24  statement successfully appends 5 to the list. However, substitute it for \f3\fs20 lst += [5]\f2\fs24 , and it raises \f3\fs20 UnboundLocalError\f2\fs24 , although at first sight it should accomplish the same.\par
Although this exact question is answered in Python\rquote s official FAQ (}}{\field {\*\fldinst HYPERLINK "http://docs.python.org/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 right here}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 ), I decided to write this article with the intent of giving a deeper explanation. It will start with a basic FAQ-level answer, which should satisfy one only wanting to know how to "solve the damn problem and move on". Then, I will dive deeper, looking at the formal definition of Python to understand what\rquote s going on. Finally, I\rquote ll take a look what happens behind the scenes in the implementation of CPython to cause this behavior.\par
{\f1\fs28\b The simple answer\par
}As mentioned above, this problem is covered in the Python FAQ. For completeness, I want to explain it here as well, quoting the FAQ when necessary.\par
Let\rquote
s take the first code snippet again:\par
\f3\fs20 x = {\cf4 10}\par
{\f4\b\cf2 def} {\cf2 foo}():\par
    x += {\cf4 1}\par
    {\f4\b\cf2 print} x\par
foo()\f0\fs24 \par
\f2 So where does the exception come from? Quoting the FAQ:\par
This is because when you make an assignment to a variable in a scope, that variable becomes local to that scope and shadows any similarly named variable in the outer scope.\par
But \f3
\fs20 x += 1\f2\fs24  is similar to \f3\fs20 x = x + 1\f2\fs24 , so it should first read \f3\fs20 x\f2\fs24 , perform the addition and then assign back to \f3\fs20 x\f2\fs24 . As mentioned in the quote above, Python considers \f3\fs20 x\f2\fs24  a variable local to \f3\fs20 foo\f2\fs24 , so we have a problem \endash  a variable is read (referenced) before it\rquote s been assigned. Python raises the \f3\fs20 UnboundLocalError\f2\fs24  exception in this case }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id7"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
So what do we do about this? The solution is very simple \endash  Python has the }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/reference/simple_stmts.html#the-global-statement"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 global statement}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  just for this purpose:\par
\f3\fs20 x = {\cf4 10}\par
{\f4\b\cf2 def} {\cf2 foo}():\par
    {\f4\b\cf2 global} x\par
    x += {\cf4 1}\par
    {\f4\b\cf2 print} x\par
foo()\f0
\fs24 \par
\f2 This prints \f3\fs20 11\f2\fs24 , without any errors. The \f3\fs20 global\f2\fs24  statement tells Python that inside \f3\fs20 foo\f2\fs24 , \f3\fs20 x\f2\fs24  refers to the global variable \f3\fs20 x\f2\fs24 , even if it\rquote s assigned in \f3\fs20 foo\f2\fs24 .\par
Actually, there is another variation on the question, for which the answer is a bit different. Consider this code:\par
{\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 external}():\par
    x = {\cf4 10}\par
    {\f4\b\cf2 def} {\cf2 internal}():\par
        x += {\cf4 1}\par
        {\f4\b\cf2 print}(x)\par
    internal()\par
external()\f0
\fs24 \par
\f2 This kind of code may come up if you\rquote re into closures and other techniques that use Python\rquote s lexical scoping rules. The error this generates is the familiar \f3\fs20 UnboundLocalError\f2\fs24 . However, applying the "global fix":\par
{\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 external}():\par
    x = {\cf4 10}\par
    {\f4\b\cf2 def} {\cf2 internal}():\par
        {\f4\b\cf2 global} x\par
        x += {\cf4 1}\par
        {\f4\b\cf2 print}(x)\par
    internal()\par
external()\f0
\fs24 \par
\f2 Doesn\rquote t help \endash  another error is generated: \f3\fs20 NameError: global name 'x' is not defined\f2\fs24 . Python is right here \endash  after all, there\rquote s no global variable named \f3\fs20 x\f2\fs24 , there\rquote s only an \f3\fs20 x\f2\fs24  in \f3\fs20 external\f2\fs24 . It may be not local to \f3\fs20 internal\f2\fs24 , but it\rquote s not global. So what can you do in this situation? If you\rquote re using Python 3, you have the \f3\fs20 nonlocal\f2\fs24  keyword. Replacing \f3\fs20 global\f2\fs24  by \f3\fs20 nonlocal\f2\fs24  in the last snippet makes everything work as expected. \f3\fs20 nonlocal\f2\fs24  is a new statement in Python 3, and there is no equivalent in Python 2 }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id8"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
{\f1\fs28\b The formal answer\par
}Assignments in Python are used to bind names to values and to modify attributes or items of mutable objects. I could find two places in the Python (2.x) documentation where it\rquote
s defined how an assignment to a local variable works.\par
One is section 6.2 "Assignment statements" in the }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/reference/simple_stmts.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 Simple Statements}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  chapter of the language reference:\par
Assignment of an object to a single target is recursively defined as follows. If the target is an identifier (name):\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 If the name does not occur in a global statement in the current code block: the name is bound to the object in the current local namespace.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Otherwise: the name is bound to the object in the current global namespace.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 Another is section 4.1 "Naming and binding" of the }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/reference/executionmodel.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 Execution model}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  chapter:\par
If a name is bound in a block, it is a local variable of that block.\par
[...]\par
When a name is used in a code block, it is resolved using the nearest enclosing scope. [...] If the name refers to a local variable that has not been bound, a UnboundLocalError exception is raised.\par
This is all clear, but still, another small doubt remains. All these rules apply to assignments of the form \f3\fs20 var = value\f2\fs24  which clearly bind \f3\fs20 var\f2\fs24  to \f3\fs20 value\f2\fs24 . But the code snippets we\rquote re having a problem with here have the \f3\fs20 +=\f2\fs24  assignment. Shouldn\rquote t that just modify the bound value, without re-binding it?\par
Well, no. \f3\fs20 +=\f2\fs24  and its cousins (\f3\fs20 -=\f2\fs24 , \f3\fs20 *=\f2\fs24 , etc.) are what Python calls "}}{\field {\*\fldinst HYPERLINK "http://docs.python.org/reference/simple_stmts.html#augmented-assignment-statements"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 augmented assignment statements}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 " [emphasis mine]:\par
An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, {\f1\b and assigns the result to the original target}. The target is only evaluated once.\par
An augmented assignment expression like \f3
\fs20 x += 1\f2\fs24  {\f1\b can be rewritten as} \f3\fs20 x = x + 1\f2\fs24  to achieve a similar, but not exactly equal effect. In the augmented version, \f3\fs20 x\f2\fs24  is only evaluated once. Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead.\par
With the exception of assigning to tuples and multiple targets in a single statement, {\f1\b the assignment done by augmented assignment statements is handled the same way as normal assignments}. Similarly, with the exception of the possible in-place behavior, the binary operation performed by augmented assignment is the same as the normal binary operations.\par
So when earlier I said that \f3
\fs20 x += 1\f2\fs24  is similar to \f3\fs20 x = x + 1\f2\fs24 , I wasn\rquote t telling all the truth, but it was accurate with respect to binding. Apart for possible optimization, \f3\fs20 +=\f2\fs24  counts exactly as \f3\fs20 =\f2\fs24  when binding is considered. If you think carefully about it, it\rquote s unavoidable, because some types Python works with are immutable. Consider strings, for example:\par
\f3\fs20 x = {\cf3 "abc"}\par
x += {\cf3 "def"}\f0
\fs24 \par
\f2 The first line binds \f3\fs20 x\f2\fs24  to the value "abc". The second line doesn\rquote t modify the value "abc" to be "abcdef". Strings are immutable in Python. Rather, it creates the new value "abcdef" somewhere in memory, and re-binds \f3\fs20 x\f2\fs24  to it. This can be seen clearly when examining the object ID for \f3\fs20 x\f2\fs24  before and after the \f3\fs20 +=\f2\fs24 :\par
\f3\fs20 >>> x = {\cf3 "abc"}\par
>>> {\cf2 id}(x)\par
{\cf4 11173824}\par
>>> x += {\cf3 "def"}\par
>>> {\cf2 id}(x)\par
{\cf4 32831648}\par
>>> x\par
{\cf3 'abcdef'}\f0
\fs24 \par
\f2 Note that some types in Python are mutable. For example, lists can actually be modified in-place:\par
\f3\fs20 >>> y = [{\cf4 1}, {\cf4 2}]\par
>>> {\cf2 id}(y)\par
{\cf4 32413376}\par
>>> y += [{\cf4 2}, {\cf4 3}]\par
>>> {\cf2 id}(y)\par
{\cf4 32413376}\par
>>> y\par
[{\cf4 1}, {\cf4 2}, {\cf4 2}, {\cf4 3}]\par
id(y)\f2
\fs24  didn\rquote t change after \f3\fs20 +=\f2\fs24 , because the object \f3\fs20 y\f2\fs24  referenced was just modified. Still, Python re-bound \f3\fs20 y\f2\fs24  to the same object }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id9"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [3]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
{\f1\fs28\b The "too much information" answer\par
}This section is of interest only to those curious about the implementation internals of Python itself.\par
One of the stages in the compilation of Python into bytecode is building the symbol table }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id10"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [4]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . An important goal of building the symbol table is for Python to be able to mark the scope of variables it encounters \endash  which variables are local to functions, which are global, which are free (lexically bound) and so on.\par
When the symbol table code sees a variable is assigned in a function, it marks it as local. Note that it doesn\rquote t matter if the assignment was done before usage, after usage, or maybe not actually executed due to a condition in code like this:\par
\f3\fs20 x = {\cf4 10}\par
{\f4\b\cf2 def} {\cf2 foo}():\par
    {\f4\b\cf2 if} something_false_at_runtime:\par
        x = {\cf4 20}\par
    {\f4\b\cf2 print}(x)\f0
\fs24 \par
\f2 We can use the \f3\fs20 symtable\f2\fs24  module to examine the symbol table information gathered on some Python code during compilation:\par
{\f4\fs20\b\cf2 import}\f3\fs20
 {\cf2 symtable}\par
code = {\cf3 '''}\par
{\cf3 x = 10}\par
{\cf3 def foo():}\par
{\cf3     x += 1}\par
{\cf3     print(x)}\par
{\cf3 '''}\par
table = symtable.symtable(code, {\cf3 '<string>'}, {\cf3 'exec'})\par
foo_namespace = table.lookup({\cf3 'foo'}).get_namespace()\par
sym_x = foo_namespace.lookup({\cf3 'x'})\par
{\f4\b\cf2 print}(sym_x.get_name())\par
{\f4\b\cf2 print}(sym_x.is_local())\f0
\fs24 \par
\f2 This prints:\par
\f3\fs20 x\par
True\f0\fs24 \par
\f2 So we see that \f3\fs20 x\f2\fs24  was marked as local in \f3\fs20 foo\f2\fs24 . Marking variables as local turns out to be important for optimization in the bytecode, since the compiler can generate a special instruction for it that\rquote s very fast to execute. There\rquote s an excellent }}{\field {\*\fldinst HYPERLINK "http://tech.blog.aknin.name/2010/06/05/pythons-innards-naming/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 article here}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  explaining this topic in depth; I\rquote ll just focus on the outcome.\par
The \f3\fs20 compiler_nameop\f2\fs24  function in \f3\fs20 Python/compile.c\f2\fs24  handles variable name references. To generate the correct opcode, it queries the symbol table function \f3\fs20 PyST_GetScope\f2\fs24 . For our \f3\fs20 x\f2\fs24 , this returns a bitfield with \f3\fs20 LOCAL\f2\fs24  in it. Having seen \f3\fs20 LOCAL\f2\fs24 , \f3\fs20 compiler_nameop\f2\fs24  generates a \f3\fs20 LOAD_FAST\f2\fs24 . We can see this in the disassembly of \f3\fs20 foo\f2\fs24 :\par
\f3\fs20 35           0 LOAD_FAST                0 (x)\par
             3 LOAD_CONST               1 (1)\par
             6 INPLACE_ADD\par
             7 STORE_FAST               0 (x)\par
36          10 LOAD_GLOBAL              0 (print)\par
            13 LOAD_FAST                0 (x)\par
            16 CALL_FUNCTION            1\par
            19 POP_TOP\par
            20 LOAD_CONST               0 (None)\par
            23 RETURN_VALUE\f0\fs24 \par
\f2 The first block of instructions shows what \f3\fs20 x += 1\f2\fs24  was compiled to. You will note that already here (before it\rquote s actually assigned), \f3\fs20 LOAD_FAST\f2\fs24  is used to retrieve the value of \f3\fs20 x\f2\fs24 .\par
This \f3\fs20 LOAD_FAST\f2\fs24  is the instruction that will cause the \f3\fs20 UnboundLocalError\f2\fs24  exception to be raised at runtime, because it is actually executed before any \f3\fs20 STORE_FAST\f2\fs24  is done for \f3\fs20 x\f2\fs24 . The gory details are in the bytecode interpreter code in \f3\fs20 Python/ceval.c\f2\fs24 :\par
\f3\fs20 TARGET(LOAD_FAST)\par
    x = GETLOCAL(oparg);\par
    {\f4\b\cf2 if} (x != {\cf2 NULL}) \{\par
        Py_INCREF(x);\par
        PUSH(x);\par
        FAST_DISPATCH();\par
    \}\par
    format_exc_check_arg(PyExc_UnboundLocalError,\par
        UNBOUNDLOCAL_ERROR_MSG,\par
        PyTuple_GetItem(co->co_varnames, oparg));\par
    {\f4\b\cf2 break};\f0
\fs24 \par
\f2 Ignoring the macro-fu for the moment, what this basically says is that once \f3\fs20 LOAD_FAST\f2\fs24  is seen, the value of \f3\fs20 x\f2\fs24  is obtained from an indexed array of objects }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id11"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [5]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . If no \f3\fs20 STORE_FAST\f2\fs24  was done before, this value is still \f3\fs20 NULL\f2\fs24 , the \f3\fs20 if\f2\fs24  branch is not taken }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id12"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [6]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  and the exception is raised.\par
You may wonder why Python waits until runtime to raise this exception, instead of detecting it in the compiler. The reason is this code:\par
\f3\fs20 x = {\cf4 10}\par
{\f4\b\cf2 def} {\cf2 foo}():\par
    {\f4\b\cf2 if} something_true():\par
        x = {\cf4 1}\par
    x += {\cf4 1}\par
    {\f4\b\cf2 print}(x)\f0
\fs24 \par
\f2 Suppose \f3\fs20 something_true\f2\fs24  is a function that returns \f3\fs20 True\f2\fs24 , possibly due to some user input. In this case, \f3\fs20 x = 1\f2\fs24  binds \f3\fs20 x\f2\fs24  locally, so the reference to it in \f3\fs20 x += 1\f2\fs24  is no longer unbound. This code will then run without exceptions. Of course if \f3\fs20 something_true\f2\fs24  actually turns out to return \f3\fs20 False\f2\fs24 , the exception will be raised. Python has no way to resolve this at compile time, so the error detection is postponed to runtime.\par
}}{\pard \nisusnos \qc\nowidctlpar\sb240 \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth420 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx420 \clvertalt \clftsWidth3 \clwWidth10360 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10780 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl This is quite useful, if you think about it. In C & C++ you can use the value of an un-initialized variable, which is almost always a bug. Some compilers (with some settings) warn you about this, but in Python it\rquote s just a plain error.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth420 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx420 \clvertalt \clftsWidth3 \clwWidth10360
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10780 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl If you\rquote re using Python 2 and still need such code to work, the common workaround is the following: if you have data in \f3\fs20 external\f2\fs24  which you want to modify in \f3\fs20 internal\f2\fs24 , store it inside a \f3\fs20 dict\f2\fs24  instead of a stand-alone variable.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth420 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx420 \clvertalt \clftsWidth3 \clwWidth10360
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10780 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id3"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [3]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Could this be spared? Due to the dynamic nature of Python, that would be hard to do. At compilation time, when Python is compiled to bytecode, there\rquote s no way to know what the real type of the objects is. \f3\fs20 y\f2\fs24  in the example above could be some user-defined type with an overloaded \f3\fs20 +=\f2\fs24  operator which returns a new object, so Python compiler has to create generic code that re-binds the variable.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth420 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx420 \clvertalt \clftsWidth3 \clwWidth10360
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10780 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id4"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [4]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl I\rquote ve written comprehensively on the internals of symbol table construction in Python\rquote s compiler (}}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1/"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl part 1}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2  and }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/09/20/python-internals-symbol-tables-part-2/"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl part 2}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 ).\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth420 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx420 \clvertalt \clftsWidth3 \clwWidth10360
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10780 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id5"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [5]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f3\fs20 \intbl GETLOCAL(i)\f2\fs24  is a macro for \f3\fs20 (fastlocals[i])\f2\fs24 .\cell }}\row }\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt
\clftsWidth3 \clwWidth420 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx420 \clvertalt \clftsWidth3 \clwWidth10360 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10780 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/05/15/understanding-unboundlocalerror-in-python/#id6"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [6]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Had the \f3\fs20 if\f2\fs24  been entered, the exception raising code would not have been reached, since \f3\fs20 FAST_DISPATCH\f2\fs24  expands to a \f3\fs20 goto\f2\fs24  that takes control elsewhere.\cell }}\row
}\pard \plain {\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b Less copies in Python with the buffer protocol and memoryviews\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 November 28th, 2011 at 7:48 am\fs24 \par
For one of the hobby projects I\rquote m currently hacking on, I recently had to do a lot of binary data processing in memory. Large chunks of data are being read from a file, then examined and modified in memory and finally used to write some reports.\par
This made me think about the most efficient way to read data from a file into a modifiable memory chunk in Python. As we all know, the standard file \f3\fs20 read\f2\fs24  method, for a file opened in binary mode, returns a \f3\fs20 bytes\f2\fs24  object }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id10"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , which is immutable:\par
{\nisusnos \keepn\sl300\slmult0 {\f3\fs20\cf6 # Snippet #1}\f0
\line \f3\fs20 f = {\cf2 open}(FILENAME, {\cf3 'rb'})\f0\fs24 \line \f3\fs20 data = f.read()\f0\fs24 \line {\f3\fs20\cf6 # oops: TypeError: 'bytes' object does not support item assignment}\line
\f3\fs20 data[{\cf4 0}] = {\cf4 97}\f0\fs24 \par
}This reads the whole contents of the file into \f3\fs20 data\f2\fs24  \endash  a \f3\fs20 bytes\f2\fs24  object which is read only. But what if we now want to perform some modifications on the data? Then, we need to somehow get it into a writable object. The most straightforward writable data buffer in Python is a \f3
\fs20 bytearray\f2\fs24 . So we can do this:\par
{\nisusnos \keepn\sl300\slmult0 {\f3\fs20\cf6 # Snippet #2}\f0 \line \f3\fs20 f = {\cf2 open}(FILENAME, {\cf3 'rb'})\f0\fs24 \line \f3\fs20
data = {\cf2 bytearray}(f.read())\f0\fs24 \line \f3\fs20 data[{\cf4 0}] = {\cf4 97} {\cf6 # OK!}\f0\fs24 \par
}Now, the \f3\fs20 bytes\f2\fs24  object returned by \f3\fs20 f.read()\f2\fs24
 is passed into the \f3\fs20 bytearray\f2\fs24  constructor, which copies its contents into an internal buffer. Since \f3\fs20 data\f2\fs24  is a \f3\fs20 bytearray\f2\fs24 , we can manipulate it.\par
Although it appears that the goal has been achieved, I don\rquote t like this solution. The extra copy made by \f3\fs20 bytearray\f2\fs24  is bugging me. Why is this copy needed? \f3\fs20 f.read()\f2\fs24  just returns a throwaway buffer we don\rquote t need anyway \endash  can\rquote t we just initialize the \f3\fs20 bytearray\f2\fs24  directly, without copying a temporary buffer?\par
This use case is one of the reasons the Python buffer protocol exists.\par
{\f1\fs28\b The buffer protocol \endash  introduction\par
}The buffer protocol is described in the }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/c-api/buffer.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 Python documentation}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  and in }}{\field {\*\fldinst HYPERLINK "http://www.python.org/dev/peps/pep-3118/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 PEP 3118}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id11"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . Briefly, it provides a way for Python objects to expose their internal buffers to other objects. This is useful to avoid extra copies and for certain kinds of sharing. There are many examples of the buffer protocol in use. In the core language \endash  in builtin types such as \f3\fs20 bytes\f2\fs24  and \f3\fs20 bytearray\f2\fs24 , in the standard library (for example \f3\fs20 array.array\f2\fs24  and \f3\fs20 ctypes\f2\fs24 ) and 3rd party libraries (some important Python libraries such as \f3\fs20 numpy\f2\fs24  and \f3\fs20 PIL\f2\fs24  rely extensively on the buffer protocol for performance).\par
There are usually two or more parties involved in each protocol. In the case of the Python buffer protocol, the parties are a "producer" (or "provider") and a "consumer". The producer exposes its internals via the buffer protocol, and the consumer accesses those internals.\par
Here I want to focus specifically on one use of the buffer protocol that\rquote s relevant to this article. The producer is the built-in \f3\fs20 bytearray\f2\fs24  type, and the consumer is a method in the \f3\fs20 file\f2\fs24  object named \f3\fs20 readinto\f2\fs24 .\par
{\f1\fs28\b A more efficient way to read into a bytearray\par
}Here\rquote
s the way to do what Snippet #2 did, just without the extra copy:\par
{\nisusnos \keepn\sl300\slmult0 {\f3\fs20\cf6 # Snippet #3}\f0 \line \f3\fs20 f = {\cf2 open}(FILENAME, {\cf3 'rb'})\f0
\fs24 \line \f3\fs20 data = {\cf2 bytearray}(os.path.getsize(FILENAME))\f0\fs24 \line \f3\fs20 f.readinto(data)\f0\fs24 \par
}First, a \f3\fs20 bytearray\f2\fs24  is created and pre-allocated to the size of the data we\rquote
re going to read into it. The pre-allocation is important \endash  since \f3\fs20 readinto\f2\fs24  directly accesses the internal buffer of \f3\fs20 bytearray\f2\fs24 , it won\rquote t write more than has been allocated. Next, the \f3\fs20 file.readinto\f2\fs24  method is used to read the data directly into the bytearray\rquote s internal storage, without going via temporary buffers.\par
The result: this code runs ~30% faster than snippet #2 }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id12"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [3]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
{\f1\fs28\b Variations on the theme\par
}Other objects and modules could be used here. For example, the built-in \f3
\fs20 array.array\f2\fs24  class also supports the buffer protocol, so it can also be written and read from a file directly and efficiently. The same goes for \f3\fs20 numpy\f2\fs24  arrays. On the consumer side, the \f3\fs20 socket\f2\fs24  module can also read directly into a buffer with the \f3\fs20 read_into\f2\fs24  method. I\rquote m sure that it\rquote s easy to find many other sample uses of this protocol in Python itself and some 3rd partly libraries \endash  if you find something interesting, please let me know.\par
{\f1\fs28\b The buffer protocol \endash  implementation\par
}Let\rquote
s see how Snippet #3 works under the hood using the buffer protocol }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id13"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [4]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . We\rquote ll start with the producer.\par
\f3\fs20 bytearray\f2\fs24  declares that it implements the buffer protocol by filling the \f3\fs20 tp_as_buffer\f2\fs24  slot of its type object }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id14"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [5]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . What\rquote s placed there is the address of a \f3\fs20 PyBufferProcs\f2\fs24  structure, which is a simple container for two function pointers:\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 typedef}\f3
\fs20  {\f4\b\cf2 int} (*getbufferproc)(PyObject *, Py_buffer *, {\f4\b\cf2 int});\f0\fs24 \line {\f4\fs20\b\cf2 typedef}\f3\fs20  {\f4\b\cf2 void} (*releasebufferproc)(PyObject *, Py_buffer *);\f0
\fs24 \line {\f3\fs20\cf6 /* ... */}\line {\f4\fs20\b\cf2 typedef}\f3\fs20  {\f4\b\cf2 struct} \{\f0\fs24 \line \f3\fs20      getbufferproc bf_getbuffer;\f0\fs24 \line \f3\fs20      releasebufferproc bf_releasebuffer;\f0
\fs24 \line \f3\fs20 \} PyBufferProcs;\par
}\f3\fs20 bf_getbuffer\f2\fs24  is the function used to obtain a buffer from the object providing it, and \f3\fs20 bf_releasebuffer\f2\fs24  is the function used to notify the object that the provided buffer is no longer needed.\par
The \f3
\fs20 bytearray\f2\fs24  implementation in \f3\fs20 Objects/bytearrayobject.c\f2\fs24  initializes an instance of \f3\fs20 PyBufferProces\f2\fs24  thus:\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 static}\f3
\fs20  PyBufferProcs bytearray_as_buffer = \{\f0\fs24 \line \f3\fs20     (getbufferproc)bytearray_getbuffer,\f0\fs24 \line \f3\fs20     (releasebufferproc)bytearray_releasebuffer,\f0\fs24 \line \f3\fs20 \};\f0\fs24 \par
}The more interesting function here is \f3
\fs20 bytearray_getbuffer\f2\fs24 :\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 static}\f3\fs20  {\f4\b\cf2 int}\f0\fs24 \line {\f3\fs20\cf2 bytearray_getbuffer}\f3\fs20 (PyByteArrayObject *obj, Py_buffer *view, {\f4\b\cf2 int} flags)\f0
\fs24 \line \f3\fs20 \{\f0\fs24 \line \f3\fs20     {\f4\b\cf2 int} ret;\f0\fs24 \line \f3\fs20     {\f4\b\cf2 void} *ptr;\f0\fs24 \line \f3\fs20     {\f4\b\cf2 if} (view == {\cf2 NULL}) \{\f0
\fs24 \line \f3\fs20         obj->ob_exports++;\f0\fs24 \line \f3\fs20         {\f4\b\cf2 return} {\cf4 0};\f0\fs24 \line \f3\fs20     \}\f0\fs24 \line \f3\fs20     ptr = ({\f4\b\cf2 void} *) PyByteArray_AS_STRING(obj);\f0
\fs24 \line \f3\fs20     ret = PyBuffer_FillInfo(view, (PyObject*)obj, ptr, Py_SIZE(obj), {\cf4 0}, flags);\f0\fs24 \line \f3\fs20     {\f4\b\cf2 if} (ret >= {\cf4 0}) \{\f0\fs24 \line \f3
\fs20         obj->ob_exports++;\f0\fs24 \line \f3\fs20     \}\f0\fs24 \line \f3\fs20     {\f4\b\cf2 return} ret;\f0\fs24 \line \f3\fs20 \}\f0\fs24 \par
}It simply uses the \f3\fs20 PyBuffer_FillInfo\f2
\fs24  API to fill the }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/c-api/buffer.html#the-buffer-structure"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 buffer structure}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  passed to it. \f3\fs20 PyBuffer_FillInfo\f2\fs24  provides a simplified method of filling the buffer structure, which is suitable for unsophisticated objects like \f3\fs20 bytearray\f2\fs24  (if you want to see a more complex example that has to fill the buffer structure manually, take a look at the corresponding function of \f3\fs20 array.array\f2\fs24 ).\par
On the consumer side, the code that interests us is the \f3\fs20 buffered_readinto\f2\fs24  function in \f3\fs20 Modules\\_io\\bufferedio.c\f2\fs24  }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id15"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [6]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . I won\rquote t show its full code here since it\rquote s quite complex, but with regards to the buffer protocol, the flow is simple:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 11.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Use the \f3\fs20 PyArg_ParseTuple\f2\fs24  function with the \f3\fs20 w*\f2\fs24  format specifier to parse its argument as a R/W buffer object, which itself calls \f3\fs20 PyObject_GetBuffer\f2\fs24  \endash  a Python API that invokes the producer\rquote s "get buffer" function.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 12.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Read data from the file directly into this buffer.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 13.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Release the buffer using the \f3\fs20 PyBuffer_Release\f2\fs24  API }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id16"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\cs803 \f2\ul\ulc1\cf1 [7]}}}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 , which eventually gets routed to the \f3\fs20 bytearray_releasebuffer\f2\fs24  function in our case.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 To conclude, here\rquote s what the call sequence looks like when \f3\fs20 f.readinto(data)\f2\fs24  is executed in the Python code:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 buffered_readinto\f0\fs24 \line \f3\fs20 |\f0\fs24 \line \f3\fs20 \\--> PyArg_ParseTuple(..., "w*", ...)\f0\fs24 \line \f3\fs20 |    |\f0\fs24 \line \f3\fs20 |    \\--> PyObject_GetBuffer(obj)\f0\fs24 \line \f3\fs20 |         |\f0\fs24 \line \f3\fs20 |         \\--> obj->ob_type->tp_as_buffer->bf_getbuffer\f0\fs24 \line \f3\fs20 |\f0\fs24 \line \f3\fs20 |--> ... read the data\f0\fs24 \line \f3\fs20 |\f0\fs24 \line \f3\fs20 \\--> PyBuffer_Release\f0\fs24 \line \f3\fs20      |\f0\fs24 \line \f3\fs20      \\--> obj->ob_type->tp_as_buffer->bf_releasebuffer\f0\fs24 \par
}{\f1\fs28\b Memory views\par
}The buffer protocol is an internal implementation detail of Python, accessible only on the C-API level. And that\rquote
s a good thing, since the buffer protocol requires certain low-level behavior such as properly releasing buffers. }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/library/stdtypes.html#typememoryview"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 Memoryview objects}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  were created to expose it to a user\rquote s Python code in a safe manner:\par
memoryview objects allow Python code to access the internal data of an object that supports the buffer protocol without copying.\par
The linked documentation page explains \f3\fs20 memoryviews\f2\fs24  quite well and should be immediately comprehensible if you\rquote ve reached so far in this article. Therefore I\rquote m not going to explain how a \f3\fs20 memoryview\f2\fs24  works, just show some examples of its use.\par
It is a known fact that in Python, slices on strings and bytes make copies. Sometimes when performance matters and the buffers are large, this is a big waste. Suppose you have a large buffer and you want to pass just half of it to some function (that will send it to a socket or do something else }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id17"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [8]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 ). Here\rquote s what happens (annotated Python pseudo-code):\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 mybuf = ... {\cf6 # some large buffer of bytes}\f0
\fs24 \line \f3\fs20 func(mybuf[:{\cf2 len}(mybuf)//{\cf4 2}])\f0\fs24 \line \f3\fs20   {\cf6 # passes the first half of mybuf into func}\f0\fs24 \line \f3\fs20   {\cf6 # COPIES half of mybuf's data to a new buffer}\f0
\fs24 \par
}The copy can be expensive if there\rquote s a lot of data involved. What\rquote s the alternative? Using a \f3\fs20 memoryview\f2\fs24 :\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 mybuf = ... {\cf6 # some large buffer of bytes}\f0
\fs24 \line \f3\fs20 mv_mybuf = memoryview(mybuf) {\cf6 # a memoryview of mybuf}\f0\fs24 \line \f3\fs20 func(mv_mybuf[:{\cf2 len}(mv_mybuf)//{\cf4 2}])\f0\fs24 \line \f3\fs20   {\cf6 # passes the first half of mybuf into func as a "sub-view" created}\f0
\fs24 \line \f3\fs20   {\cf6 # by slicing a memoryview.}\f0\fs24 \line \f3\fs20   {\cf6 # NO COPY is made here!}\f0\fs24 \par
}A \f3\fs20 memoryview\f2\fs24  behaves just like \f3\fs20 bytes\f2
\fs24  in many useful contexts (for example, it supports the mapping protocol) so it provides an adequate replacement if used carefully. The great thing about it is that it uses the buffer protocol beneath the covers to avoid copies and just juggle pointers to data. The performance difference is dramatic \endash  I timed a 300x speedup on slicing out a half of a 1MB \f3\fs20 bytes\f2\fs24  buffer when using a \f3\fs20 memoryview\f2\fs24  as demonstrated above. And this speedup will get larger with larger buffers, since it\rquote s O(1) vs. the O(n) of copying.\par
But there\rquote s more. On writable producers such as \f3\fs20 bytearray\f2\fs24 , a \f3\fs20 memoryview\f2\fs24  creates a writable view that can be modified:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 >>> buf = {\cf2 bytearray}(b{\cf3 'abcdefgh'})\f0
\fs24 \line \f3\fs20 >>> mv = memoryview(buf)\f0\fs24 \line \f3\fs20 >>> mv[{\cf4 4}:{\cf4 6}] = b{\cf3 'ZA'}\f0\fs24 \line \f3\fs20 >>> buf\f0\fs24 \line {\f3\fs20\cf2 bytearray}\f3\fs20
(b{\cf3 'abcdZAgh'})\f0\fs24 \par
}This gives us a way to do something we couldn\rquote t achieve by any other means \endash  read from a file (or receive from a socket) directly into the middle of some existing buffer }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id18"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [9]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 buf = {\cf2 bytearray}(...) {\cf6 # pre-allocated to the needed size}\f0
\fs24 \line \f3\fs20 mv = memoryview(buf)\f0\fs24 \line \f3\fs20 numread = f.readinto(mv[some_offset:])\f0\fs24 \par
}{\f1\fs28\b Conclusion\par
}This article demonstrated the Python buffer protocol, showing both how it works and what it can be used for. The main use of the buffer protocol to the Python programmer is optimization of certain patterns of coding, by avoiding unnecessary data copies.\par
Any mention of optimization in Python code is sure to draw fire from people claiming that if I want to write fast code, I shouldn\rquote
t use Python at all. But I disagree. Python these days is fast enough to be suitable for many tasks that were previously only in the domain of C/C++. I want to keep using it while I can, and only resort to low-level C/C++ when I must.\par
Employing the buffer protocol to have zero-copy buffer manipulations on the Python level is IMHO a huge boon that can stall (or even avoid) the transition of some performance-sensitive code from Python to C. That\rquote s because when dealing with data processing, we often use a lot of C APIs anyway, the only Python overhead being the passing of data between these APIs. A speed boost in this code can make a huge difference and bring the Python code very close to the performance we could have with plain C.\par
The article also gave a glimpse into one aspect of the implementation of Python, hopefully showing that it\rquote s not difficult at all to dive right into the code and understand how Python does something it does.\par
}}{\pard \nisusnos \nowidctlpar\sb240 \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl In this article I\rquote m focusing on the latest Python 3.x, although most of it also applies to Python 2.7\cell }}\row }\trowd \trql
\ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl The buffer protocol existed in Python prior to 2.6, but was then greatly enhanced. The PEP also describes the change that was made to the buffer protocol with the move to Python 3.x (and later backported to the 2.x line starting with 2.6).\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id3"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [3]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl This is on the latest build of Python 3.3. Roughly the same speedup can be seen on Python 2.7. With Python 3.2 there appears to be a speed regression that makes the two snippets perform similarly, but it has been fixed in 3.3\par
Another note on the benchmarking: it\rquote s recommended to use large files (say, ~100 MB and up) to get reliable measurements. For small files too many irrelevant factors come into play and offset the benchmarks. In addition, the code should be run in a loop to avoid differences due to warm/cold disk cache issues. I\rquote m using the \f3\fs20 timeit\f2\fs24  module, which is perfect for this purpose.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id4"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [4]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl All the code displayed here is taken from the latest development snapshot of Python 3.3 (\f3\fs20 default\f2\fs24  branch).\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id5"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [5]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Type objects are a fascinating aspect of Python\rquote s implementation, and I hope to cover it in a separate article one day. Briefly, it allows Python objects to declare which services they provide (or, in other terms, which interfaces they implement). More information can be found }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/c-api/typeobj.html"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl in the documentation}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 .\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id6"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [6]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Since the built-in \f3\fs20 open\f2\fs24  function, when asked to open a file in binary mode for reading, returns an \f3\fs20 io.BufferedReader\f2\fs24  object by default. This can be controlled with the buffering argument.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id7"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [7]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Releasing the buffer structure is an important part of the buffer protocol. Each time it\rquote s requested for a buffer, \f3\fs20 bytearray\f2\fs24  increments a reference count, and decrements it when the buffer is released. While the refcount is positive (meaning that there are consumer objects directly relying on the internal buffer), \f3\fs20 bytearray\f2\fs24  won\rquote t agree to resize or do other operations that may invalidate the internal buffer. Otherwise, this would be an avenue for insidious memory bugs.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id8"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [8]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Networking code is actually a common use case. When sending data over sockets, it\rquote s frequently sliced and diced to build frames. This can involve a lot of copying. Other data-munging applications such as encryption and compression are also culprits.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/#id9"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [9]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl This code snippet was borrowed from Antoine Pitrou\rquote s post on python-dev.\cell }}\row }\pard \plain {\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b Python internals: how callables work\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 March 23rd, 2012 at 10:53 am\fs24 \par
[The Python version described in this article is 3.x, more specifically - the 3.3 alpha release of CPython.]\par
The concept of a callable is fundamental in Python. When thinking about what can be "called", the immediately obvious answer is functions. Whether it\rquote s user defined functions (written by you), or builtin functions (most probably implemented in C inside the CPython interpreter), functions were meant to be called, right?\par
Well, there are also methods, but they\rquote re not very interesting because they\rquote re just special functions that are bound to objects. What else can be called? You may, or may not be familiar with the ability to call objects, as long as they belong to classes that define the \f3\fs20 __call__\f2\fs24  magic method. So objects can act as functions. And thinking about this a bit further, classes are callable too. After all, here\rquote s how we create new objects:\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 class}\f3
\fs20  {\cf2 Joe}:\f0\fs24 \line \f3\fs20   ... [contents of class]\f0\fs24 \line \f3\fs20 joe = Joe()\f0\fs24 \par
}Here we "call" \f3\fs20 Joe\f2\fs24  to create a new instance. So classes can act as functions as well!\par
It turns out that all these concepts are nicely united in the CPython implementation. Everything in Python is an object, and that includes every entity described in the previous paragraphs (user & builtin functions, methods, objects, classes). All these calls are served by a single mechanism. This mechanism is elegant and not that difficult to understand, so it\rquote
s worth knowing about. But let\rquote s start at the beginning.\par
{\f1\fs28\b Compiling calls\par
}CPython executes our program in two major steps:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 14.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 The Python source code is compiled to bytecode.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 15.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 A VM executes that bytecode, using a toolbox of built-in objects and modules to help it do its job.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 In this section I\rquote ll provide a quick overview of how the first step applies to making calls. I won\rquote t get too deep since these details are not the really interesting part I want to focus on in the article. If you want to learn more about the flow Python source undergoes in the compiler, read }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 this}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
Briefly, the Python compiler identifies everything followed by \f3\fs20 (arguments...)\f2\fs24  inside an expression as a call }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id7"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . The AST node for this is \f3\fs20 Call\f2\fs24 . The compiler emits code for \f3\fs20 Call\f2\fs24  in the \f3\fs20 compiler_call\f2\fs24  function in \f3\fs20 Python/compile.c\f2\fs24 . In most cases, the \f3\fs20 CALL_FUNCTION\f2\fs24  bytecode instruction is going to be emitted. There are some variations I\rquote m going to ignore for the purpose of the article. For example, if the call has "star args" \endash  \f3\fs20 func(a, b, *args)\f2\fs24 , there\rquote s a special instruction for handling that \endash  \f3\fs20 CALL_FUNCTION_VAR\f2\fs24 . It and other special instructions are just variations on the same theme.\par
{\f1\fs28\b CALL_FUNCTION\par
}So \f3
\fs20 CALL_FUNCTION\f2\fs24  is the instruction we\rquote re going to focus on here. This is }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/library/dis.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 what it does}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
{\f1\b CALL_FUNCTION(argc)}\par
Calls a function. The low byte of argc indicates the number of positional parameters, the high byte the number of keyword parameters. On the stack, the opcode finds the keyword parameters first. For each keyword argument, the value is on top of the key. Below the keyword parameters, the positional parameters are on the stack, with the right-most parameter on top. Below the parameters, the function object to call is on the stack. Pops all function arguments, and the function itself off the stack, and pushes the return value.\par
CPython bytecode is evaluated by the the mammoth function \f3
\fs20 PyEval_EvalFrameEx\f2\fs24  in \f3\fs20 Python/ceval.c\f2\fs24 . The function is scary but it\rquote s nothing more than a fancy dispatcher of opcodes. It reads instructions from the code object of the given frame and executes them. Here, for example, is the handler for \f3\fs20 CALL_FUNCTION\f2\fs24  (cleaned up a bit to remove tracing and timing macros):\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 TARGET(CALL_FUNCTION)\f0\fs24 \line \f3\fs20 \{\f0\fs24 \line \f3\fs20     PyObject **sp;\f0\fs24 \line \f3\fs20     sp = stack_pointer;\f0\fs24 \line \f3\fs20     x = call_function(&sp, oparg);\f0\fs24 \line \f3\fs20     stack_pointer = sp;\f0\fs24 \line \f3\fs20     PUSH(x);\f0\fs24 \line \f3\fs20     {\f4\b\cf2 if} (x != {\cf2 NULL})\f0
\fs24 \line \f3\fs20         DISPATCH();\f0\fs24 \line \f3\fs20     {\f4\b\cf2 break};\f0\fs24 \line \f3\fs20 \}\f0\fs24 \par
}Not too bad \endash  it\rquote s actually very readable. \f3
\fs20 call_function\f2\fs24  does the actual call (we\rquote ll examine it in a bit), \f3\fs20 oparg\f2\fs24  is the numeric argument of the instruction, and \f3\fs20 stack_pointer\f2\fs24  points to the top of the stack }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id8"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . The value returned by \f3\fs20 call_function\f2\fs24  is pushed back to the stack, and \f3\fs20 DISPATCH\f2\fs24  is just some macro magic to invoke the next instruction.\par
\f3\fs20 call_function\f2\fs24  is also in \f3\fs20 Python/ceval.c\f2\fs24 . It implements the actual functionality of the instruction. At 80 lines it\rquote s not very long, but long enough so I won\rquote t paste it wholly here. Instead I\rquote ll explain the flow in general and paste small snippets where relevant; you\rquote re welcome to follow along with the code open in your favorite editor.\par
{\f1\fs28\b Any call is just an object call\par
}The most important first step in understanding how calls work in Python is to ignore most of what \f3
\fs20 call_function\f2\fs24  does. Yes, I mean it. The vast majority of the code in this function deals with optimizations for various common cases. It can be removed without hurting the correctness of the interpreter, only its performance. If we ignore all optimizations for the time being, all \f3\fs20 call_function\f2\fs24  does is decode the amount of arguments and amount of keyword arguments from the single argument of \f3\fs20 CALL_FUNCTION\f2\fs24  and forwards it to \f3\fs20 do_call\f2\fs24 . We\rquote ll get back to the optimizations later since they are interesting, but for the time being, let\rquote s see what the core flow is.\par
\f3\fs20 do_call\f2\fs24  loads the arguments from the stack into \f3\fs20 PyObject\f2\fs24  objects (a tuple for the positional arguments, a dict for the keyword arguments), does a bit of tracing and optimization of its own, but eventually calls \f3\fs20 PyObject_Call\f2\fs24 .\par
\f3\fs20 PyObject_Call\f2\fs24  is a super-important function. It\rquote s also available to extensions in the Python C API. Here it is, in all its glory:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 PyObject *\f0\fs24 \line {\f3\fs20\cf2 PyObject_Call}\f3
\fs20 (PyObject *func, PyObject *arg, PyObject *kw)\f0\fs24 \line \f3\fs20 \{\f0\fs24 \line \f3\fs20     ternaryfunc call;\f0\fs24 \line \f3\fs20     {\f4\b\cf2 if} ((call = func->ob_type->tp_call) != {\cf2 NULL}) \{\f0
\fs24 \line \f3\fs20         PyObject *result;\f0\fs24 \line \f3\fs20         {\f4\b\cf2 if} (Py_EnterRecursiveCall({\cf3 " while calling a Python object"}))\f0\fs24 \line \f3\fs20             {\f4\b\cf2 return} {\cf2 NULL};\f0
\fs24 \line \f3\fs20         result = (*call)(func, arg, kw);\f0\fs24 \line \f3\fs20         Py_LeaveRecursiveCall();\f0\fs24 \line \f3\fs20         {\f4\b\cf2 if} (result == {\cf2 NULL} && !PyErr_Occurred())\f0
\fs24 \line \f3\fs20             PyErr_SetString(\f0\fs24 \line \f3\fs20                 PyExc_SystemError,\f0\fs24 \line \f3\fs20                 {\cf3 "NULL result without error in PyObject_Call"});\f0
\fs24 \line \f3\fs20         {\f4\b\cf2 return} result;\f0\fs24 \line \f3\fs20     \}\f0\fs24 \line \f3\fs20     PyErr_Format(PyExc_TypeError, {\cf3 "'%.200s' object is not callable"},\f0
\fs24 \line \f3\fs20                  func->ob_type->tp_name);\f0\fs24 \line \f3\fs20     {\f4\b\cf2 return} {\cf2 NULL};\f0\fs24 \line \f3\fs20 \}\f0\fs24 \par
}Deep recursion protection and error handling aside }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id9"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [3]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , \f3\fs20 PyObject_Call\f2\fs24  extracts the \f3\fs20 tp_call\f2\fs24  attribute }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id10"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [4]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  of the object\rquote s type and calls it. This is possible since \f3\fs20 tp_call\f2\fs24  holds a function pointer.\par
Let it sink for a moment. This is it. Ignoring all kinds of wonderful optimizations, this is what all calls in Python boil down to:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Everything in Python is an object }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id11"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\cs803 \f2\ul\ulc1\cf1 [5]}}}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 .\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Every object has a type; the type of an object dictates the stuff that can be done to/with the object.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 When an object is called, its type\rquote s \f3\fs20 tp_call\f2\fs24  attribute is called.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 As a user of Python, your only direct interaction with \f3\fs20 tp_call\f2\fs24  is when you want your objects to be callable. If you define your class in Python, you have to implement the \f3\fs20 __call__\f2\fs24  method for this purpose. This method gets directly mapped to \f3\fs20 tp_call\f2\fs24  by CPython. If you define your class as a C extension, you have to assign \f3\fs20 tp_call\f2\fs24  in the type object of your class manually.\par
But recall that classes themselves are "called" to create new objects, so \f3\fs20 tp_call\f2\fs24  plays a role here as well. Even more fundamentally, when you define a class there is also a call involved \endash  on the class\rquote s metaclass. This is an interesting topic and I\rquote ll cover it in a future article.\par
{\f1\fs28\b Extra credit: Optimizations in CALL_FUNCTION\par
}This part is optional, since the main point of the article was delivered in the previous section. That said, I think this material is interesting, since it provides examples of how some things you wouldn\rquote
t usually think of as objects, actually are objects in Python.\par
As I mentioned earlier, we could just use \f3\fs20 PyObject_Call\f2\fs24  for every \f3\fs20 CALL_FUNCTION\f2\fs24  and be done with it. In reality, it makes sense to do some optimizations to cover common cases where that may be an overkill. \f3\fs20 PyObject_Call\f2\fs24  is a very generic function that needs all its arguments in special tuple and dictionary objects (for positional and keyword arguments, respectively). These arguments need to be taken from the stack and arranged in the containers \f3\fs20 PyObject_Call\f2\fs24  expects. In some common cases we can avoid a lot of this overhead, and this is what the optimizations in \f3\fs20 call_function\f2\fs24  are about.\par
The first special case \f3\fs20 call_function\f2\fs24  addresses is:\par
{\nisusnos \keepn\sl300\slmult0 {\f3\fs20\cf6 /* Always dispatch PyCFunction first, because these are}\f0
\line {\f3\fs20\cf6    presumed to be the most frequent callable object.}\line {\f3\fs20\cf6 */}\line {\f4\fs20\b\cf2 if}\f3\fs20  (PyCFunction_Check(func) && nk == {\cf4 0}) \{\f0\fs24 \par
}This handles objects of type \f3
\fs20 builtin_function_or_method\f2\fs24  (represented by the \f3\fs20 PyCFunction\f2\fs24  type in the C implementation). There are a lot of those in Python, as the comment above notes. All functions and methods implemented in C, whether in the CPython interpreter, or in C extensions, fall into this category. For example:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 >>> type(chr)\f0\fs24 \line \f3\fs20 <class 'builtin_function_or_method'>\f0\fs24 \line \f3\fs20 >>> type("".split)\f0\fs24 \line \f3\fs20 <class 'builtin_function_or_method'>\f0\fs24 \line \f3\fs20 >>> from pickle import dump\f0\fs24 \line \f3\fs20 >>> type(dump)\f0\fs24 \line \f3\fs20 <class 'builtin_function_or_method'>\f0\fs24 \par
}There\rquote
s an additional condition in that \f3\fs20 if\f2\fs24  \endash  that the amount of keyword arguments passed to the function is zero. This allows some important optimizations. If the function in question accepts no arguments (marked by the \f3\fs20 METH_NOARGS\f2\fs24  flag when the function is created) or just a single object argument (\f3\fs20 METH_0\f2\fs24  flag), \f3\fs20 call_function\f2\fs24  doesn\rquote t go through the usual argument packing and can call the underlying function pointer directly. To understand how this is possible, reading about \f3\fs20 PyCFunction\f2\fs24  and the \f3\fs20 METH_\f2\fs24  flags in }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/c-api/structures.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 this part of the documentation}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  is highly recommended.\par
Next, there\rquote s some special handling for methods of classes written in Python:\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 else}\f3
\fs20  \{\f0\fs24 \line \f3\fs20   {\f4\b\cf2 if} (PyMethod_Check(func) && PyMethod_GET_SELF(func) != {\cf2 NULL}) \{\par
}\f3\fs20 PyMethod\f2\fs24  is the internal object used to represent }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/c-api/method.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 bound methods}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . The special thing about methods is that they carry around a reference to the object they\rquote re bound to. \f3\fs20 call_function\f2\fs24  extracts this object and places it on the stack, in preparation for what comes next.\par
Here\rquote s the rest of the call code (after it in \f3\fs20 call_object\f2\fs24  there\rquote s only some stack cleanup):\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 if}\f3
\fs20  (PyFunction_Check(func))\f0\fs24 \line \f3\fs20     x = fast_function(func, pp_stack, n, na, nk);\f0\fs24 \line {\f4\fs20\b\cf2 else}\line \f3\fs20     x = do_call(func, pp_stack, na, nk);\par
}\f3
\fs20 do_call\f2\fs24  we\rquote ve already met \endash  it implements the most generic form of calling. However, there\rquote s one more optimization \endash  if \f3\fs20 func\f2\fs24  is a \f3\fs20 PyFunction\f2\fs24  (an object used }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/c-api/function.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 internally}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  to represent functions defined in Python code), a separate path is taken \endash  \f3\fs20 fast_function\f2\fs24 .\par
To understand what \f3\fs20 fast_function\f2\fs24  does, it\rquote s important to first consider what happens when a Python function is executed. Simply put, its code object is evaluated (with \f3\fs20 PyEval_EvalCodeEx\f2\fs24  itself). This code expects its arguments to be on the stack. Therefore, in most cases there\rquote s no point packing the arguments into containers and unpacking them again. With some care, they can just be left on the stack and a lot of precious CPU cycles can be spared.\par
Everything else falls back to \f3\fs20 do_call\f2\fs24 . This, by the way, includes \f3\fs20 PyCFunction\f2\fs24  objects that do have keyword arguments. A curious aspect of this fact is that it\rquote s somewhat more efficient to not pass keyword arguments to C functions that either accept them or are fine with just positional arguments. For example }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id12"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [6]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 $ ~/test/python_src/33/python -m timeit -s's="a;b;c;d;e"' 's.split(";")'\f0\fs24 \line \f3\fs20 1000000 loops, best of 3: 0.3 usec per loop\f0\fs24 \line \f3\fs20 $ ~/test/python_src/33/python -m timeit -s's="a;b;c;d;e"' 's.split(sep=";")'\f0\fs24 \line \f3\fs20 1000000 loops, best of 3: 0.469 usec per loop\f0\fs24 \par
}This is a big difference, but the input is very small. For larger strings the difference is almost invisible:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 $ ~/test/python_src/33/python -m timeit -s's="a;b;c;d;e"*1000' 's.split(";")'\f0\fs24 \line \f3\fs20 10000 loops, best of 3: 98.4 usec per loop\f0\fs24 \line \f3\fs20 $ ~/test/python_src/33/python -m timeit -s's="a;b;c;d;e"*1000' 's.split(sep=";")'\f0\fs24 \line \f3\fs20 10000 loops, best of 3: 98.7 usec per loop\f0\fs24 \par
}{\f1\fs28\b Summary\par
}The aim of this article was to discuss what it means to be callable in Python, approaching this concept from the lowest possible level \endash
 the implementation details of the CPython virtual machine. Personally, I find this implementation very elegant, since it unifies several concepts into a single one. As the extra credit section showed, Python entities we don\rquote t usually think of as objects \endash  functions and methods \endash  actually are objects and can also be handled in the same uniform manner. As I promised, future article(s) will dive deeper into the meaning of \f3\fs20 tp_call\f2\fs24  for creating new Python objects and classes.\par
}}{\pard \nisusnos \nowidctlpar\sb240 \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl This is an intentional simplification \endash  \f3\fs20 ()\f2\fs24  serve other roles like class definitions (for listing base classes), function definitions (for listing arguments), decorators, etc \endash  these are not in expressions. I\rquote m also ignoring generator expressions on purpose.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl The CPython VM is a }}{\field {\*\fldinst HYPERLINK "http://en.wikipedia.org/wiki/Stack_machine"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl stack machine}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 .\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id3"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [3]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f3\fs20 \intbl Py_EnterRecursiveCall\f2\fs24  is needed where C code may end up calling Python code, to allow CPython keep track of its recursion level and bail out when it\rquote s too deep. Note that functions written in C don\rquote t have to abide by this recursion limit. This is why \f3\fs20 do_call\f2\fs24  special-cases \f3\fs20 PyCFunction\f2\fs24  before calling \f3\fs20 PyObject_Call\f2\fs24 .\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id4"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [4]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl By "attribute" here I mean a structure field (sometimes also called "slot" in the documentation). If you\rquote re completely unfamiliar with the way Python C extensions are defined, go over }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/extending/newtypes.html"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl this page}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 .\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id5"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [5]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl When I say that everything is an object \endash  I mean it. You may think of objects as instances of classes you defined. However, deep down on the C level, CPython creates and juggles a lot of objects on your behalf. Types (classes), builtins, functions, modules \endash  all these are represented by objects.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10400
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10800 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/#id6"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [6]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl This example will only run on Python 3.3, since the \f3\fs20 sep\f2\fs24  keyword argument to \f3\fs20 split\f2\fs24  is new in this version. In prior versions of Python \f3\fs20 split\f2\fs24  only accepted positional arguments.\cell }}\row
}\pard \plain {\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b Python objects, types, classes, and instances \endash  a glossary\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 March 30th, 2012 at 7:35 am\fs24 \par
While writing the article on the }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 internals of Python callables}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , it occurred to me that some things in Python have more than one name. At the same time, some names are sometimes used to refer to more than one entity, and which one is implied has to be understood from context. Therefore, I think it\rquote s a good idea to collect this nomenclature in a single place for the sake of my future writings. This way I\rquote ll just be able to point here every time I discuss these topics, instead of explaining them over and over again.\par
Specifically, I want to define what I mean by types, objects, classes and instances. Note that this refers to Python 3.x, but is mostly applicable for 2.x as well }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/#id3"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
{\f1\fs28\b Objects\par
}It\rquote
s easiest to start with objects. The Python }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/reference/datamodel.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 data model reference}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  has a pretty good definition:\par
Objects are Python\rquote s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann\rquote s model of a \ldblquote stored program computer,\rdblquote  code is also represented by objects.)\par
Every object has an identity, a type and a value.\par
So, everything in Python is an object. Lists are objects. 42 is an object. Modules are objects. Functions are objects. Python bytecode is also kept in an object. All of these have types and unique IDs:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 >>> def foo(): pass\f0\fs24 \line \f3\fs20 ...\f0\fs24 \line \f3\fs20 >>> type(foo), id(foo)\f0\fs24 \line \f3\fs20 (<class 'function'>, 38110760)\f0\fs24 \line \f3\fs20 >>> type(foo.__code__), id(foo.__code__)\f0\fs24 \line \f3\fs20 (<class 'code'>, 38111680)\f0\fs24 \par
}This "everything is an object" model is backed by the CPython implementation. Indeed, if you look into the code of CPython, you\rquote
ll notice that every entity mentioned above can be manipulated via a pointer to the \f3\fs20 PyObject\f2\fs24  base struct.\par
{\f1\fs28\b Types\par
}The data model reference is useful here too:\par
[...] An object\rquote
s type determines the operations that the object supports (e.g., \ldblquote does it have a length?\rdblquote ) and also defines the possible values for objects of that type.\par
So, every object in Python has a type. Its type can be discovered by calling the \f3\fs20 type\f2\fs24  builtin function }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/#id4"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . The type is an object too, so it has a type of its own, which is called \f3\fs20 type\f2\fs24 . This last fact may not be very exciting or useful when you\rquote re just writing Python code, but it\rquote s hugely important if you want to understand the internals of CPython:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 >>> type(42)\f0\fs24 \line \f3\fs20 <class 'int'>\f0\fs24 \line \f3\fs20 >>> type(type(42))\f0\fs24 \line \f3\fs20 <class 'type'>\f0\fs24 \line \f3\fs20 >>> type(type(type(42)))\f0\fs24 \line \f3\fs20 <class 'type'>\f0\fs24 \par
}Yep, it\rquote
s turtles all the way down.\par
{\f1\fs28\b Classes\par
}In the olden days, there was a difference between user-defined classes and built in types. But }}{\field {\*\fldinst HYPERLINK "http://www.python.org/download/releases/2.2.3/descrintro/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 since 2.2}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , as long as you\rquote re using "new-style" classes (classes that inherit from \f3\fs20 object\f2\fs24  in 2.x, and are default in 3.x), there is no real difference. Essentially, a class is a mechanism Python gives us to create new user-defined types from Python code.\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 >>> class Joe: pass\f0\fs24 \line \f3\fs20 ...\f0\fs24 \line \f3\fs20 >>> j = Joe()\f0\fs24 \line \f3\fs20 >>> type(j)\f0\fs24 \line \f3\fs20 <class '__main__.Joe'>\f0\fs24 \par
}Using the class mechanism, we\rquote
ve created \f3\fs20 Joe\f2\fs24  \endash  a user-defined type. \f3\fs20 j\f2\fs24  is an instance of the class \f3\fs20 Joe\f2\fs24 . In other words, it\rquote s an object and its type is \f3\fs20 Joe\f2\fs24 .\par
As any other type, \f3\fs20 Joe\f2\fs24  is an object itself, and it has a type too. This type is \f3\fs20 type\f2\fs24 :\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 >>> type(type(j))\f0\fs24 \line \f3\fs20 <class 'type'>\f0\fs24 \par
}The terms "class" and "type" are an example of two names referring to the same concept. To avoid this confusion, I will always try to say "type" when I mean a type, and "user-defined class" (or "user-defined type") when referring to a new type created using the \f3
\fs20 class\f2\fs24  construct. Note that when we create new types using the C API of CPython, there\rquote s no "class" mentioned \endash  we create a new "type", not a new "class".\par
{\f1\fs28\b Instances\par
}Not unlike the ambiguity between "class" and "type", "instance" is synonymous to "object". Think of it this way: objects are instances of types. So, "42 is an instance of the type \f3
\fs20 int\f2\fs24 " is equivalent to "42 is an \f3\fs20 int\f2\fs24  object". I usually use "instance" and "object" interchangeably. In some cases when I want to specifically refer to objects as artifacts of the CPython implementation, I will try to use "instance" to refer to actual instances of classes. Another place where the term "instance" is explicitly used by Python is in built-ins like \f3\fs20 isinstance\f2\fs24  and the special \f3\fs20 __instancecheck__\f2\fs24  attribute.\par
{\f1\fs28\b Conclusion\par
}As we\rquote
ve seen, there are two pairs of roughly synonymous terms in Python nomenclature. Types and classes are interchangeable concepts. I prefer to say "type" wherever possible, leaving the term "class" for user-defined types created with the "class" construct. IMHO "type" is a better term, and Python wouldn\rquote t be worse if the "class" concept was wiped out completely.\par
Similarly, objects and instances are terms that mean the same thing, but perhaps from slightly different angles. Sometimes it\rquote s more convenient to use "instance" (i.e. when specifically talking about specific objects being instances of specific types \endash  as in "\f3\fs20 j\f2\fs24  is an instance of \f3\fs20 Joe\f2\fs24 "), and sometimes it\rquote s better to use "object" (i.e. when discussing the guts of the CPython implementation).\par
I sincerely hope this post is more helpful than confusing! For me, it\rquote s an aid that serves as a simple glossary when my usage of these terms in some article may be unclear or ambiguous.\par
}}{\pard \nisusnos \nowidctlpar\sb240 \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx440 \clvertalt \clftsWidth3 \clwWidth10340 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10780 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl As long as you forget about the existence of classic 2.x classes and take it as a fact that all user-defined classes inherit from \f3\fs20 object\f2\fs24 .\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth440 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx440 \clvertalt \clftsWidth3 \clwWidth10340
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10780 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl An alternative is the \f3\fs20 __class__\f2\fs24  attribute.\cell }}\row }\pard \plain {\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b The fundamental types of Python \endash  a diagram\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 April 3rd, 2012 at 8:33 pm\fs24 \par
The aim of this post is to present a succinct diagram that correlates some basic properties of all Python objects with the fundamental types \f3\fs20 type\f2\fs24  and \f3\fs20 object\f2\fs24 . This is not a tutorial \endash  it\rquote s more of a reference snapshot that puts things in order. To properly understand why things are the way they are, check out the existing and future writings in the }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/category/programming/python/python-internals/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 Python internals category}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  of this blog, as well as other resources available online.\par
In Python, }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 every object has a type}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . Types are also objects \endash  rather special objects. A type object, like any other object, has a type of its own. It also has a sequence of "base types" \endash  in other words, types from which it inherits. This is unlike non-type objects, which don\rquote t have base types.\par
Consider this exemplary piece of code (Python 3):\par
{\nisusnos \keepn\sl300\slmult0 {\f3\fs20\cf6 # Some types}\f0
\line {\f4\fs20\b\cf2 class}\f3\fs20  {\cf2 Base}:\f0\fs24 \line \f3\fs20     {\f4\b\cf2 pass}\f0\fs24 \line {\f4\fs20\b\cf2 class}\f3\fs20  {\cf2 Klass}(Base):\f0\fs24 \line \f3\fs20     {\f4\b\cf2 pass}\f0
\fs24 \line {\f4\fs20\b\cf2 class}\f3\fs20  {\cf2 Meta}({\cf2 type}):\f0\fs24 \line \f3\fs20     {\f4\b\cf2 pass}\f0\fs24 \line {\f4\fs20\b\cf2 class}\f3\fs20  {\cf2 KlassWithMeta}(metaclass=Meta):\f0
\fs24 \line \f3\fs20     {\f4\b\cf2 pass}\f0\fs24 \line {\f3\fs20\cf6 # Non-types}\line \f3\fs20 kwm = KlassWithMeta()\f0\fs24 \line \f3\fs20 mylist = []\f0\fs24 \par
}The following diagram describes the types and bases of all the objects created in this code. Non-type objects only have types and no bases:\par
Some interesting things to note:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 The default type of all new types is \f3\fs20 type\f2\fs24 . This can be overridden by explicitly specifying the }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\cs803 \f2\ul\ulc1\cf1 metaclass}}}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2  for a type.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Built-in types like \f3\fs20 list\f2\fs24  and user-defined types like \f3\fs20 Base\f2\fs24  are equivalent as far as Python is concerned.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 The special type \f3\fs20 type\f2\fs24  is the default type of all objects \endash  including itself. It is an object, and as such, inherits from \f3\fs20 object\f2\fs24 .\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 The special type \f3\fs20 object\f2\fs24  is the pinnacle of every inheritance hierarchy \endash  it\rquote s the ultimate base type of all Python types.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 type\f2\fs24  and \f3\fs20 object\f2\fs24  are the only types in Python that really stand out from other types (and hence they are colored differently). \f3\fs20 type\f2\fs24  is its own type. \f3\fs20 object\f2\fs24  has no base type.\par
}}{\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b Python object creation sequence\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 April 16th, 2012 at 7:03 am\fs24 \par
[The Python version described in this article is 3.x]\par
This article aims to explore the process of creating new objects in Python. As I explained in }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 a previous article}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , object creation is just a special case of calling a callable. Consider this Python code:\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 class}\f3
\fs20  {\cf2 Joe}:\f0\fs24 \line \f3\fs20     {\f4\b\cf2 pass}\f0\fs24 \line \f3\fs20 j = Joe()\f0\fs24 \par
}What happens when \f3\fs20 j = Joe()\f2\fs24  is executed? Python sees it as a call to the callable \f3
\fs20 Joe\f2\fs24 , and routes it to the internal function \f3\fs20 PyObject_Call\f2\fs24 , with \f3\fs20 Joe\f2\fs24  passed as the first argument. \f3\fs20 PyObject_Call\f2\fs24  looks at the type of its first argument to extract its \f3\fs20 tp_call\f2\fs24  attribute.\par
Now, what is the type of \f3\fs20 Joe\f2\fs24 ? Whenever we define a new Python class, unless we explicitly specify }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 a metaclass}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  for it, its type is \f3\fs20 type\f2\fs24 . Therefore, when \f3\fs20 PyObject_Call\f2\fs24  attempts to look at the type of \f3\fs20 Joe\f2\fs24 , it finds \f3\fs20 type\f2\fs24  and picks its \f3\fs20 tp_call\f2\fs24  attribute. In other words, the function \f3\fs20 type_call\f2\fs24  in \f3\fs20 Objects/typeobject.c\f2\fs24  is invoked }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/#id5"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
This is an interesting function, and it\rquote s short, so I\rquote ll paste it wholly here:\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 static}\f3
\fs20  PyObject *\f0\fs24 \line {\f3\fs20\cf2 type_call}\f3\fs20 (PyTypeObject *type, PyObject *args, PyObject *kwds)\f0\fs24 \line \f3\fs20 \{\f0\fs24 \line \f3\fs20     PyObject *obj;\f0
\fs24 \line \f3\fs20     {\f4\b\cf2 if} (type->tp_new == {\cf2 NULL}) \{\f0\fs24 \line \f3\fs20         PyErr_Format(PyExc_TypeError,\f0\fs24 \line \f3\fs20                      {\cf3 "cannot create '%.100s' instances"},\f0
\fs24 \line \f3\fs20                      type->tp_name);\f0\fs24 \line \f3\fs20         {\f4\b\cf2 return} {\cf2 NULL};\f0\fs24 \line \f3\fs20     \}\f0\fs24 \line \f3\fs20     obj = type->tp_new(type, args, kwds);\f0
\fs24 \line \f3\fs20     {\f4\b\cf2 if} (obj != {\cf2 NULL}) \{\f0\fs24 \line \f3\fs20         {\cf6 /* Ugly exception: when the call was type(something),}\f0\fs24 \line {\f3\fs20\cf6            don't call tp_init on the result. */}\line
\f3\fs20         {\f4\b\cf2 if} (type == &PyType_Type &&\f0\fs24 \line \f3\fs20             PyTuple_Check(args) && PyTuple_GET_SIZE(args) == {\cf4 1} &&\f0\fs24 \line \f3\fs20             (kwds == {\cf2 NULL} ||\f0
\fs24 \line \f3\fs20              (PyDict_Check(kwds) && PyDict_Size(kwds) == {\cf4 0})))\f0\fs24 \line \f3\fs20             {\f4\b\cf2 return} obj;\f0\fs24 \line \f3\fs20         {\cf6 /* If the returned object is not an instance of type,}\f0
\fs24 \line {\f3\fs20\cf6            it won't be initialized. */}\line \f3\fs20         {\f4\b\cf2 if} (!PyType_IsSubtype(Py_TYPE(obj), type))\f0\fs24 \line \f3\fs20             {\f4\b\cf2 return} obj;\f0
\fs24 \line \f3\fs20         type = Py_TYPE(obj);\f0\fs24 \line \f3\fs20         {\f4\b\cf2 if} (type->tp_init != {\cf2 NULL} &&\f0\fs24 \line \f3\fs20             type->tp_init(obj, args, kwds) < {\cf4 0}) \{\f0
\fs24 \line \f3\fs20             Py_DECREF(obj);\f0\fs24 \line \f3\fs20             obj = {\cf2 NULL};\f0\fs24 \line \f3\fs20         \}\f0\fs24 \line \f3\fs20     \}\f0\fs24 \line \f3
\fs20     {\f4\b\cf2 return} obj;\f0\fs24 \line \f3\fs20 \}\f0\fs24 \par
}So what arguments is \f3\fs20 type_call\f2\fs24  being passed in our case? The first one is \f3\fs20 Joe\f2\fs24
 itself \endash  but how is it represented? Well, \f3\fs20 Joe\f2\fs24  is a class, so it\rquote s a type (}}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 all classes are types in Python 3}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 ). Types are represented inside the CPython VM by \f3\fs20 PyTypeObject\f2\fs24  objects }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/#id6"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
What \f3\fs20 type_call\f2\fs24  does is first call the \f3\fs20 tp_new\f2\fs24  attribute of the given type. Then, it checks for a special case we can ignore for simplicity, makes sure \f3\fs20 tp_new\f2\fs24  returned an object of the expected type, and then calls \f3\fs20 tp_init\f2\fs24 . If an object of a different type was returned, it is not being initialized.\par
Translated to Python, what happens is this: if your class defines the \f3\fs20 __new__\f2\fs24  special method, it gets called first when a new instance of the class is created. This method has to return some object. Usually, this will be of the required type, but this doesn\rquote t have to be the case. Objects of the required type get \f3\fs20 __init__\f2\fs24  invoked on them. Here\rquote s an example:\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 class}\f3
\fs20  {\cf2 Joe}:\f0\fs24 \line \f3\fs20     {\f4\b\cf2 def} {\cf2 __new__}(cls, *args, **kwargs):\f0\fs24 \line \f3\fs20         obj = {\cf2 super}(Joe, cls).__new__(cls)\f0\fs24 \line
\f3\fs20         {\f4\b\cf2 print}({\cf3 '__new__ called. got new obj id=0x%x'} % {\cf2 id}(obj))\f0\fs24 \line \f3\fs20         {\f4\b\cf2 return} obj\f0\fs24 \line \f3\fs20     {\f4\b\cf2 def} {\cf2 __init__}({\cf2 self}, arg):\f0
\fs24 \line \f3\fs20         {\f4\b\cf2 print}({\cf3 '__init__ called (self=0x%x) with arg=%s'} % ({\cf2 id}({\cf2 self}), arg))\f0\fs24 \line \f3\fs20         {\cf2 self}.arg = arg\f0
\fs24 \line \f3\fs20 j = Joe({\cf4 12})\f0\fs24 \line {\f4\fs20\b\cf2 print}\f3\fs20 ({\cf2 type}(j))\f0\fs24 \par
}This prints:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 __new__ called. got new obj id=0x7f88e7218290\f0\fs24 \line \f3\fs20 __init__ called (self=0x7f88e7218290) with arg=12\f0\fs24 \line \f3\fs20 <class '__main__.Joe'>\f0\fs24 \par
}{\f1\fs28\b Customizing the sequence\par
}As we saw above, since the type of \f3
\fs20 Joe\f2\fs24  is \f3\fs20 type\f2\fs24 , the \f3\fs20 type_call\f2\fs24  function is invoked to define the creation sequence for \f3\fs20 Joe\f2\fs24  instances. This sequence can be changed by specifying a custom type for \f3\fs20 Joe\f2\fs24  \endash  in other words, a metaclass. Let\rquote s modify the previous example to specify a custom metaclass for \f3\fs20 Joe\f2\fs24 :\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 class}\f3
\fs20  {\cf2 MetaJoe}({\cf2 type}):\f0\fs24 \line \f3\fs20     {\f4\b\cf2 def} {\cf2 __call__}(cls, *args, **kwargs):\f0\fs24 \line \f3\fs20         {\f4\b\cf2 print}({\cf3 'MetaJoe.__call__'})\f0
\fs24 \line \f3\fs20         {\f4\b\cf2 return} {\cf2 None}\f0\fs24 \line {\f4\fs20\b\cf2 class}\f3\fs20  {\cf2 Joe}(metaclass=MetaJoe):\f0\fs24 \line \f3\fs20     {\f4\b\cf2 def} {\cf2 __new__}(cls, *args, **kwargs):\f0
\fs24 \line \f3\fs20         obj = {\cf2 super}(Joe, cls).__new__(cls)\f0\fs24 \line \f3\fs20         {\f4\b\cf2 print}({\cf3 '__new__ called. got new obj id=0x%x'} % {\cf2 id}(obj))\f0
\fs24 \line \f3\fs20         {\f4\b\cf2 return} obj\f0\fs24 \line \f3\fs20     {\f4\b\cf2 def} {\cf2 __init__}({\cf2 self}, arg):\f0\fs24 \line \f3\fs20         {\f4\b\cf2 print}({\cf3 '__init__ called (self=0x%x) with arg=%s'} % ({\cf2 id}({\cf2 self}), arg))\f0
\fs24 \line \f3\fs20         {\cf2 self}.arg = arg\f0\fs24 \line \f3\fs20 j = Joe({\cf4 12})\f0\fs24 \line {\f4\fs20\b\cf2 print}\f3\fs20 ({\cf2 type}(j))\f0\fs24 \par
}So now the type of \f3
\fs20 Joe\f2\fs24  is not \f3\fs20 type\f2\fs24 , but \f3\fs20 MetaJoe\f2\fs24 . Consequently, when \f3\fs20 PyObject_Call\f2\fs24  picks the call function to execute for \f3\fs20 j = Joe(12)\f2\fs24 , it takes \f3\fs20 MetaJoe.__call__\f2\fs24 . The latter prints a notice about itself and returns \f3\fs20 None\f2\fs24 , so we don\rquote t expect the \f3\fs20 __new__\f2\fs24  and \f3\fs20 __init__\f2\fs24  methods of \f3\fs20 Joe\f2\fs24  to be called at all. Indeed, this is the outcome:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 MetaJoe.__call__\f0\fs24 \line \f3\fs20 <class 'NoneType'>\f0\fs24 \par
}{\f1\fs28\b Digging deeper \endash  tp_new\par
}Alright, so now we have a better understanding of the object creation sequence. One crucial piece of the puzzle is still missing, though. While we almost always define \f3
\fs20 __init__\f2\fs24  for our classes, defining \f3\fs20 __new__\f2\fs24  is rather rare }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/#id7"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [3]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . Moreover, from a quick look at the code it\rquote s obvious that \f3\fs20 __new__\f2\fs24  is more fundamental in a way. This method is used to create a new object. It is called once and only once per instantiation. \f3\fs20 __init__\f2\fs24 , on the other hand, already gets a constructed object and may not be called at all; it can also be called multiple times.\par
Since the \f3\fs20 type\f2\fs24  parameter passed to \f3\fs20 type_call\f2\fs24  in our case is \f3\fs20 Joe\f2\fs24 , and \f3\fs20 Joe\f2\fs24  does not define a custom \f3\fs20 __new__\f2\fs24  method, then \f3\fs20 type->tp_new\f2\fs24  defers to the \f3\fs20 tp_new\f2\fs24  slot of the base type. The base type of \f3\fs20 Joe\f2\fs24  (}}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/03/the-fundamental-types-of-python-a-diagram/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 and all other Python objects}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , except \f3\fs20 object\f2\fs24  itself) is \f3\fs20 object\f2\fs24 . The \f3\fs20 object.tp_new\f2\fs24  slot is implemented in CPython by the \f3\fs20 object_new\f2\fs24  function in \f3\fs20 Objects/typeobject.c\f2\fs24 .\par
\f3\fs20 object_new\f2\fs24  is actually very simple. It does some argument checking, verifies that the type we\rquote re trying to instantiate is not }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/library/abc.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 abstract}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , and then does this:\par
{\nisusnos \sl300\slmult0 {\f4\fs20\b\cf2 return}\f3
\fs20  type->tp_alloc(type, {\cf4 0});\par
}\f3\fs20 tp_alloc\f2\fs24  is a low-level slot of the type object in CPython. It\rquote s not directly accessible from Python code, but should be familiar to C extension developers. A custom type defined in a C extension may override this slot to supply a custom memory allocation scheme for instances of itself. Most C extension types will, however, defer this allocation to the function \f3
\fs20 PyType_GenericAlloc\f2\fs24 .\par
This function is part of the public C API of CPython, and it also happens to be assigned to the \f3\fs20 tp_alloc\f2\fs24  slot of \f3\fs20 object\f2\fs24  (defined in \f3\fs20 Objects/typeobject.c\f2\fs24 ). It figures out how much memory the new object needs }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/#id8"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [4]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , allocates a memory chunk from CPython\rquote s memory allocator and initializes it all to zeros. It then initializes the bare essential \f3\fs20 PyObject\f2\fs24  fields (type and reference count), does some GC bookkeeping and returns. The result is a freshly allocated instance.\par
{\f1\fs28\b Conclusion\par
}Lest we lose the forest for the trees, let\rquote
s revisit the question this article began with. What happens when CPython executes \f3\fs20 j = Joe()\f2\fs24 ?\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Since \f3\fs20 Joe\f2\fs24  has no explicit metaclass, \f3\fs20 type\f2\fs24  is its type. So the \f3\fs20 tp_call\f2\fs24  slot of \f3\fs20 type\f2\fs24 , which is \f3\fs20 type_call\f2\fs24 , is called.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 type_call\f2\fs24  starts by calling the \f3\fs20 tp_new\f2\fs24  slot of \f3\fs20 Joe\f2\fs24 :\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl1\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f2 Since \f3\fs20 Joe\f2\fs24  has no explicit base clase, its base is \f3\fs20 object\f2\fs24 . Therefore, \f3\fs20 object_new\f2\fs24  is called.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl1\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f2 Since \f3\fs20 Joe\f2\fs24  is a Python-defined class, it has no custom \f3\fs20 tp_alloc\f2\fs24  slot. Therefore, \f3\fs20 object_new\f2\fs24  calls \f3\fs20 PyType_GenericAlloc\f2\fs24 .\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl1\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f3\fs20 PyType_GenericAlloc\f2\fs24  allocates and initializes a chunk of memory big enough to contain \f3\fs20 Joe\f2\fs24 .\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 type_call\f2\fs24  then goes on and calls \f3\fs20 Joe.__init__\f2\fs24  on the newly created object.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl1\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f2 Since \f3\fs20 Joe\f2\fs24  does not define \f3\fs20 __init__\f2\fs24 , its base\rquote s \f3\fs20 __init__\f2\fs24  is called, which is \f3\fs20 object_init\f2\fs24 .\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl1\li720\lin720\fi-720\ri0\rin0\tx720\tx940 {\f3\fs20 object_init\f2\fs24  does nothing.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 The new object is returned from \f3\fs20 type_call\f2\fs24  and is bound to the name \f3\fs20 j\f2\fs24 .\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 This is the vanilla flow for an object of a class that doesn\rquote t have a custom metaclass, doesn\rquote t have an explicit base class, and doesn\rquote t define its own \f3\fs20 __new__\f2\fs24  and \f3\fs20 __init__\f2\fs24  methods. However, this article should have made it quite clear where these custom capabilities plug in to modify the object creation sequence. As you can see, Python is amazingly flexible. Practically every single step of the process described above can be customized, even for user-defined types implemented in Python. Types implemented in a C extension can customize even more, such as the exact memory allocation strategy used to create instances of the type.\par
}}{\pard \nisusnos \nowidctlpar\sb240 \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10480 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10880 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl The \f3\fs20 PyTypeObject\f2\fs24  structure definition for \f3\fs20 type\f2\fs24  is \f3\fs20 PyType_Type\f2\fs24  in \f3\fs20 Objects/typeobject.c\f2\fs24 . You can see that \f3\fs20 type_call\f2\fs24  is being assigned to its \f3\fs20 tp_call\f2\fs24  slot.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10480
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10880 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl A future article will show how this comes to be when a new class is created.\cell }}\row }\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt
\clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10480 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10880 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/#id3"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [3]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Even when we do explicitly override \f3\fs20 __new__\f2\fs24  in our classes, we almost certainly defer the actual object creation to the base\rquote s \f3\fs20 __new__\f2\fs24 .\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth400 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx400 \clvertalt \clftsWidth3 \clwWidth10480
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10880 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/#id4"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [4]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl This information is available in the \f3\fs20 PyObject\f2\fs24  header of any type.\cell }}\row }\pard \plain {\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b Under the hood of Python class definitions\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 June 15th, 2012 at 5:51 am\fs24 \par
This is a fast-paced walk-through of the internals of defining new classes in Python. It shows what actually happens inside the Python interpreter when a new class definition is encountered and processed. Beware, this is advanced material. If the prospect of pondering the metaclass of the metaclass of your class makes you feel nauseated, you better stop now.\par
The focus is on the official (CPython) implementation of Python 3. For modern releases of Python 2 the concepts are similar, although there will be some slight differences in the details.\par
{\f1\fs28\b On the bytecode level\par
}I\rquote
ll start right with the bytecode, ignoring all the good work done by the Python compiler }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id11"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [1]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . For simplicity, this function will be used to demonstrate the bytecode generated by a class definition, since it\rquote s easy to disassemble functions:\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 def}\f3
\fs20  {\cf2 myfunc}():\f0\fs24 \line \f3\fs20     {\f4\b\cf2 class} {\cf2 Joe}:\f0\fs24 \line \f3\fs20         attr = {\cf4 100.02}\f0\fs24 \line \f3\fs20         {\f4\b\cf2 def} {\cf2 foo}({\cf2 self}):\f0
\fs24 \line \f3\fs20             {\f4\b\cf2 return} {\cf4 2}\f0\fs24 \par
}Disassembling \f3\fs20 myfunc\f2\fs24  will show us the steps needed to define a new class:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 >>> dis.disassemble(myfunc.__code__)\f0\fs24 \line \f3\fs20  {\cf4 14}           {\cf4 0} LOAD_BUILD_CLASS\f0
\fs24 \line \f3\fs20               {\cf4 1} LOAD_CONST               {\cf4 1} (<code {\cf2 object} Joe at {\cf4 0x7fe226335b80}, {\cf2 file} {\cf3 "disassemble.py"}, line {\cf4 14}>)\f0
\fs24 \line \f3\fs20               {\cf4 4} LOAD_CONST               {\cf4 2} ({\cf3 'Joe'})\f0\fs24 \line \f3\fs20               {\cf4 7} MAKE_FUNCTION            {\cf4 0}\f0\fs24 \line
\f3\fs20              {\cf4 10} LOAD_CONST               {\cf4 2} ({\cf3 'Joe'})\f0\fs24 \line \f3\fs20              {\cf4 13} CALL_FUNCTION            {\cf4 2}\f0\fs24 \line \f3\fs20              {\cf4 16} STORE_FAST               {\cf4 0} (Joe)\f0
\fs24 \line \f3\fs20              {\cf4 19} LOAD_CONST               {\cf4 0} ({\cf2 None})\f0\fs24 \line \f3\fs20              {\cf4 22} RETURN_VALUE\f0\fs24 \par
}The number immediately preceding the instruction name is its offset in the binary representation of the code object. All the instructions until and including the one at offset 16 are for defining the class. The last two instructions are for \f3
\fs20 myfunc\f2\fs24  to return \f3\fs20 None\f2\fs24 .\par
Let\rquote s go through them, step by step. Documentation of the Python bytecode instructions is available in the }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/library/dis.htm"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 dis module}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
\f3\fs20 LOAD_BUILD_CLASS\f2\fs24  is a special instruction used for creating classes. It pushes the function \f3\fs20 builtins.__build_class__\f2\fs24  onto the stack. We\rquote ll examine this function in much detail later.\par
Next, a code object, followed by a name (\f3\fs20 Joe\f2\fs24 ) are pushed onto the stack as well. The code object is interesting, let\rquote s peek inside:\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 >>> dis.disassemble(myfunc.__code__.co_consts[{\cf4 1}])\f0
\fs24 \line \f3\fs20  {\cf4 14}           {\cf4 0} LOAD_FAST                {\cf4 0} (__locals__)\f0\fs24 \line \f3\fs20               {\cf4 3} STORE_LOCALS\f0\fs24 \line \f3\fs20               {\cf4 4} LOAD_NAME                {\cf4 0} (__name__)\f0
\fs24 \line \f3\fs20               {\cf4 7} STORE_NAME               {\cf4 1} (__module__)\f0\fs24 \line \f3\fs20              {\cf4 10} LOAD_CONST               {\cf4 0} ({\cf3 'myfunc.<locals>.Joe'})\f0
\fs24 \line \f3\fs20              {\cf4 13} STORE_NAME               {\cf4 2} (__qualname__)\f0\fs24 \line \f3\fs20  {\cf4 15}          {\cf4 16} LOAD_CONST               {\cf4 1} ({\cf4 100.02})\f0
\fs24 \line \f3\fs20              {\cf4 19} STORE_NAME               {\cf4 3} (attr)\f0\fs24 \line \f3\fs20  {\cf4 16}          {\cf4 22} LOAD_CONST               {\cf4 2} (<code {\cf2 object} foo at {\cf4 0x7fe226335c40}, {\cf2 file} {\cf3 "disassemble.py"}, line {\cf4 16}>)\f0
\fs24 \line \f3\fs20              {\cf4 25} LOAD_CONST               {\cf4 3} ({\cf3 'myfunc.<locals>.Joe.foo'})\f0\fs24 \line \f3\fs20              {\cf4 28} MAKE_FUNCTION            {\cf4 0}\f0
\fs24 \line \f3\fs20              {\cf4 31} STORE_NAME               {\cf4 4} (foo)\f0\fs24 \line \f3\fs20              {\cf4 34} LOAD_CONST               {\cf4 4} ({\cf2 None})\f0\fs24 \line
\f3\fs20              {\cf4 37} RETURN_VALUE\f0\fs24 \par
}This code defines the innards of the class. Some generic bookkeeping, followed by definitions for the \f3\fs20 attr\f2\fs24  attribute and \f3
\fs20 foo\f2\fs24  method.\par
Now let\rquote s get back to the first disassembly. The next instruction (at offset 7) is \f3\fs20 MAKE_FUNCTION\f2\fs24  }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id12"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [2]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . This instruction pulls two things from the stack \endash  a name and a code object. So in our case, it gets the name \f3\fs20 Joe\f2\fs24  and the code object we saw disassembled above. It creates a function with the given name and the code object as its code and pushes it back to the stack.\par
This is followed by once again pushing the name \f3\fs20 Joe\f2\fs24  onto the stack. Here\rquote s what the stack looks like now (TOS means "top of stack"):\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 TOS> name "Joe"\f0\fs24 \line \f3\fs20      function "Joe" with code for defining the class\f0\fs24 \line \f3\fs20      function builtins.__build_class__\f0\fs24 \line \f3\fs20      -----------------------------------------------\f0\fs24 \par
}At this point (offset 13), \f3
\fs20 CALL_FUNCTION 2\f2\fs24  is executed. The 2 simply means that the function was passed two positional arguments (and no keyword arguments). \f3\fs20 CALL_FUNCTION\f2\fs24  first takes the arguments from the stack (the rightmost on top), and then the function itself. So the call is equivalent to:\par
{\nisusnos \sl300\slmult0 \f3\fs20 builtins.__build_class__(function defining "Joe", "Joe")\f0\fs24 \par
}{\f1\fs28\b Build me a class, please\par
}A quick peek into the \f3
\fs20 builtins\f2\fs24  module in \f3\fs20 Python/bltinmodule.c\f2\fs24  reveals that \f3\fs20 __build_class__\f2\fs24  is implemented by the function \f3\fs20 builtin___build_class__\f2\fs24  (I\rquote ll call it BBC for simplicity) in the same file.\par
As any Python function, BBC accepts both positional and keyword arguments. The positional arguments are:\par
{\nisusnos \sl300\slmult0 \f3\fs20 func, name, base1, base2, ... baseN\f0\fs24 \par
}So we see only the function and name were passed for \f3
\fs20 Joe\f2\fs24 , since it has no base classes. The only keyword argument BBC understands is \f3\fs20 metaclass\f2\fs24  }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id13"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [3]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , allowing the Python 3 way of defining }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 metaclasses}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 class}\f3
\fs20  {\cf2 SomeOtherJoe}(metaclass=JoeMeta):\f0\fs24 \line \f3\fs20   [...]\f0\fs24 \par
}So back to BBC, here\rquote s what it does }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id14"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [4]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 16.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 The first chunk of code deals with extracting the arguments and setting defaults.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 17.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Next, if no metaclass is supplied, BBC looks at the base classes and takes the metaclass of the first base class. If there are no base classes, the default metaclass \f3\fs20 type\f2\fs24  is used.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 18.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 If the metaclass is really a class (note that in Python any callable can be given as a metaclass), look at the bases again to determine "the most derived" metaclass.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 The last point deserves a bit of elaboration. If our class has bases, then some rules apply for the metaclasses that are allowed. The metaclasses of its bases must be either subclasses or superclasses of our class\rquote s metaclass. Any other arrangement will result in this \f3\fs20 TypeError\f2\fs24 :\par
{\nisusnos \keepn\sl300\slmult0 \f3\fs20 metaclass conflict: the metaclass of a derived class must be a (non-strict)\f0\fs24 \line \f3\fs20                     subclass of the metaclasses of all its bases\f0\fs24 \par
}Eventually, given that there are no conflicts, the most derived metaclass will be chosen. The most derived metaclass is the one which is a subtype of the explicitly specified metaclass and the metaclasses of all the base classes. In other words, if our class\rquote
s metaclass is \f3\fs20 Meta1\f2\fs24 , only one of the bases has a metaclass and that\rquote s \f3\fs20 Meta2\f2\fs24 , and \f3\fs20 Meta2\f2\fs24  is a subclass of \f3\fs20 Meta1\f2\fs24 , it is \f3\fs20 Meta2\f2\fs24  that will be picked to serve as the eventual metaclass of our class.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 5.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls6\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 At this point BBC has a metaclass }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id15"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240\ls6\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\cs803 \f2\ul\ulc1\cf1 [5]}}}}{\pard \nisusnos \nowidctlpar\sb240\ls6\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 , so it starts by calling its \f3\fs20 __prepare__\f2\fs24  method to create a namespace dictionary for the class. If there\rquote s no such method, an empty dict is used.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 As documented in the }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/reference/datamodel.html"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 data model reference}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
If the metaclass has a __prepare__() attribute (usually implemented as a class or static method), it is called before the class body is evaluated with the name of the class and a tuple of its bases for arguments. It should return an object that supports the mapping interface that will be used to store the namespace of the class. The default is a plain dictionary. This could be used, for example, to keep track of the order that class attributes are declared in by returning an ordered dictionary.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 5.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls13\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 The function argument is invoked, passing the namespace dict as the only argument. If we look back at the disassembly of this function (the second one), we see that the first argument is placed into the \f3\fs20 f_locals\f2\fs24  attribute of the frame (with the \f3\fs20 STORE_LOCALS\f2\fs24  instruction). In other words, this dictionary is then used to populate the class attributes. The function itself returns \f3\fs20 None\f2\fs24  \endash  its outcome is modifying the namespace dictionary.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 6.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls14\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 Finally, the metaclass is called with the name, list of bases and namespace dictionary as arguments.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 The last step defers to the metaclass to actually create a new class with the given definition. }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 Recall that}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  when some class \f3\fs20 MyKlass\f2\fs24  has a metaclass \f3\fs20 MyMeta\f2\fs24 , then the class definition of \f3\fs20 MyKlass\f2\fs24  is equivalent to }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id16"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [6]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
{\nisusnos \sl300\slmult0 \f3\fs20 MyKlass = MyMeta(name, bases, namespace_dict)\f0\fs24 \par
}The flow of BBC outlined above directly embodies this equivalence.\par
So what happens next? Well, the metaclass \f3
\fs20 MyMeta\f2\fs24  is a class, right? And what happens when a class is "called"? }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 It\rquote s instantiated}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . How is a class\rquote s instantiation done? By invoking its metaclass\rquote s \f3\fs20 __call__\f2\fs24 . So wait, this is the metaclass\rquote s metaclass we\rquote re talking about here, right? Yes! A metaclass is just a class, after all }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id17"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [7]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , and has a metaclass of its own \endash  so Python has to keep the meta-flow going.\par
Realistically, what probably happens is this:\par
Most chances are that your class has no metaclass specified explicitly. Then, its default metaclass is \f3\fs20 type\f2\fs24 , so the call above is actually:\par
{\nisusnos \sl300\slmult0 \f3\fs20 MyKlass = {\cf2 type}(name, bases, namespace_dict)\f0
\fs24 \par
}The metaclass of \f3\fs20 type\f2\fs24  happens to be \f3\fs20 type\f2\fs24  itself, so here \f3\fs20 type.__call__\f2\fs24  is called.\par
In the more complex case that your class does have a metaclass, most chances are that the metaclass itself has no metaclass }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id18"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [8]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , so \f3\fs20 type\f2\fs24  is used for it. Therefore, the \f3\fs20 MyMeta(...)\f2\fs24  call is also served by \f3\fs20 type.__call__\f2\fs24 .\par
{\f1\fs28\b type_call\par
}In \f3
\fs20 Objects/typeobject.c\f2\fs24 , the \f3\fs20 type.__call__\f2\fs24  slot is getting mapped to the function \f3\fs20 type_call\f2\fs24 . I\rquote ve already spent some time explaining }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 how it works}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , so it\rquote s important to review that article at this point.\par
Things are a bit different here, however. The }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 object creation sequence article}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  explained how instances are created, so the \f3\fs20 tp_new\f2\fs24  slot called from \f3\fs20 type_call\f2\fs24  went to \f3\fs20 object\f2\fs24 . Here, since \f3\fs20 type_call\f2\fs24  will actually call \f3\fs20 tp_new\f2\fs24  on a metaclass, and the metaclass\rquote s base is \f3\fs20 type\f2\fs24  (see }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/04/03/the-fundamental-types-of-python-a-diagram/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 this diagram}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 ), we\rquote ll have to study how the \f3\fs20 type_new\f2\fs24  function (also from \f3\fs20 Objects/typeobject.c\f2\fs24 ) works.\par
{\f1\fs28\b A brief recap\par
}I feel that the flow here is relatively convoluted, so lest we lose focus, let\rquote
s have a brief recap of how we got thus far. The following is a much simplified version of the flow described so far in this article:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 1.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls15\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 When a new class \f3\fs20 Joe\f2\fs24  is defined\u8230 ?\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 2.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls16\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 The Python interpreter arranges the builtin function \f3\fs20 builtin__build_class__\f2\fs24  (BBC) to be called, giving it the class name and its innards compiled into a code object.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 3.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls16\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 BBC finds the metaclass of \f3\fs20 Joe\f2\fs24  and calls it to create the new class.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 4.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls16\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 When any class in Python is called, it means that its metaclass\rquote s \f3\fs20 tp_call\f2\fs24  slot is invoked. So to create \f3\fs20 Joe\f2\fs24 , this is the \f3\fs20 tp_call\f2\fs24  of its metaclass\rquote s metaclass. In most cases this is the \f3\fs20 type_call\f2\fs24  function (since the metaclass\rquote s metaclass is almost always \f3\fs20 type\f2\fs24 , or something that eventually delegates to it).\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 5.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls16\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 type_call\f2\fs24  creates a new instance of the type it\rquote s bound to by calling its \f3\fs20 tp_new\f2\fs24  slot.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 6.\tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls16\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f2 In our case, that is served by the \f3\fs20 type_new\f2\fs24  function.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 The next section picks up from step 6.\par
{\f1\fs28\b type_new\par
}The \f3
\fs20 type_new\f2\fs24  function is a complex beast \endash  it\rquote s over 400 lines long. There\rquote s a good reason for this, however, since it plays a very fundamental role in the Python object system. It\rquote s literally responsible for creating all Python types. I\rquote ll go over its functionality in major blocks, pasting short snippets of code where relevant.\par
Let\rquote s start at the beginning. The signature of \f3\fs20 type_new\f2\fs24  is:\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 static}\f3
\fs20  PyObject *\f0\fs24 \line \f3\fs20 type_new(PyTypeObject *metatype, PyObject *args, PyObject *kwds)\f0\fs24 \par
}When called to create our class \f3\fs20 Joe\f2\fs24 , the arguments will be:\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 metatype\f2\fs24  \endash  the metaclass, so it\rquote s \f3\fs20 type\f2\fs24  itself.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 args\f2\fs24  \endash  we saw in the description of BBC above that this is the class name, list of base classes and a namespace dict.\par
}}{\listtext {\pard \nisusnos \nowidctlpar\sb240\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\sb240\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 kwds\f2\fs24  \endash  since \f3\fs20 Joe\f2\fs24  has no metaclass, this will be empty.\par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 At this point, it may be useful }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 to recall that}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 :\par
{\nisusnos \keepn\sl300\slmult0 {\f4\fs20\b\cf2 class}\f3
\fs20  {\cf2 Joe}:\f0\fs24 \line \f3\fs20   ... contents\f0\fs24 \par
}Is equivalent to:\par
{\nisusnos \sl300\slmult0 \f3\fs20 Joe = {\cf2 type}({\cf3 'joe'}, (), {\cf2 dict} of contents)\par
}\f3
\fs20 type_new\f2\fs24  serves both approaches, of course.\par
It starts by handling the special 1-argument call of the \f3\fs20 type\f2\fs24  function, which returns the type. Then, it tries to see if the requested type has a metaclass that\rquote s more suitable than the one passed in. This is necessary to handle a direct call to \f3\fs20 type\f2\fs24  as shown above \endash  if one of the bases has a metaclass, that metaclass should be used for the creation }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id19"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [9]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 .\par
Next, \f3\fs20 type_new\f2\fs24  handles some special class methods (for example \f3\fs20 __slots__\f2\fs24 ).\par
Finally, the type object itself is allocated and initialized. Since the }}{\field {\*\fldinst HYPERLINK "http://www.python.org/download/releases/2.2/descrintro/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 unification of types and classes}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  in Python, user-defined classes are represented similarly to built-in types inside the CPython VM. However, there\rquote s still a difference. Unlike built-in types (and new types exported by C extension) which are statically allocated and are essentially "singletons", user-defined classes have to be implemented by dynamically allocated type objects on the heap }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id20"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 [10]}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 . For this purpose, \f3\fs20 Include/object.h\f2\fs24  defines an "extended type object", \f3\fs20 PyHeapTypeObject\f2\fs24 . This struct starts with a \f3\fs20 PyTypeObject\f2\fs24  member, so it can be passed around to Python C code expecting any normal type. The extra information it carries is used mainly for book-keeping in the type-handling code (\f3\fs20 Objects/typeobject.c\f2\fs24 ). \f3\fs20 PyHeapTypeObject\f2\fs24  is an interesting type to discuss but would deserve an article of its own, so I\rquote ll stop right here.\par
Just as an example of one of the special cases handled by \f3\fs20 type_new\f2\fs24  for members of new classes, let\rquote s look at \f3\fs20 __new__\f2\fs24 . The data model reference }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/reference/datamodel.html#object.__new__"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 says}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2  about it:\par
Called to create a new instance of class cls. __new__() is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument.\par
It\rquote s interesting to see how this statement is embodied in the code of \f3\fs20 type_new\f2\fs24 :\par
{\nisusnos \keepn\sl300\slmult0 {\f3\fs20\cf6 /* Special-case __new__: if it's a plain function,}\f0
\line {\f3\fs20\cf6    make it a static function */}\line \f3\fs20 tmp = _PyDict_GetItemId(dict, &PyId___new__);\f0\fs24 \line {\f4\fs20\b\cf2 if}\f3\fs20  (tmp != {\cf2 NULL} && PyFunction_Check(tmp)) \{\f0
\fs24 \line \f3\fs20     tmp = PyStaticMethod_New(tmp);\f0\fs24 \line \f3\fs20     {\f4\b\cf2 if} (tmp == {\cf2 NULL})\f0\fs24 \line \f3\fs20         {\f4\b\cf2 goto} error;\f0\fs24 \line
\f3\fs20     {\f4\b\cf2 if} (_PyDict_SetItemId(dict, &PyId___new__, tmp) < {\cf4 0})\f0\fs24 \line \f3\fs20         {\f4\b\cf2 goto} error;\f0\fs24 \line \f3\fs20     Py_DECREF(tmp);\f0
\fs24 \line \f3\fs20 \}\f0\fs24 \par
}So when the dict of the new class has a \f3\fs20 __new__\f2\fs24  method, it\rquote s automatically replaced with a corresponding static method.\par
After some more handling of special cases, \f3
\fs20 type_new\f2\fs24  returns the object representing the newly created type.\par
{\f1\fs28\b Conclusion\par
}This has been a relatively dense article. If you got lost, don\rquote t despair. The important part to remember is the flow described in "A brief recap" \endash
 the rest of the article just explains the items in that list in more detail.\par
The Python type system is very powerful, dynamic and flexible. Since this all has to be implemented in the low-level and type-rigid C, and at the same time be relatively efficient, the implementation is almost inevitably complex. If you\rquote re just writing Python code, you almost definitely don\rquote t have to be aware of all these details. However, if you\rquote re writing non-trivial C extensions, and/or hacking on CPython itself, understanding the contents of this article (at least on an approximate level) can be useful and educational.\par
Many thanks to Nick Coghlan for reviewing this article.\par
}}{\pard \nisusnos \f2 \par }\plain
\intbl \trowd \trql \ltrrow \trrh0 \clheight0 \nisustablepadt240 \nisustablepadl20 \nisustablepadb0 \nisustablepadr20 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id1"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [1]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl If you\rquote re interested in the compilation part, }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl this article}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2  provides a good overview.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id2"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [2]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl In the distant past, \f3\fs20 MAKE_FUNCTION\f2\fs24  was used both for creating functions and classes. However, when lexical scoping was added to Python, a new instruction for creating functions was added \endash  \f3\fs20 MAKE_CLOSURE\f2\fs24 . So nowadays, as strange as it sounds, \f3\fs20 MAKE_FUNCTION\f2\fs24  is only used for creating classes, not functions.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id3"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [3]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl The other keyword arguments, if they exist, are passed to the metaclass when it\rquote s getting called.\cell }}\row }\trowd \trql \ltrrow
\trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id4"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [4]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl You may find it educational to open the file \f3\fs20 Python/bltinmodule.c\f2\fs24  from the Python source distribution and follow along.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id5"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [5]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl There always is some metaclass, because all classes eventually derive from \f3\fs20 object\f2\fs24  whose metaclass is \f3\fs20 type\f2\fs24 .\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id6"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [6]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl With the caveat that BBC also calls \f3\fs20 __prepare__\f2\fs24 . For a more equivalent sequence, take a look at }}{\field {\*\fldinst HYPERLINK "http://docs.python.org/dev/library/types.html?highlight=new_class#types.new_class"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl types.new_class}}}}{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 .\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id7"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [7]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl As I mentioned earlier, any callable can be specified as a metaclass. If the callable is a function and not a class, it\rquote s simply called as the last step of BBC \endash  the rest of the discussion doesn\rquote t apply.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id8"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [8]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl I\rquote ve never encountered real-world Python code where a metaclass has a metaclass of its own. If you have, please let me know \endash  I\rquote m genuinely curious about the use cases for such a construct.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id9"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [9]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl If you\rquote ve noticed that this is a duplication of effort, you\rquote re right. BBC also computes the metaclass, but to handle the \f3\fs20 type(...)\f2\fs24  call, \f3\fs20 type_new\f2\fs24  has to do this again. I think that creating new classes is a rare enough occurrence that the extra work done here doesn\rquote t count for much.\cell }}\row
}\trowd \trql \ltrrow \trrh0 \clheight0 \clvertalt \clftsWidth3 \clwWidth560 \clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx560 \clvertalt \clftsWidth3 \clwWidth10200
\clpadl20 \clpadfl3 \clpadr20 \clpadfr3 \clpadb20 \clpadfb3 \clpadt20 \clpadft3 \cellx10760 {{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/06/15/under-the-hood-of-python-class-definitions/#id10"}{\fldrslt {\pard \intbl \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 \intbl [10]}}}}\cell
{\pard \intbl \nisusnos \nowidctlpar\sb240 {\f2 \intbl Since they have to be garbage collected and fully deleted when no longer needed.\cell }}\row }\pard \plain {\pard \s466 \qc\nowidctlpar\sa240 {\f5 \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \emdash \f2 \par
}}{\pard \s466 {\f1\fs28\b Faster XML iteration with ElementTree\fs36 \par
}}{\pard \nisusnos \nowidctlpar\sb240 {\f2\fs20 June 17th, 2012 at 5:28 am\fs24 \par
As I\rquote ve }}{\field {\*\fldinst HYPERLINK "http://eli.thegreenplace.net/2012/03/02/python-development-improving-elementtree-for-3-3/"}{\fldrslt {\pard \nisusnos \nowidctlpar\sb240 {\cs803 \f2\ul\ulc1\cf1 mentioned previously}}}}{\pard \nisusnos \nowidctlpar\sb240 {\f2 , starting with Python 3.3 the C accelerator of the \f3\fs20 xml.etree.ElementTree\f2\fs24  module is going to be imported by default. This should make quite a bit of code faster for those who were not aware of the existence of the accelerator, and reduce the amount of boilerplate importing for everyone.\par
As Python 3.3 is nearing its first beta, more work was done in the past few weeks; mostly fixing all kinds of problems that arose from the aforementioned transition. But in this post I want to focus on one feature that was added this weekend \endash  much faster iteration over the parsed XML tree.\par
\f3\fs20 ElementTree\f2\fs24  offers a few tools for iterating over the tree and for finding interesting elements in it, but the basis for them all is the \f3\fs20 iter\f2\fs24  method:\par
Creates a tree iterator with the current element as the root. The iterator iterates over this element and all elements below it, in document (depth first) order. If tag is not None or \lquote *\rquote , only elements whose tag equals tag are returned from the iterator.\par
And until very recently, this \f3\fs20 iter\f2\fs24  was implemented in Python, even when the C accelerator was loaded. This was achieved by calling \f3\fs20 PyRun_String\f2\fs24  on a "bootstrap" string defining the method (as well as a bunch of other Python code), when the C extension module was being initialized. In the past few months I\rquote ve been slowly and surely decimating this bootstrap code, trying to move as much functionality as possible into the C code and replacing stuff with actual C API calls. The last bastion was \f3\fs20 iter\f2\fs24  (and its cousin \f3\fs20 itertext\f2\fs24 ) because its implementation in C is not trivial.\par
Well, that last bastion has now fallen and the C accelerator of \f3\fs20 ElementTree\f2\fs24  no longer has any Python bootstrap code \endash  \f3\fs20 iter\f2\fs24  is actually implemented in C. And the great "side effect" of this is that the \f3\fs20 iter\f2\fs24  method (and all the other methods that rely on it, like \f3\fs20 find\f2\fs24 , \f3\fs20 iterfind\f2\fs24  and others) is now much faster. On a relatively large XML document I timed a {\f1\b 10x speed boost} for simple iteration looking for a specific tag. I hope that this will make a lot of XML processing code in Python much faster out-of-the-box.\par
This change is already in Python trunk and will be part of the 3.3 release. I must admit that I didn\rquote
t spend much time optimizing the C code implementing \f3\fs20 iter\f2\fs24 , so there may still be an area for improvement. I have a hunch that it can be made a few 10s of percents faster with a bit of effort. If you\rquote re interested to help, drop me a line and I will be happy to discuss it.\nisusselectcaret \par }}}