{\rtf1 \mac \ansicpg10000 \nisusversion40007 \deff0 {\fonttbl {\f0 \froman \fcharset77 Times-Roman{\*\falt Times};}{\f1 \fswiss \fcharset77 LucidaGrande{\*\falt Lucida Grande};}{\f2 \fswiss \fcharset77 LucidaGrande-Bold{\*\falt Lucida Grande};}{\f3 \fmodern \fcharset77 Courier;}{\f4 \fnil \fcharset77 Tahoma-Bold{\*\falt Tahoma};}{\f5 \fswiss \fcharset77 Tahoma;}}{\colortbl ;\red0 \green0 \blue233 ;\red0 \green0 \blue0 ;\red0 \green0 \blue255 ;}{\*\revtbl {Unknown;}{ ;}}\nisusrevtypes0 \donotshowinsdel1 {\*\nisustoctable {\nisustoc \tcf68 {\nisustocname Default TOC}{\*\nisustoctabrep  }{\*\nisustocretrep  }{\nisustoclevelstyle TOC 1}{\nisustoclevelstyle TOC 2}{\nisustoclevelstyle TOC 3}{\nisustoclevelstyle TOC 4}{\nisustoclevelstyle TOC 5}{\nisustoclevelstyle TOC 6}{\nisustoclevelstyle TOC 7}{\nisustoclevelstyle TOC 8}{\nisustoclevelstyle TOC 9}}\nisusactivetoc68
}{\*\nisusxetable {\nisusxe \xef68 {\nisusxename Default Index}{\nisusxeheaderstyle Index Heading}{\nisusxelevelstyle Index 1}{\nisusxelevelstyle Index 2}{\nisusxelevelstyle Index 3}{\nisusxelevelstyle Index 4}{\nisusxelevelstyle Index 5}{\nisusxelevelstyle Index 6}{\nisusxelevelstyle Index 7}{\nisusxelevelstyle Index 8}{\nisusxelevelstyle Index 9}{\*\fldinst INDEX \\k ". " \\g \endash  \\e "\tab " \\l ", " \\f D}}\nisusactivexe68
}{\stylesheet {\s813 \nisusnoteplacement0 \nisusnotespanheight1300 \nisusnotespanlines5 \nisusnotedocrefstyle814 \nisusnoterefstyle815 \nisusnotegutterh60 {\*\nisusnotedefaulttext .\u160 ?}\nisusnotedivalign2
\nisusnotedivpercent25 \nisusnotedivoverpercent75 {\*\nisusnotedivstyle \nisusbrdredge \brdrs \brdrw20 \brdrcf2 }\sbasedon816 \f0\fs24 \ql\nowidctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar
\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Footnote;}{\*\cs814 \super Note Reference;}{\*\cs815 \sbasedon814 \nosupersub Note Reference in Note;}{\s816 \snext816 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Normal;}{\s817 \nisusnoteplacement2 \nisusnotespanheight1300 \nisusnotespanlines5 \nisusnotedocrefstyle814 \nisusnoterefstyle815 \nisusnotegutterh60 {\*\nisusnotedefaulttext .\u160 ?}\nisusnotedivalign2
\nisusnotedivpercent25 \nisusnotedivoverpercent75 {\*\nisusnotedivstyle \nisusbrdredge \brdrs \brdrw20 \brdrcf2 }\sbasedon816 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar
\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Endnote;}{\s818 \snext816 \sbasedon816 \f4\fs28\b \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl1 Heading 1;}{\s819 \snext816 \sbasedon818 \f4\fs26\b \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl2 Heading 2;}{\s820 \snext816 \sbasedon819 \f4\fs26\b\i \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl3 Heading 3;}{\s821 \snext821 \sbasedon816 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Header;}{\s822 \snext816 \sbasedon816 \f4\fs28\b \qc\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Title;}{\s823 \snext823 \sbasedon816 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 Footer;}{\s824 \snext824 \sbasedon816 \f0\fs24 \ql\widctlpar\keep0\keepn0\sb0\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li1080\lin1080\fi0\ri1020\rin1020 Block Quote;}{\*\cs825 \i Emphatic;}{\s826 \snext816 \sbasedon820 \f5\fs26\b0\i0 \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl4 Heading 4;}{\s827 \snext816 \sbasedon826 \f5\fs26\b0\i0\ul \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl5 Heading 5;}{\s828 \snext816 \sbasedon827 \f5\fs26\b0\i\ul \ql\widctlpar\keep0\keepn0\sb120\sa0\sl240\slmult1\ltrpar\pardirnatural\hyphpar1\li0\lin0\fi0\ri0\rin0 \tcf68 \tcl6 Heading 6;}{\*\cs829 \b Strong;}{\*\cs847 \ul\cf3 Hyperlink;}}{\*\listtable {\list \listhybrid {\listlevel \levelnfc1 \levelnfcn1 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li360
\lin360 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc3 \levelnfcn3 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'01.;}{\levelnumbers \'01;}\li720
\lin720 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'02.;}{\levelnumbers \'01;}\li1080
\lin1080 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'03);}{\levelnumbers \'01;}\li1440
\lin1440 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'04);}{\levelnumbers \'02;}\li1800
\lin1800 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'05);}{\levelnumbers \'02;}\li2160
\lin2160 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'06);}{\levelnumbers \'02;}\li2520
\lin2520 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'07);}{\levelnumbers \'02;}\li2880
\lin2880 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'08);}{\levelnumbers \'02;}\li3240
\lin3240 \fi-360 \ri0 \rin0 }{\listname ;}\listid958829064 \nisuslistcontnum0 {\*\liststylename Outline;}}{\list \listhybrid {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li576
\lin576 \fi-576 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'04\'00.\'01.;}{\levelnumbers \'01\'03;}\li796
\lin796 \fi-796 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'06\'00.\'01.\'02.;}{\levelnumbers \'01\'03\'05;}\li1016
\lin1016 \fi-1016 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'08\'00.\'01.\'02.\'03.;}{\levelnumbers \'01\'03\'05\'07;}\li1236
\lin1236 \fi-1236 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0a\'00.\'01.\'02.\'03.\'04.;}{\levelnumbers \'01\'03\'05\'07\'09;}\li1456
\lin1456 \fi-1456 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0c\'00.\'01.\'02.\'03.\'04.\'05.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b;}\li1676
\lin1676 \fi-1676 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0e\'00.\'01.\'02.\'03.\'04.\'05.\'06.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d;}\li1896
\lin1896 \fi-1896 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'10\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d\'0f;}\li2116
\lin2116 \fi-2116 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'12\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\li2336
\lin2336 \fi-2336 \ri0 \rin0 }{\listname ;}\listid322791560 \nisuslistcontnum1 {\*\liststylename Headings;}}{\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid108668244 \nisuslistcontnum1 {\*\liststylename Bullet List 3;}}{\list \listsimple1 {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat2 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid614056598 \nisuslistcontnum1 {\*\liststylename Number List 1;}}{\list \listhybrid {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li648
\lin648 \fi-648 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'04\'00.\'01.;}{\levelnumbers \'01\'03;}\li868
\lin868 \fi-868 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'06\'00.\'01.\'02.;}{\levelnumbers \'01\'03\'05;}\li1088
\lin1088 \fi-1088 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'08\'00.\'01.\'02.\'03.;}{\levelnumbers \'01\'03\'05\'07;}\li1308
\lin1308 \fi-1308 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0a\'00.\'01.\'02.\'03.\'04.;}{\levelnumbers \'01\'03\'05\'07\'09;}\li1528
\lin1528 \fi-1528 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0c\'00.\'01.\'02.\'03.\'04.\'05.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b;}\li1748
\lin1748 \fi-1748 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'0e\'00.\'01.\'02.\'03.\'04.\'05.\'06.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d;}\li1968
\lin1968 \fi-1968 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'10\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d\'0f;}\li2188
\lin2188 \fi-2188 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'12\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08.;}{\levelnumbers \'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\li2408
\lin2408 \fi-2408 \ri0 \rin0 }{\listname ;}\listid1790318751 \nisuslistcontnum0 {\*\liststylename Tiered List;}}{\list \listhybrid {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li720
\lin720 \fi-432 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'01.;}{\levelnumbers \'01;}\li1080
\lin1080 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'02.;}{\levelnumbers \'01;}\li1440
\lin1440 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'03);}{\levelnumbers \'02;}\li1800
\lin1800 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'04);}{\levelnumbers \'02;}\li2160
\lin2160 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'05);}{\levelnumbers \'02;}\li2520
\lin2520 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'06);}{\levelnumbers \'01;}\li2880
\lin2880 \fi-431 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'07);}{\levelnumbers \'01;}\li3240
\lin3240 \fi-432 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'08);}{\levelnumbers \'01;}\li3600
\lin3600 \fi-432 \ri0 \rin0 }{\listname ;}\listid1493869940 \nisuslistcontnum0 {\*\liststylename Number List;}}{\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid637850124 \nisuslistcontnum1 {\*\liststylename Bullet List 2;}}{\list \listhybrid {\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li648
\lin648 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'01.;}{\levelnumbers \'01;}\li1008
\lin1008 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'02.;}{\levelnumbers \'01;}\li1368
\lin1368 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'03);}{\levelnumbers \'02;}\li1728
\lin1728 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'04);}{\levelnumbers \'02;}\li2088
\lin2088 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'03(\'05);}{\levelnumbers \'02;}\li2448
\lin2448 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc4 \levelnfcn4 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'06);}{\levelnumbers \'01;}\li2808
\lin2808 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'07);}{\levelnumbers \'01;}\li3168
\lin3168 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc2 \levelnfcn2 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'08);}{\levelnumbers \'01;}\li3528
\lin3528 \fi-360 \ri0 \rin0 }{\listname ;}\listid1240764503 \nisuslistcontnum0 {\*\liststylename Lettered List;}}{\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid1554270776 \nisuslistcontnum1 {\*\liststylename Bullet List 1;}}{\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid1116666771 \nisuslistcontnum1 {\*\liststylename Bullet List 6;}}{\list \listhybrid {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li648
\lin648 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li1008
\lin1008 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li1368
\lin1368 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li1728
\lin1728 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li2088
\lin2088 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li2448
\lin2448 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li2808
\lin2808 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li3168
\lin3168 \fi-360 \ri0 \rin0 }{\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li3528
\lin3528 \fi-360 \ri0 \rin0 }{\listname ;}\listid1462789551 \nisuslistcontnum0 {\*\liststylename Bullet List;}}{\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid981747696 \nisuslistcontnum1 {\*\liststylename Bullet List 5;}}{\list \listsimple1 {\listlevel \levelnfc23 \levelnfcn23 \leveljcn0 \levelfollow0 \levelstartat1 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'01\u8226 ?;}{\levelnumbers ;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid1026076958 \nisuslistcontnum1 {\*\liststylename Bullet List 4;}}{\list \listsimple1 {\listlevel \levelnfc0 \levelnfcn0 \leveljcn0 \levelfollow0 \levelstartat4 \nisuslevelnuminc1 \levelspace0 \levelindent0 {\leveltext \'02\'00.;}{\levelnumbers \'01;}\li720
\lin720 \fi-500 \ri0 \rin0 }{\listname ;}\listid711192801 \nisuslistcontnum1 {\*\liststylename Number List 2;}}}{\*\listoverridetable {\listoverride \listid1554270776 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls1
}{\listoverride \listid1554270776 \listoverridecount0 \ls2 }{\listoverride \listid637850124 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls3
}{\listoverride \listid637850124 \listoverridecount0 \ls4 }{\listoverride \listid108668244 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls5
}{\listoverride \listid1026076958 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls6 }{\listoverride \listid981747696 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls7
}{\listoverride \listid1116666771 \listoverridecount1 {\lfolevel \listoverridestartat \levelstartat1 \nisuslistsoftoverridestartat }\ls8 }{\listoverride \listid958829064 \listoverridecount0 \ls9 }{\listoverride \listid322791560 \listoverridecount0 \ls10 }{\listoverride \listid108668244 \listoverridecount0 \ls11 }{\listoverride \listid614056598 \listoverridecount0 \ls12 }{\listoverride \listid1790318751 \listoverridecount0 \ls13 }{\listoverride \listid1493869940 \listoverridecount0 \ls14 }{\listoverride \listid1240764503 \listoverridecount0 \ls15 }{\listoverride \listid1116666771 \listoverridecount0 \ls16 }{\listoverride \listid1462789551 \listoverridecount0 \ls17 }{\listoverride \listid981747696 \listoverridecount0 \ls18 }{\listoverride \listid1026076958 \listoverridecount0 \ls19 }{\listoverride \listid711192801 \listoverridecount0 \ls20 }}\defformat {\info {\*\nisusgmtoffset -5:00}{\author  }{\creatim \yr2014 \mo2 \dy16 \hr19 \min49 }{\revtim \yr2014 \mo2 \dy16 \hr20 \min3 }{\printim \yr2014 \mo2 \dy16 \hr20 \min3 }}{\*\userprops }\viewkind1
\viewzk1 \nisusviewruler1 \nisusviewrulerh1 \nisusviewrulerv0 \nisusviewtoolbar1 \nisusviewtooldrawer1 \nisusviewpagenumtype1 \nisusviewrulericons0 {\*\nisusviewsettings \viewkind4 \viewscale125 }{\*\nisusviewsettings \viewkind1 \viewzk1 {\nisusnavsettings {\*\mode toc}{\*\closedtochandles }{\*\visible 0}}}{\*\nisuswindow \x299 \y120 \w840 \h720 }\nisusrulerunits0
\nshwinv1 \nshwpg1 \nisusinlinespell1 \hyphauto0 \hyphhotz10800 \nisusselectstart0 \nisusselectlength0 \ftnstart1 \ftnnar \aftnstart1 \aftnnar \aenddoc \fet2 \ftnbj \paperw12240 \paperh15840 \margl720 \margr720 \margt720 \margb720 \gutter0 \pgnstart1 \nocolbal \widowctrl \f0 \sectd \endnhere \sftnnar \saftnnar \linemod0 \cols1 \ltrsect \colbalsxn0 \pgwsxn12240 \pghsxn15840 \marglsxn720 \margrsxn720 \margtsxn720 \margbsxn720 \guttersxn0 \headery320 \footery320 \pgnstarts1 \pgnrestart \pgndec \sxnstarts1 \sxnrestart \sxndec {\header \plain \pard \s821 \f0\fs24 }{\footer \plain \pard \s823 \f0\fs24 }\deftab720
{\pard \nisusnos \nowidctlpar {\f1\fs48 \nisusselectcaret Senthil Kumaran, Python Design}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This is page describing various aspects of CPython Design. It is derived from Documents written by various authors who have researched on this topic, CPython Code and the PEPs. If you find anything lacking, please feel free to suggest the changes or corrections.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f2\fs36\b Python Internals}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This is a single page, python design notes from Yaniv Aknin\rquote s }}{\field {\*\fldinst HYPERLINK "http://tech.blog.aknin.name/category/my-projects/pythons-innards/"}{\fldrslt {\pard \nisusnos \nowidctlpar {\cs847 \f1\ul\ulc1\cf1 Python-Innards}}}}{\pard \nisusnos \nowidctlpar {\f1  Docs and other resources. I collected and wrote them so that I can understand and grasp the design principles. The material is possibly augumented with other resources.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Overview}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Explains the Python\rquote s byte-code evaluation. For e.g, what happen\rquote s when you do\f0 \par
}}{\pard \nisusnos {\par
\tab \f1 python -c \ldblquote print(\lquote hello,world\rquote )\rdblquote \f0 \par
\par
}}{\pard \nisusnos \nowidctlpar {\f1 Python\rquote s binary is executed, the standard C library initialization happens and then the main function starts executing from \f3\fs20 ./Modules/python.c: main\f1\fs24 , which soon calls \f3\fs20 ./Modules/main.c: Py_Main\f1\fs24  and after some initialization stuff like parse arguments, see if environment variables should affect behaviour, assess the situation of the standard streams and act accordingly, etc, \f3\fs20 ./Python/pythonrun.c: Py_Initialize\f1\fs24  is called.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In many ways, \f3\fs20 Py_Initialize\f1\fs24  function is what \lquote builds\rquote  and assembles together the pieces needed to run the CPython machine and makes \lquote a process\rquote  into \lquote a process with a Python interpreter in it\rquote . Among other things, it creates two very important Python data-structures: the interpreter state and thread state. It also creates the built-in module sys and the module which hosts all builtins.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 It will execute a single string, since we invoked it with -c. To execute this single string, \f3\fs20 ./Python/pythonrun.c: PyRun_SimpleStringFlags\f1\fs24  is called. This function creates the \f3\fs20 __main__\f1\fs24  namespace \lquote where\rquote  our string will be executed. After the namespace is created, the string is executed in it. To do that, you must first transform the string into something that machine can work on.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The parser/compiler stage of \f3\fs20 PyRun_SimpleStringFlags\f1\fs24  goes largely like this: tokenize and create a Concrete Syntax Tree (CST) from the code, transform the CST into an Abstract Syntax Tree (AST) and finally compile the AST into a code object using \f3\fs20 ./Python/ast.c: PyAST_FromNode\f1\fs24 . The code object as a binary string of machine code that Python VM\rquote s \lquote machinary\rquote  can operate on \endash  so now we\rquote re ready to do interpretation (again, evaluation in Python\rquote s parlance).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We have an empty \f3\fs20 __main__\f1\fs24 , we have a code object, we want to evaluate it. Now what? Now this line: \f3\fs20 Python/pythonrun.c: run_mod, v = PyEval_EvalCode(co, globals, locals);\f1\fs24  does the trick. It receives a code object and a namespace for globals and for locals (in this case, both of them will be the newly created \f3\fs20 __main__\f1\fs24  namespace), creates a frame object from these and executes it.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We know that \f3\fs20 Py_Initialize\f1\fs24  creates a thread state. Get back to that, each Python thread is represented by its own thread state, which among other things points to the stack of currently executing frames. After the frame object is created and placed at the top of the thread state stack, the byte code pointed by it is evaluated, opcode by opcode, by means of the \f3\fs20 ./Python/ceval.c: PyEval_EvalFrameEx\f1\fs24 . \f3\fs20 PyEval_EvalFrameEx\f1\fs24  function takes the frame, extracts opcode after opcode, and corresponding operands, if any and executes a short piece of C code matching the opcode.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Opcode looks like this.:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> from dis import dis\par
>>> co = compile("spam = eggs - 1", "<string>", "exec")\par
>>> dis(co)\par
  1           0 LOAD_NAME                0 (eggs)\par
              3 LOAD_CONST               0 (1)\par
              6 BINARY_SUBTRACT\par
              7 STORE_NAME               1 (spam)\par
             10 LOAD_CONST               1 (None)\par
             13 RETURN_VALUE\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 You \ldblquote load\rdblquote  the name eggs (where do you load it from? where do you load it to?), and also load a constant value (1), then you do a \f3\fs20 \ldblquote binary subtract\rdblquote \f1\fs24  (what do you mean \lquote binary\rquote  in this context? between which operands?), and so on and so forth. The names are \ldblquote loaded\rdblquote  from the globals and locals namespaces we\rquote ve seen earlier, and they\rquote re loaded onto an operand stack (not to be confused with the stack of running frames), which is exactly where the binary subtract will pop them from, subtract one from the other, and put the result back on that stack.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Look at \f3\fs20 PyEval_EvalFrameEx at ./Python/ceval.c\f1\fs24 . The following piece of code is run when BINARY_SUBTRACT opcode is found.:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 TARGET(BINARY_SUBTRACT)\par
    w = POP();\par
    v = TOP();\par
    x = PyNumber_Subtract(v, w);\par
    Py_DECREF(v);\par
    Py_DECREF(w);\par
    SET_TOP(x);\par
    if (x != NULL) DISPATCH();\par
    break;\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 After the frame is executed and \f3\fs20 PyRun_SimpleStringFlags\f1\fs24  returns, the main function does some cleanup (notably, \f3\fs20 Py_Finalize\f1\fs24 ), the standard C library deinitialization stuff is done (\f3\fs20 atexit\f1\fs24 ), and the process exits.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Python Objects}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Objects are fundamental to the innards of python and Objects are not very tightly coupled with anything else in Python. Look at the implementation of objects as if they\rquote re unrelated to the \lquote rest\rquote , as if they\rquote re a general purpose C API for creating an object subsystem. Objects are just a bunch of structures and some functions to manipulate them.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Mostly everything in Python is an object, from integer to dictionaries, from user defined classes to built-in ones, from stack frames to code objects.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Given a pointer to a piece of memory, the very least you must expect of it to treat it as an object are just a couple of fields defined in a C structure called \f3\fs20 ./Objects/object.h: PyObject.\f1\fs24 :\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 typedef struct _object \{\par
    Py_ssize_t ob_refcnt;\par
    struct _typeobject *ob_type;\par
\} PyObject;\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Many objects extend this structure to accommodate other variables required to represent the object\rquote s value, but these two fields must always exist: a reference count and type (in special debug builds, a couple other esoteric fields are added to track references).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The reference count is an integer which counts how many times the object is referenced. \f3\fs20 >>> a = b = c = object()\f1\fs24  instantiates an empty object and binds it to three different names: a, b and c. Each of these names creates another reference to it even though the object is allocated only once. Binding the object to yet another name or adding the object to a list will create another reference \endash  but will not create another object!\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 There is much more to say about reference counting, but that\rquote s less central to the overall object system and more related to Garbage Collection.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We can now better understand the \f3\fs20 ./Objects/object.h: Py_DECREF\f1\fs24  macro we\rquote ve seen used in the introduction and didn\rquote t know how to explain: It simply decrements \f3\fs20 ob_refcnt\f1\fs24  (and initiates deallocation, if \f3\fs20 ob_refcnt\f1\fs24  hit zero). That\rquote s all we\rquote ll say about reference counting for now.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f3\fs20 ob_type\f1\fs24 , a pointer to an object\rquote s type, a central piece of Python\rquote s object model. Every object has exactly one type, which never changes during the lifetime of the object. Most importantly, the type of an object (and only the type of an object) determines what can be done with an object.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 When the interpreter evaluates the subtraction opcode, a single C function \f3\fs20 (PyNumber_Subtract)\f1\fs24  will be called regardless of whether its operands are an integer and an integer, an integer and a float or even something nonsensical (subtract an exception from a dictionary).:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 # n2w: the type, not the instance, determines what can be done with an instance\par
>>> class Foo(object):\par
...     "I don't have __call__, so I can't be called"\par
...\par
>>> class Bar(object):\par
...     __call__ = lambda *a, **kw: 42\par
...\par
>>> foo = Foo()\par
>>> bar = Bar()\par
>>> foo()\par
Traceback (most recent call last):\par
  File "<stdin>", line 1, in <module>\par
TypeError: 'Foo' object is not callable\par
>>> bar()\par
42\par
# will adding __call__ to foo help?\par
>>> foo.__call__ = lambda *a, **kw: 42\par
>>> foo()\par
Traceback (most recent call last):\par
  File "<stdin>", line 1, in <module>\par
TypeError: 'Foo' object is not callable\par
# how about adding it to Foo?\par
>>> Foo.__call__ = lambda *a, **kw: 42\par
>>> foo()\par
42\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 How can a single C function be used to handle any kind of object that is thrown at it? It can receive a \f3\fs20 void * pointer\f1\fs24  (actually it receives a \f3\fs20 PyObject *\f1\fs24  pointer, which is also opaque insofar as the object\rquote s data is concerned), but how will it know how to manipulate the object it is given? In the object\rquote s type lies the answer. A type is in itself a Python object (it also has a reference count and a type of its own, the type of almost all types is type), but in addition to the refcount and the type of the type, there are many more fields in the C structure describing type objects.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f3\fs20 ./Include/object.h: PyTypeObject\f1\fs24  has the information about types as well as type\rquote s structure\rquote s definition. Many of the fields a type object has are called slots and they point to functions (or to structures that point to a bunch of related functions). These functions are what will actually be called when Python C-API functions are invoked to operate on an object instantiated from that type. So while you think you\rquote re calling \f3\fs20 PyNumber_Subtract\f1\fs24  on both a, say, \f3\fs20 int and a float\f1\fs24 , in reality what happens is that the types of it operands are \f3\fs20 dereferenced\f1\fs24  and the type-specific subtraction function in the \lquote subtraction\rquote  slot is used. So we see that the C-API functions aren\rquote t generic, but rather rely on types to abstract the details away and appear as if they can work on anything (valid work is also just to raise a TypeError).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f3\fs20 PyNumber_Subtract\f1\fs24  calls a generic two-argument function called \f3\fs20 ./Object/abstract.c: binary_op\f1\fs24 , and tells it to operate on the number-like \f3\fs20 slot nb_subtract\f1\fs24  (similar slots exists for other functionality, like, say, the number-like slot \f3\fs20 nb_negative\f1\fs24  or the sequence-like slot \f3\fs20 sq_length\f1\fs24 ). \f3\fs20 binary_op\f1\fs24  is an error-checking wrapper around \f3\fs20 binary_op1\f1\fs24 , the real \lquote do work\rquote  function. \f3\fs20 ./Objects/abstract.c: binary_op1\f1\fs24  receives \f3\fs20 BINARY_SUBTRACT\lquote s\f1\fs24  operands as v and w, and then tries to dereference \f3\fs20 v->ob_type->tp_as_number\f1\fs24 , a structure pointing to many numeric slots which represents how v can be used as a number. \f3\fs20 binary_op1\f1\fs24  will expect to find at \f3\fs20 tp_as_number->nb_subtract\f1\fs24  a C function that will either do the subtraction or return the special value \f3\fs20 Py_NotImplemented\f1\fs24 , to signal that these operands are \lquote insubtracticable\rquote  in relation to one another (this will cause a TypeError exception to be raised).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 If you want to change how objects behave, you can write an extension in C which will statically define its own \f3\fs20 PyObjectType\f1\fs24  structure in code and fill the slots away as you see fit. But when we create our own types in Python ( class and type are the same thing), we don\rquote t manually allocate a C structure and we don\rquote t fill up its slots.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 How come these types behave just like built-in types? The answer is inheritance, where typing plays a significant role. See, Python arrives with some built-in types, like \f3\fs20 list or dict\f1\fs24 . As we said, these types have a certain set of functions populating their slots and thus objects instantiated from them behave in a certain way, like a mutable sequence of values or like a mapping of keys to values. When you define a new type in Python, a new C structure for that type is dynamically allocated on the \f3\fs20 heap\f1\fs24  (like any other object) and its slots are filled from whichever type it is inheriting, which is also called its base\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Since the slots are copied over, the newly created sub-type has mostly identical functionality to its base. Python also arrives with a featureless base object type called object (\f3\fs20 PyBaseObject_Type\f1\fs24  in C), which has mostly null slots and which you can extend without inheriting any particular functionality. You never really \lquote create\rquote  a type in pure Python, you always inherit one (if you define a class without inheriting anything explicitly, you will implicitly inherit object; in Python 2.x, not inheriting anything explicitly leads to the creation of a so called \lquote classic class\rquote , which is out of our scope).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Of course, you don\rquote t have to inherit everything. You can, obviously, mutate the behaviour of a type created in pure Python, as I\rquote ve demonstrated in the code snippet earlier in this post. By setting the special method \f3\fs20 __call__\f1\fs24  on our class Bar, I made instances of that class callable. Someone, sometime during the creation of our class, noticed this \f3\fs20 __call__\f1\fs24  method exists and wired it into our newly created type\rquote s \f3\fs20 tp_call\f1\fs24  slot. \f3\fs20 ./Objects/typeobject.c: type_new\f1\fs24 , an elaborate and central function, is that function.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Let\rquote s look at a small line right at the end after the new type has been fully created and just before returning \f3\fs20 fixup_slot_dispatchers(type);\f1\fs24 . This function iterates over the correctly named methods defined for the newly created type and wires them to the correct slots in the type\rquote s structure, based on their particular name.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Another thing remains unanswered in the sea of small details: we\rquote ve demonstrated already that setting the method \f3\fs20 __call__\f1\fs24  on a type after it\rquote s created will also make objects instantiated from that type callable (even objects already instantiated from that type). Recall that a type is an object, and that the type of a type is type (if your head is spinning, try: \f3\fs20 >>> class Foo(list): pass ; type(Foo)\f1\fs24 ).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 So when we do stuff to a class, like calling a class, or subtracting a class, or, indeed, setting an attribute on a class, what happens is that the \f3\fs20 class\rquote  object\rquote s ob_type\f1\fs24  member is dereferenced, finding that the class\rquote  type is type. Then the \f3\fs20 type->tp_setattro\f1\fs24  slot is used to do the actual attribute setting. So a class, like an integer or a list can have its own attribute-setting function. And the type-specific attribute-setting function (\f3\fs20 ./Objects/typeobject.c: type_setattro\f1\fs24 ) calls the very same function that \f3\fs20 fixup_slot_dispatchers\f1\fs24  uses to actually do the fixup work (update_one_slot) after it has set a new attribute on a class.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 What is happening here?:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> a = object()\par
>>> class C(object): pass\par
...\par
>>> b = C()\par
>>> a.foo = 5\par
Traceback (most recent call last):\par
  File "<stdin>", line 1, in <module>\par
AttributeError: 'object' object has no attribute 'foo'\par
>>> b.foo = 5\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 How I can set an arbitrary attribute to b, which is an instance of C, which is a class inheriting object and not changing anything, and yet I can\rquote t do the same with a, an instance of that very same object? Some wise crackers can say: b has a \f3\fs20 __dict__\f1\fs24  and a doesn\rquote t, and that\rquote s true, but how did this new (and totally non-trivial!) functionality come from if I didn\rquote t inherit it?!\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Attributes of an object}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 An object\rquote s attributes are other objects related to it and accessible by invoking the . (dot) operator, like so: \f3\fs20 >>> my_object.attribute_name\f1\fs24 . A type can define one (or more) specially named methods that will customize attribute access to its instances and they will be wired into the type\rquote s slots using \f3\fs20 fixup_slot_dispatchers\f1\fs24  when the type is created.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 These methods simply store the attribute as a key/value pair (attribute name/attribute value) in some object-specific dictionary when an attribute is set and retrieve the attribute from that dictionary when an attribute is get (or raise an AttributeError if the dictionary doesn\rquote t have a key matching the requested attribute\rquote s name).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Here is an example snippet which presents a particularly surprising behavior of attribute access.:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> print(object.__dict__)\par
\{'__ne__': <slot wrapper '__ne__' of 'object' objects>, ... ,\par
'__ge__': <slot wrapper '__ge__' of 'object' objects>\}\par
>>> object.__ne__ is object.__dict__['__ne__']\par
True\par
>>> o = object()\par
>>> o.__class__\par
<class 'object'>\par
>>> o.a = 1\par
Traceback (most recent call last):\par
  File "<stdin>", line 1, in <module>\par
AttributeError: 'object' object has no attribute 'a'\par
>>> o.__dict__\par
Traceback (most recent call last):\par
  File "<stdin>", line 1, in <module>\par
AttributeError: 'object' object has no attribute '__dict__'\par
>>> class C:\par
...     A = 1\par
...\par
>>> C.__dict__['A']\par
1\par
>>> C.A\par
1\par
>>> o2 = C()\par
>>> o2.a = 1\par
>>> o2.__dict__\par
\{'a': 1\}\par
>>> o2.__dict__['a2'] = 2\par
>>> o2.a2\par
2\par
>>> C.__dict__['A2'] = 2\par
Traceback (most recent call last):\par
  File "<stdin>", line 1, in <module>\par
TypeError: 'dict_proxy' object does not support item assignment\par
>>> C.A2 = 2\par
>>> C.__dict__['A2'] is C.A2\par
True\par
>>> type(C.__dict__) is type(o2.__dict__)\par
False\par
>>> type(C.__dict__)\par
<class 'dict_proxy'>\par
>>> type(o2.__dict__)\par
<class 'dict'>\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We can see that object (as in, the most basic built-in type which we\rquote ve discussed before) has a private dictionary, and we see that stuff we access on object as an attribute is identical to what we find in \f3\fs20 object.__dict__\f1\fs24 . Instances of object (o, in the example) don\rquote t support arbitrary attribute assignment and don\rquote t have a \f3\fs20 __dict__\f1\fs24  at all, though they do support some attribute access (try \f3\fs20 o.__class__, o.__hash__\f1\fs24 , etc; these do return things).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 After that we created our own class, C, derived from object and adding an attribute A, and saw that A was accessible via \f3\fs20 C.A\f1\fs24  and \f3\fs20 C.__dict__['A']\f1\fs24  just the same, as expected.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We then instantiated o2 from C, and demonstrated that as expected, attribute assignment on it indeed mutates its \f3\fs20 __dict__\f1\fs24  and vice versa (i.e., mutations to its \f3\fs20 __dict__\f1\fs24  are exposed as attributes). We were then probably more surprised to learn that even though attribute assignment on the class (C.A2) worked fine, our class\rquote  \f3\fs20 __dict__\f1\fs24  is actually read-only. Finally, we saw that our \f3\fs20 class __dict__\f1\fs24  is not of the same type as our object\rquote s \f3\fs20 __dict__\f1\fs24 , but rather an unfamiliar beast called dict_proxy. And if all that wasn\rquote t enough, recall the mystery from the end of Objects 101: if plain object instances like o have no \f3\fs20 __dict__\f1\fs24 , and C extends object without adding anything significant, why do instances of C like o2 suddenly do have a \f3\fs20 __dict__\f1\fs24 ?\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 First, we shall look at the implementation of a \f3\fs20 type\rquote s __dict__\f1\fs24 . Looking at the definition of \f3\fs20 PyObjectType\f1\fs24  (a zesty and highly recommended exercise), we see a slot called \f3\fs20 tp_dict\f1\fs24 , ready to accept a pointer to a dictionary. All types must have this slot, and all types have a dictionary placed there when \f3\fs20 ./Objects/typeobject.c: PyType_Ready\f1\fs24  is called on them, either when the interpreter is first initialized (remember \f3\fs20 Py_Initialize\f1\fs24 ? It invokes \f3\fs20 _Py_ReadyTypes\f1\fs24  which calls \f3\fs20 PyType_Ready\f1\fs24  on all known types) or when the type is created dynamically by the user (\f3\fs20 type_new\f1\fs24  calls \f3\fs20 PyType_Ready\f1\fs24  on the newborn type before returning).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In fact, every name you bind within a class statement will turn up in the newly created type\rquote s \f3\fs20 __dict__\f1\fs24  (see \f3\fs20 ./Objects/typeobject.c: type_new: type->tp_dict = dict = PyDict_Copy(dict);\f1\fs24 ). These functions use the dictionary each type has and pointed to by \f3\fs20 tp_dict\f1\fs24  to store/retrieve the attributes, that is, getting attributes on a type is directly wired to dictionary assignment for the type instance\rquote s private dictionary pointed to by the type\rquote s structure. So far I hope it\rquote s been rather simple, and explains types\rquote  attribute retrieval.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Descriptors}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Descriptors play a special role in instances\rquote  attribute access. An object is said to be a descriptor if it\rquote s type has one or two slots (tp_descr_get and/or tp_descr_set) filled with non-NULL value. These slots are wired to the special method names \f3\fs20 __get__\f1\fs24 , \f3\fs20 __set__\f1\fs24  and \f3\fs20 __delete__\f1\fs24 , when the type is defined in pure Python (i.e., if you create a class which has a \f3\fs20 __get__\f1\fs24  method it will be wired to its tp_descr_get slot, and if you instantiate an object from that class, the object is a descriptor).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 An object is said to be a data descriptor if its type has a non-NULL tp_descr_set slot (there\rquote s no particularly special term for a non-data descriptor). We\rquote ve defined descriptors, and we know how types\rquote  dictionaries and attribute access work. Most objects aren\rquote t types, that is to say, their type isn\rquote t type, it\rquote s something more mundane like int or dict or a user defined class. All these rely on generic attribute access functions, which are either set on the type explicitly or inherited from the type\rquote s base when the type is created.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The generic attribute-getting function (\f3\fs20 PyObject_GenericGetAttr\f1\fs24 ) and its algorithm is like so:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 (a) Search the accessed instance\rquote s type\rquote s dictionary, and then all the type\rquote s bases\rquote  dictionaries. If a data descriptor was found, invoke it\rquote s \f3\fs20 tp_desr_get\f1\fs24  function and return the results. If something else is found, set it aside (we\rquote ll call it X).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\tx220 {\f1 (b) Now search the object\rquote s dictionary, and if something is found, return it.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 (c) If nothing was found in the object\rquote s dictionary, inspect X, if one was set aside at all; if X is a non-data descriptor, invoke it\rquote s \f3\fs20 tp_descr_get\f1\fs24  function and return the result, and if it\rquote s a plain object it returns it.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\tx220 {\f1 (d) Finally, if nothing was found, it raise an \f3\fs20 AttributeError\f1\fs24  exception.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 So we learn that descriptors can execute code when they\rquote re accessed as an attribute (so when you do \f3\fs20 foo = o.a or o.a = foo\f1\fs24 , a runs code). A powerful notion, that, and it\rquote s used in several cases to implement some of Python\rquote s more \lquote magical\rquote  features.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Data-descriptors are even more powerful, as they take precedence over instance attributes (if you have an \f3\fs20 object o of class C\f1\fs24 , class C has a foo data-descriptor and o has a foo instance attribute, when you do o.foo the descriptor will take precedence).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 While descriptors are really important and you\rquote re advised to take the time to understand them, for brevity and due to the well written resources I\rquote ve just mentioned I will explain them no further, other than show you how they behave in the interpreter (super simple example!):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> class ShoutingInteger(int):\par
...     # __get__ implements the tp_descr_get slot\par
...     def __get__(self, instance, owner):\par
...             print('I was gotten from %s (instance of %s)'\par
...                   % (instance, owner))\par
...             return self\par
...\par
>>> class Foo:\par
...     Shouting42 = ShoutingInteger(42)\par
...\par
>>> foo = Foo()\par
>>> 100 - foo.Shouting42\par
I was gotten from <__main__.Foo object at 0xb7583c8c> (instance of <class __main__.'foo'>)\par
58\par
# Remember: descriptors are only searched on types!\par
>>> foo.Silent666 = ShoutingInteger(666)\par
>>> 100 - foo.Silent666\par
-566\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We now understand that accessing attribute A on object O instantiated from class C1 which inherits C2 which inherits C3 can return A either from O, C1, C2 or C3, depending on something called the \f3\fs20 method resolution order\f1\fs24 . This way of resolving attributes, when coupled with slot inheritance, is enough to explain most of Python\rquote s inheritance functionality.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We\rquote ve seen the definition of \f3\fs20 PyObject\f1\fs24 , and it most definitely didn\rquote t have a pointer to a dictionary, so where is the reference the object\rquote s dictionary stored? If you look closely at the definition of \f3\fs20 PyTypeObject\f1\fs24 , you will see a field called \f3\fs20 tp_dictoffset\f1\fs24 . This field provides a byte offset into the C-structure allocated for objects instantiated from this type; at this offset, a pointer to a regular Python dictionary should be found.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Under normal circumstances, when creating a new type, the size of the memory region necessary to allocate objects of that type will be calculated, and that size will be larger than the size of vanilla \f3\fs20 PyObject\f1\fs24 . The extra room will typically be used (among other things) to store the pointer to the dictionary (all this happens in \f3\fs20 ./Objects/typeobject.c\f1\fs24  : \f3\fs20 type_new, see may_add_dict = base->tp_dictoffset == 0\f1\fs24 ; onwards).:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> class C: pass\par
...\par
>>> o = C()\par
>>> o.foo = 'bar'\par
>>> o\par
<__main__.C object at 0x846b06c>\par
>>>\par
# break into GDB, see 'metablogging'->'tools' above\par
Program received signal SIGTRAP, Trace/breakpoint trap.\par
0x0012d422 in __kernel_vsyscall ()\par
(gdb) p ((PyObject *)(0x846b06c))->ob_type->tp_dictoffset\par
$1 = 16\par
(gdb) p *((PyObject **)(((char *)0x846b06c)+16))\par
$3 = \{u'foo': u'bar'\}\par
(gdb)\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We have created a new class, instantiated an object from it and set some attribute on the object (o.foo = \lquote bar\rquote ), broke into gdb, dereferenced the object\rquote s type (C) and checked its \f3\fs20 tp_dictoffset\f1\fs24  (it was 16), and then checked what\rquote s to be found at the address pointed to by the pointer located at 16 bytes\rquote  offset from the object\rquote s C-structure, and indeed we found there a dictionary object with the key foo pointing to the value bar.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Of course, if you check \f3\fs20 tp_dictoffset\f1\fs24  on a type which doesn\rquote t have a \f3\fs20 __dict__\f1\fs24 , like object, you will find that it is zero. I define a class C inheriting object and doing nothing much else in Python, and then I instantiate o from that class, causing the extra memory for the dictionary pointer to be allocated at \f3\fs20 tp_dictoffset\f1\fs24 .\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 I then type in my interpreter \f3\fs20 o.__dict__\f1\fs24 , which byte-compiles to the \f3\fs20 LOAD_ATTR\f1\fs24  opcode, which causes the \f3\fs20 PyObject_GetAttr\f1\fs24  function to be called, which dereferences the type of o and finds the \f3\fs20 slot tp_getattro\f1\fs24 , which causes the default attribute searching mechanism described earlier in this post and implemented in \f3\fs20 PyObject_GenericGetAttr\f1\fs24 .\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 So when all that happens, what returns my object\rquote s dictionary? I know where the dictionary is stored, but I can see that \f3\fs20 __dict__\f1\fs24  isn\rquote t recursively inside itself, so there\rquote s a chicken and egg problem here; who gives me my dictionary when I access \f3\fs20 __dict__\f1\fs24  if it is not in my dictionary?\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Someone who has precedence over the object\rquote s dictionary \endash  a descriptor. Check this out:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> class C: pass\par
...\par
>>> o = C()\par
>>> o.__dict__\par
\{\}\par
>>> C.__dict__['__dict__']\par
<attribute '__dict__' of 'C' objects>\par
>>> type(C.__dict__['__dict__'])\par
<class 'getset_descriptor'>\par
>>> C.__dict__['__dict__'].__get__(o, C)\par
\{\}\par
>>> C.__dict__['__dict__'].__get__(o, C) is o.__dict__\par
True\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Seems like there\rquote s something called \f3\fs20 getset_descriptor\f1\fs24  (it\rquote s in \f3\fs20 ./Objects/typeobject.c\f1\fs24 ), which are groups of functions implementing the descriptor protocol and meant to be attached to an object placed in type\rquote s \f3\fs20 __dict__\f1\fs24 .\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This descriptor will intercept all attribute access to \f3\fs20 o.__dict__\f1\fs24  on instances of this type, and will return whatever it wants, in our case, a reference to the dictionary found at the \f3\fs20 tp_dictoffset\f1\fs24  of o.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This is also the explanation of the dict_proxy business we\rquote ve seen earlier. If in \f3\fs20 tp_dict\f1\fs24  there\rquote s a pointer to a plain dictionary, what causes it to be returned wrapped in this read only proxy, and why? The \f3\fs20 __dict__\f1\fs24  descriptor of the type\rquote s type type does it.:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> type(C)\par
<class 'type'>\par
>>> type(C).__dict__['__dict__']\par
<attribute '__dict__' of 'type' objects>\par
>>> type(C).__dict__['__dict__'].__get__(C, type)\par
<dict_proxy object at 0xb767e494>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This descriptor is a function that wraps the dictionary in a simple object that mimics regular dictionaries\rquote  behaviour but only allows read only access to the dictionary it wraps. And why is it so important to prevent people from messing with a \f3\fs20 type\rquote s __dict__\f1\fs24 ? Because a type\rquote s namespace might hold them specially named methods, like \f3\fs20 __sub__\f1\fs24 .\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 When you create a type with these specially named methods or when you set them on the type as an attribute, the function \f3\fs20 update_one_slot\f1\fs24  will patch these methods into one of the type\rquote s slots, as we\rquote ve seen in 101 for the subtraction operation. If you were to add these methods straight into the type\rquote s \f3\fs20 __dict__\f1\fs24 , they won\rquote t be wired to any slot, and you\rquote ll have a type that looks like it has a certain behaviour (say, has \f3\fs20 __sub__\f1\fs24  in its dictionary), but doesn\rquote t behave that way. \f3\fs20 __slots__\f1\fs24  are important construct when dealing with attributes access.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 descriptors are objects whose type has their tp_descr_get and/or tp_descr_set slots set to non-NULL. However, I also wrote, incorrectly, that descriptors take precedence over regular instance attributes (i.e., attributes in the object\rquote s \f3\fs20 __dict__\f1\fs24 ). This is partly correct but misleading, as it doesn\rquote t distinguish non-data descriptors from data-descriptors. An object is said to be a data descriptor if its type has its tp_descr_set slot implemented (there\rquote s no particularly special term for a non-data descriptor). Only data descriptors override regular object attributes, non-data descriptors do not.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Interpreter Threads}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Look into the Interpreter State and the Thread State structures both implemented in ./Python/pystate.c In many operating systems user-space code is executed by an abstraction called threads that run inside another abstraction called processes. The kernel is in charge of setting up and tearing down these processes and execution threads, as well as deciding which thread will run on which logical CPU at any given time.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 When a process invokes Py_Initialize another abstraction comes into play, and that is the interpreter. Any Python code that runs in a process is tied to an interpreter, you can think of the interpreter as the root of all other concepts we\rquote ll discuss. Python\rquote s code base supports initializing two (or more) completely separate interpreters that share little state with one another. This is rather rarely done (never in the vanilla executable), because too much subtly shared state of the interpreter core and of C extensions exists between these \lquote insulated\rquote  interpreters.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Anyhow, we said all execution of code occurs in a thread (or threads), and Python\rquote s Virtual Machine is no exception. However, Python\rquote s Virtual Machine itself is something which supports the notion of threading, so Python has its own abstraction to represent Python threads. This abstraction\rquote s implementation is fully reliant on the kernel\rquote s threading mechanisms, so both the kernel and Python are aware of each Python thread and Python threads execute as separate kernel-managed threads, running in parallel with all other threads in the system. Uhm, almost.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Many aspects of Python\rquote s CPython implementation are not thread safe. This is has some benefits, like simplifying the implementation of easy-to-screw-up pieces of code and guaranteed atomicity of many Python operations, but it also means that a mechanism must be put in place to prevent two (or more) Pythonic The GIL is a process-wide lock which must be held by a thread if it wants to do anything Pythonic \endash  effectively limiting all such work to a single thread running on a single logical CPU at a time. Threads in Python multitask cooperatively by relinquishing the GIL voluntarily so other threads can do Pythonic work; this cooperation is built-in to the evaluation loop, so ordinarily authors of Python code and some extensions don\rquote t need to do something special to make cooperation work (from their point of view, they are preempted).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Do note that while a thread doesn\rquote t use any of Python\rquote s APIs it can (and many threads do) run in parallel to another Pythonic thread. With the concepts of a process (OS abstraction), interpreter(s) (Python abstraction) and threads (an OS abstraction and a Python abstraction) in mind, let\rquote s go inside-out by zooming out from a single opcode outwards to the whole process.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Let\rquote s look again at the disassembly of the bytecode generated for the simple statement \f3\fs20 spam = eggs - 1\f1\fs24 :\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 # uses 'diss'? tool.\par
>>> diss("spam = eggs - 1")\par
  1           0 LOAD_NAME                0 (eggs)\par
              3 LOAD_CONST               0 (1)\par
              6 BINARY_SUBTRACT\par
              7 STORE_NAME               1 (spam)\par
             10 LOAD_CONST               1 (None)\par
             13 RETURN_VALUE\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In addition to the actual \lquote do work\rquote  opcode BINARY_SUBTRACT, we see opcodes like LOAD_NAME (eggs) and STORE_NAME (spam). It seems obvious that evaluating such opcodes requires some storage room: eggs has to be loaded from somewhere, spam has to be stored somewhere.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The inner-most data structures in which evaluation occurs are the frame object and the code object, and they point to this storage room. When you\rquote re \ldblquote running\rdblquote  Python code, you\rquote re actually evaluating frames (recall \f3\fs20 ceval.c: PyEval_EvalFrameEx\f1\fs24 ).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In this code-structure-oriented post, the main thing we care about is the \f3\fs20 f_back\f1\fs24  field of the frame object (though many others exist). In \f3\fs20 frame n\f1\fs24  this field points to frame n-1, i.e., the frame that called us (the first frame that was called in any particular thread, the top frame, points to NULL). This stack of frames is unique to every thread and is anchored to the thread-specific structure \f3\fs20 ./Include.h/pystate.h: PyThreadState\f1\fs24 , which includes a pointer to the currently executing frame in that thread (the most recently called frame, the bottom of the stack).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 PyThreadState is allocated and initialized for every Python thread in a process by \f3\fs20 _PyThreadState_Prealloc\f1\fs24  just before new thread creation is actually requested from the underlying OS (see \f3\fs20 ./Modules/_threadmodule.c: thread_PyThread_start_new_thread\f1\fs24  and \f3\fs20 >>> from _thread import start_new_thread\f1\fs24 ). Threads can be created which will not be under the interpreter\rquote s control; these threads won\rquote t have a \f3\fs20 PyThreadState\f1\fs24  structure and must never call a Python API. This isn\rquote t so common in a Python application but is more common when Python is embedded into another application. It is possible to \lquote Pythonize\rquote  such foreign threads that weren\rquote t originally created by Python code in order to allow them to run Python code (PyThreadState will have to be allocated for them). Finally, a bit like all frames are tied together in a backward-going stack of previous-frame pointers, so are all thread states tied together in a linked list of \f3\fs20 PyThreadState *next\f1\fs24  pointers.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The list of thread states is anchored to the interpreter state structure which owns these threads. The interpreter state structure is defined at \f3\fs20 ./Include.h/pystate.h: PyInterpreterState\f1\fs24 , and it is created when you call \f3\fs20 Py_Initialize\f1\fs24  to initialize the Python VM in a process or \f3\fs20 Py_NewInterpreter\f1\fs24  to create a new interpreter state for multi-interpreter processes. Note carefully that \f3\fs20 Py_NewInterpreter\f1\fs24  does not return an interpreter state \endash  it returns a (newly created) \f3\fs20 PyThreadState\f1\fs24  for the single automatically created thread of the newly created interpreter.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 There\rquote s no sense in creating a new interpreter state without at least one thread in it, much like there\rquote s no sense in creating a new process with no threads in it.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Similarly to the list of threads anchored to its interpreter, so does the interpreter structure have a next field which forms a list by linking the interpreters to one another.This pretty much sums up our zooming out from the resolution of a single opcode to the whole process: opcodes belong to currently evaluating code objects (currently evaluating is specified as opposed to code objects which are just lying around as data, waiting for the opportunity to be called), which belong to currently evaluating frames, which belong to Pythonic threads, which belong to interpreters. The anchor which holds the root of this structure is the static variable \f3\fs20 ./Python/pystate.c: interp_head\f1\fs24 , which points to the first interpreter state (through that all interpreters are reachable, through each of them all thread states are reachable, and so fourth).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The mutex \f3\fs20 head_mutex\f1\fs24  protects \f3\fs20 interp_head\f1\fs24  and the lists it points to so they won\rquote t be corrupt by concurrent modifications from multiple threads (I want it to be clear that this lock is not the GIL, it\rquote s just the mutex for interpreter and thread states). The macros \f3\fs20 HEAD_LOCK\f1\fs24  and \f3\fs20 HEAD_UNLOCK\f1\fs24  control this lock. \f3\fs20 interp_head\f1\fs24  is typically used when one wishes to add/remove interpreters or threads and for special purposes. That\rquote s because accessing an interpreter or a thread through the head variable would get you an interpreter state rather than the interpreter state owning the currently running thread (just in case there\rquote s more than one interpreter state).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A more useful variable similar to interp_head is \f3\fs20 ./Python/pystate.c: _PyThreadState_Current\f1\fs24  which points to the currently running thread state This is how code typically accesses the correct interpreter state for itself: first find its your own thread\rquote s thread state, then dereference its interp field to get to your interpreter.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 There are a couple of functions that let you access this variable (get its current value or swap it with a new one while retaining the old one) and they require that you hold the GIL to be used. This is important, and serves as an example of CPython\rquote s lack of thread safety (a rather simple one, others are hairier). If two threads are running and there was no GIL, to which thread would this variable point? \ldblquote The thread that holds the GIL\rdblquote  is an easy answer, and indeed, the one that\rquote s used. \f3\fs20 _PyThreadState_Current\f1\fs24  is set during Python\rquote s initialization or during a new thread\rquote s creation to the thread state structure that was just created. When a Pythonic thread is bootstrapped and starts running for the very first time it can assume two things:\f0 \par
}}{\pard \nisusnos {\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls1\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 It holds the GIL and\f0 \par
}}{\pard \nisusnos {\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls2\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 It will find a correct value in _PyThreadState_Current.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As of that moment the Pythonic thread should not relinquish the GIL and let other threads run without first storing \f3\fs20 _PyThreadState_Current\f1\fs24  somewhere, and should immediately re-acquire the GIL and restore \f3\fs20 _PyThreadState_Current\f1\fs24  to its old value when it wants to resume running Pythonic code. This behaviour is what keeps \f3\fs20 _PyThreadState_Current\f1\fs24  correct for GIL-holding threads and is so common that macros exist to do the save-release/acquire-restore idioms (\f3\fs20 Py_BEGIN_ALLOW_THREADS\f1\fs24  and \f3\fs20 Py_END_ALLOW_THREADS\f1\fs24 ). There\rquote s much more to say about the GIL and additional APIs to handle it and it\rquote s probably also interesting to contrast it with other Python implementation (Jython and IronPython are thread safe and do run Pythonic threads concurrently).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Diagram shows the relation between the state structures within a single process hosting Python as described so far. We have in this example two interpreters with two threads each, you can see each of these threads points to its own call stack of frames.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 {\*\shppict {\pict {\*\nisusfilename states4.png}\picw440
\pich315 \picwgoal8800 \pichgoal6300 {\*\picprop {\sp {\sn fillOpacity}{\sv 65536}}}{\sp {\sn fShadow}{\sv 0}}{\*\nisuspicprops {\sp {\sn dxWrapDistLeft}{\sv 0}}{\sp {\sn dyWrapDistTop}{\sv 0}}{\sp {\sn dxWrapDistRight}{\sv 0}}{\sp {\sn dyWrapDistBottom}{\sv 0}}}\pngblip
89504e470d0a1a0a0000000d49484452000001b80000013b0802000000208c0392000000097048597300000b1200000b1201d2dd7efc000076074944415478daed9d05781b57bafebb77efc2dd7b17eedefdef76b75ba62d37c5246d430d33333333b3182db0c5065996995926c916da962d2b8c4d430d149236d4240decff95c7511d536cc79665f9bcfe1e3f3367ce9c19cd8c7e7abf33f444091111111151937a826c0222222222024a22222222024a22222222024a22222222024a22222222024a22222222024a22222222024a22222222024a2222222222024a22222222024a222222a28e06a5d96236db3a4958cd64ef3ebe4c66abc96c23d11e515c622107580082d25a69755d77b96fbb1155b7aba8015f468b168aca6527ca4a082d1f4399a5c7f555b7f5ee664433abf94f5475fc42635d570b2de5e4300b285082925537abf6fc7b4f678afb7b082b1f8792ba3df722f7fc9b44fb458ceb066165e080d25ad109294958f9b894bc4f40e61b561611560600283b31256bb3928850d2af59490ed14e0ecafa942cbb51b641bca13130957c5b62fbc1d6268c9bb7651e3b9addd2b90abe2ae83bbaaff1a2b1362b6d6e1bd9d9cd519ecd1df9284ab2520eccdd1d8e58273784396fd5991a6cfa9a9a8a58c4896126ef7ffbd3a18f4f9355d2cccf272df30cbbefb3d30ead94a4e33f35899f7da2891983f24e8757de69e65242cb6f6ed41837698c9cf4c35a771bf73cc8cd971496cb0d4e8a735d21c75ee706a5fbaebb0e89dcf7dd40cfcfc30ffe53b1337467706670ed124fe5fbf5e6bddff0ecb523b63276297d699da9b597def0bcf7f74c5b352df7646eed42fb7e3bd9d9cd51aefdc023bff082ec132fbcf5f12a4906503862fe560f58dd356cd5baef6fd7393e1931b3fbe0295337885f79ef3314bed7671405b8072d78ebff4c64adfb213ad719a5ea53eda0fd518b762ee527fce385d7a9a9ddfa8caaae5fbf7d4ff419b7506abc50bba46ee30f4265bfda73f88cc59cd825bcf8279f7d4553f6e3cfeb490dfcbc9407a34d7c909f67a999b488158dd56e70e9d15537c9b11750a08cad88fd6cd867c3670ca74631f071ff8f874d1f367dcdf49c2f739cb79c3d07f57cbbfbdbf074b9a73ca862e818a3e68c42ec0adb55fe63f9c8d9237b0ce8b170c7c2fee3fa871687bef8c68b03c60f183265c8a29d8b6054eb83f2bd5eef8d983562eacaa96987d2c0c44dc19b86cd18366ee13861b2104014240a064f193c69d9247d991ef5b556edd80563b1ac675f799680b2fd40e965163c57cf61d3a76f0a7eb3e7208f77339cfae7cb6f2d0f4ad9146a1abd78372dbe6a3e5deb0159ef118367aeeb3174da8cadf288aabba317ef02e3a6ac17814aa02d1ce8f0795bdfef3766d0f435dc8ca3ead2ebe357b03fe83f6ed89c4d2afb15cc3e63b30cf3f61e3bff956e9f62744550ca88f9dbe0ce44796730ba5c98fcc7bffcfdbdbea3a76f0ec1282ff358ffc9cb416a6a545278ee6fcfbcfcd627433e1b3547e5b8cacb3a3e74f6062c6bc8ccf5c1c68b753e145a5e2bcba18631e3527ee2eb1f7d8ee1314b68cfbcfaaea6ec063e2c9a1ab970fbfb9f8fe5677f3174f646944f5ccdc7ea6d50158af2cf0c9fbb196b820f8b4d0140ffeb833ef88c03a7adc2e70a77dd79b7d788e7dff81015304a4019f88ed27ec5ee05a5c6a8a1d2f0b4c3694b684b6a1c6556303515747bf3a3370147c4ebefbf9eb43709347cbff7fb2066d5dd2af73df78cb5334037d48c73c56d906ca80fca25bb3d6d169e2f44cd7073f8db3ddef6b4366be4abefbc8ae43aa62266eee6b963e68f19bf707cd5bdaa31f3c6b8eebad02ce84940d9aea004203e1b357bc0d495f05fb048a316ed52daafecd097ae53e4511528507aa9aaadf2a4b1a81f52fc0d06dee8de5f6abc8819235c77c1918f064d426bdd874cf9e0f3b100ca326152df098bdfe83e60bd329f16ef9aba5102cb26b75c7eeb93c19837c27567a5380d18025e6b53db9bde02dcbd46cf7deaa537bd8ed2cb44100d4bf974d4ec8f064eec3b7e519d0f05b66e8db0d4ff3df00e28acdf63ad909e63b5a9c41c2894957c8b61fc0060411f0f9e8c0f82ff40eaf628c7f8956cd4111a4e0d9bbbd9e328d9d1cb04890d6e4f02cac007e546e9460ca41f499fbd71360658d12c51aa081c349c36e49dce9bb87462e1b942d3d7a618674ce9b5528012fed1db14f0274812a0b2dc20a745d01a4cbd315074a168fca2f1c9fb9267ad9f85a68c178cb090d95f644f5e3e1993c24bc26124014a58cbd2eba570b51e3f4b40d99ea07ca7d770b9e592a6fcc79a7e40c3a9f12b5823176c0faffca9415052036093b4e8421db4c13faec3ee375f4223f404f702866e214b1f6cba08bf06ecb2d30e4d5ccd0386e01fdfec3110f561065139d479b3fb90a9540b1f0e180fe6caccdf01649f4f5ac64cde272ef8eaa5777a5253074c5d25ce3f1be6bc85ff70a9db226d985d90f3252b797fbdbed783b0876115b7c32a6e01d65828780ac44b8acebffef1e714283f1d31ab4192567fe45d1b35466c1661ee4946e25e8072c22a2ed549da7fca0a8ff90d4a59cc8941b328c17f02ca4006e57ad1fade237a2323ee33aa0fe0080e2289765c752cdeb5f893219f0061d6efadc89441d26dca6dae3b2e8a62185dc15a01c6212f7eef33cfbc3bd43b2850827d43a70ddd15ba0b80ab034a90b7f7c8dee6efcc6b056b3ffefc63c32903bcea88992346cf1d8dd5c042f11fe61189fc47fd3ec2d48c2319b336cc023d074f1ebc9cb59c80b29d40b95a9a892cb85b9f51c837bd854878b74498a9e10daa82d73eec0b7b28355e6026ef47e5058c48d001b899b456306ad14e6af621b336a03252da691ba5484807cd588b4c1cfe0ba92b2c210c1a02045c13928dc419a6f5f58ffa611120f29059eb51b225bc66714b78f148d5918f23a5dda82eea35663e5ae8d67b24988ba9ecd483bdc7cc87455d214a054c27ace4605943e76cdc146aaaf3b9b0ac8dea427c102c1750c3e87a65017267f841307ab93009947cf5fd5e58f3b9bbc3511f593cf541f089300a4f3d795d10f5b980fe41d3d76041602b7ce59b3d0680ddead2eb03a7adee316cfa8c2d72ef2f0a01658080d275cdd54e17ee54dcaec0f10f3301b6b6eb154248c6ad2e2bd9d9cd51bed5a573df6dd1c95c7cff41c37e139760805cebd3ba48a8bc4c8ebdce0d4a4b99c575bd5d5859f25d097ce8bcadf3e25c711885a3cc3991533bca7f2c6f134a3a0e3bc89e6ebe72ec876ab332a4e45b41ce096f88f2cfd4396fcbcffe62f8bcad08eaec4a6709783a24e0b53f9aca71ad43d624ce75c568218768270765bbb2b276e49ecc9dbe7a7aedc8389a4128d931ac74fccccaa5fcc441d3577b03996f9db4b1934648f1b78367acabfdd176c756124a12b51e943e63659b67dc84926dc24a128492049425cd6765e5e54a4f97e5bd1a0c61d89f8350f2b173f08371aeabb1ae6b7af7ed9a9bedaa7ec428893689c48aef082503109494cc56337553a3eb868b3c6ca28b28adbca6f331df5645b6061101250125110125111101251101251111012551db83b2ec3405ca3c9b9b6c0d22024a024aa206945e769202a5c1b6976c0d22024a024a22024a22221f83d25c62db63739e73567e5fe9e7d712754860b338cf3b6d7b6d7efe93d386a03499add98e2349155fc7555e09b82b7eae26567c975e76ca9f1f576e31171f71647f5b9178d51577cd151b18f14365fc79678acb9aef4fa0b498ab6e7840095c36fdf5464d50a0f643764934f6b20ae705a73fbf5fb7ad405968298f735d0df8cbc8a3dc3fe5da0ffae17eb49a4ddf5524fe7b4f6440c63db7eea823cb8f40092fd91c50969f2d27106c7e947f551ed8a02c365b61bbbac82d373af75d3fbc42e064597aa052b286957b74e596c2ce044a4b9985ba8187440b1e71e4b4063028b34a8f75bd0702f95796f063554c608312f1655946670265e9d152c2be9646e9f1d20636b8cd6c3f68ef2ca0349a1d06fbbe0601915071a94b8132ca7d075bc3f73b0b96ca6dcbab5f6e339beeb8a3021e94e79d297e09ca46585976aa8c80afa55176baac0e22cbbe2c73df76bbaeba3a0b280bad4e9dfb5e9ceb6aaefd40f1c30747acebb19e5629cc3db55de7787c7e3193f6d57fb6793b45879cd5d96733dcdf1379b93261cfc3b8ac0fca4b16799e621dc2aadd7aab22ac0e71eebbb5e6f02d5405c4c95ce1e3530c8dec4b66a2e5d386a039a33efbb14c53a78274e3b4663675d319fa834d59bffc8233d91f4159f16d45e9b1d2fa2722cacfd4eda0d497e99f7ee9e93ea3fa0c9d3694a567d5c744823ba1f788decfbef2ecd805635d771a7852d182ed0bda0f52cb18cb2a6e5534b3b2d6aa1d3d77f484251356b2576234aa342a243ba489facd5c732f28cd7673e989d2aadb352f0aee70506696d6bc0f36d7bebf39a0a45e4c580797315537ea7064f23ae1df9f7fad5b9f519f8c98c94e3d5467eadcdde1afbed7eb6fcfbc840a1ff41fcf48dc4bbd8fe1b15f7b9bd16bcc3c0c70d20ff79bb0a4f7d80503a7aec2a8b8e0ab59db944dcc3872c1f6ce02ca1ad2edd1d5c6657d509e2b94bcf3cad38aad3343364f5f36e9f39f2ac31feaefabd2ae9e3670eee85ea8b076c660e1dac98f49c9d09d73b62f1829583b79cbbce1775d1193077f5c9f74d74ad5cd6ccdaedb2ede30b5d380927af65ad58f557570591f940850d253f95ed5b0e9c36439b2c5bb1797ff586ebb62034774769de784c6cdf241930661c074d13467e31c760c7be18e8531ce1894e47c99f3f48b4fcf583b63356fb5e7c564f7ddb115b1f3b6cce3c671cb6e94651dcfc2a4e8f2e85d61bba499d27073f852da524e2c67156f55e1b94260171ca46be900dc26e926cb654bc5ed0a719a78cea63928415345e78b9e7bf5b9a92ba72e672d77de72a224716f22d68aa16338ae39f2cfe6cf583723c21201be0b9384680d94745c75a01d2c0eeb3669e9a4ee03ba6305d28fa46354e7d061b5b729b7d9afd8311a6a0aa5d69c1bcbc568e54f95f25cf9acf5b334468dfb9ebb0e286b1079abaace697140b3d5e1bae682396de6fe35d8f6e9ab6ed7096491de74b2fed487c25de75195c0e5150a97f54129337ff7d9e8b9d4bb687a8f993f758378214b8f517a827bd8dccd93d60836859adeeb3b1a7b082445f9eb1ff59bb3533371355f52743ebcf2a7b14b19d8435b232cd33605a38530e7ade5412998715ba40db3c82d97676c918d5cb88316e7a25ef38081d18b772de1c651a01c307595a4f07c58c5ad691ba5189db649fadcebef0f9eb176abd642bdbb7cdc72d6e4b5422ccb339abcffaf4fbf88a954e5eab7f2da87cedeb8529c56ffcde6ed0dcac38eecdb55fac6e2a78769085c5eaac6a5bda1d47b549ff7a881955306e8180bfa7df8da25b3fc7aa97a50cf379304cbe2b84b98cbc7ad9b39184ef08b2c3e6dc998cfde7b454b9f0f3358a0daf0b5291893c03bf9d699775c11c0dff05eef8eeafbde84811fb1568c439b09fca5b3467eba787c5f1852b8d7cd7387c14ba21ccc3d96c99b39e293e593fb4f1dd21db3dfae082bd3ef18d5a7db88deef2e9dd8cf434c874ab47ecab8fe1f60aee3593c405cbe75c6d4a13db014fad231a8b0687cdf375e7c0ab3d822b7f93528dd3fb91d871cd435955454dda8721c7350b86c1094bd86f74ade9f1c5d163d76fed8926f4b66ae9f090c8126c08aed075b6d500264c3670c07cb328f65626ade993c4ceadebf7bd617591806c84099d91b678b52455b645be66e9e0be0ae13ae1b3265489c2b0ea044e32fbefea2244392b42f69d68659580438fbfc6bcf4bd22561c56186d306d076a37423dac7bc41c941581cd62de5408ae19401f00270a7ad9e169412b443b303f4043a31d06f4c3f98e2e0ac60e74d27da812f5e2b586bbc68c4da32a398202cd68d7ae32ed08cd503c1d13846addf5ba935377d6dc2285618338ad3c58b772d06bb6b6f1fe7d74e98c7b63f4d74d78d14de5af1e8334506fbde14e7f9764842efa738cfc554fd581f94eff71b03062de1c58392e0e384959c48f7fd1dfa32d849a5fd4a58c56d0a944adb15ea9587a8c34e3d3870da2a14f2328f3ff5e21baba499e0a928ffecf895ece99b82578ad286ced944f16b775ce52a49468f61d381d1ddb19513567139e947f09f02e5cee8f28f074d1abb8cc1cf3a4e8da29c9ff585c2f603b56e5b222c680704a75e77f146f7fe982ace3f8b51948f5ab803ffa7ac0b024f7d09ca03f6dc6f2a925a71e9cc99f2b4faa01cd9a7dbb60523404078bdbb5511ca6db38e6670bf290e818bc4548072e2c08f00c7cb163955fff38f5e3f94c606d7600601af5cd9da1d0b47f6fdf0b5af0ac4285f33639064c354837cddb8cf3f408addfbfd57c1b58d7386f67ce72573c496cd7387538d443117664a570394e5d13befb9b529412b52452ba84937ca34538674a7603a7d58cf6df34700a663fabd5fa4dea8672d0467c1f15d8b47a38255bb55b066927f3bcaabae26ce687b7079d451fe5503a084ed9abf75feeeb0dd1432226d91307d9c180ee8597389cc03507a6cdab249b0721858c15e41bdb69b32a4de4c19b60ead2150c1f3f6473d8b9fc8f756f874e8a795772a31b041bc01f4848ded3bbaaf77ea27833f0167a9d9014494e097d1fbe6894dc19bc0416aeaa29d8b5002f8ee0cdd494d05dc8154305191a7a05088bc7ba7a6666ad98f65f3b6ce5b425b02bb8a466a5b692afa8feb8f5f08aa717634bb8ea3b4945af01f3f420f6dba7b1effdebaf03685dfb047eedc24e7d7de775dd58ea8073e51efbe5d6752bda86baf625dd7721c878bcd96061de533afbc3362feb6b5b25c30112553d78bc1b2f12bd8def73b52a06cf0e5b198e5c3fee3bdadbdd963202cde88f95b1140d8eae0ace1f330bcedb9d73f08365e9cb25ecc48daeb796177d1f96a50de0719612777c7567c366a8ee785e059c707cf5ce76d6ddc72e698a534a4dbaf7dd4affe0b17074e5bfdf9e4e5d4b2a66e90f812943f54c657fbc4c89b55d10d064ce5c38e3212b3ecb31bec6663438eb2dbfe64e6993cd1bd6aaff76d71c8eec5a3c5eba7027c142811df5b1548c3eb385004cc2600e74ea0c306a2058012ee0fa034856e42b5bd498cc513fa622a02256864ed8c41f87fab220c19fd55bb0aa03c9cce01fb0a551bb0943aa014ac9da4a5cddb97c4ac8cdb0dcf98586d6f5119743e98c2420547d476feea4928f9c1a64022ef77a0f4b0d261765e7036ea5feeb8cbcf967b2e357fb81cd9f14b6fbeb45eb49ecab2a90b62a6af99be68d72238448cc2cdc1e8bdfaeeabc8678bbf297ebff7fb48bd4baf97822cabf9ab2938c236aee1af8159436b98775dd03a24d7cb99cb613341a591b346a27d0ca3f20bafbf0054c1bbcddf361ff002e65e7eeb654c55162831155e12e5987dc9ee25b0a5d4db25577157ad11ac81cb430b7094988ae5c2cf9a2e9ac6cc1b0382a30e968bfcfa9d1eef602a264933a49e8ff645162a602af8987b321704df20d9306fcbbcd7df7f9dfa4998b07802ea2fa52f05f155052aac182ac384c28a36d84769713c84cbc7e9a3741c76b402944596d287fb28bf68791f2510793dbb1a918df551ae10a5bef0e64753d68bbcefdd961a2f74eb330adca44637698cff7ce9cd39bb4223aaee2271c63027fd3037e3280676e84b676d573df3ea3b987da3bab0fa65b0c9e01a2c1ef26b1849900e9310709d4b0589c29c2f9195036abdc72e78e99d1ec1a6affffefcbf90dda3daeced6acf0bc12d973f1b3d17f591ad4b0ace7d3a6af6d48d124cfdfb73ff02bb51014c9cbc2e68228e1249063369dfa0e96ba6ac134d58c9c52cbe07e54f6ebdc36c7c541f251019b7df6e30971437d847b93f99f5fa0bff002bd53b667b0b43364fa79c1ab26918c34fbbbd326f74af5bce5094c07852f5917163d4a8d904142e99d0afdf47af019a308f9f747b1903f3c7f49a31bc2712797840d010016388741e1e73d9a4cf178def834cfc448ee09d579e5e3f73f0c2717d94db67fd581e5a079457ec4aceca0948bd974ceca74285320d7bc5f8f9637aa3857ce57a544083eb670e419a0fb2d7eeebf423507a36badb567abc1451bb37cd83c8afca2d659606536fa4c3e125e188da6fdcde1cb239e7440e356cb96ca12a8026a5d74a232c11a98752911447da2313dc091e5edc75c555c6651ccda04ef5c0d381b9c0167c28d25b6a5e04f54e4798b8a2f345897b123117888c36a9a919476adec383ac198b80694505aae7144b493b9c56f993c787c25dea4bf5a907530159c75587b7717c0a5400c75139ef749ef783147c558045d8af7a3a256d3fd8a24aa35007f5613fa9d6609f9192539d9225df95849bc3317b9d735675ce7a7b71d9d94079b70e221b032500b425bc04a172d4dcae837c199cf2be938797790c539189c35422e7c530001752fc0d06820ca7c04a6a76a0b386b34517b66a2de282af00566dd53d56ca0180959d7a889376d8f35edcf21f77c53865e64b5b22cc48a5d114b278cceb75ac72f3a5ad5aabdce2b98c29b4fcc79dfa3234b85de7404dea656430a1fcec13d42bb9558e6ba88cb4ddc77d94cd01e50344e652886ce6e541b08d200e6bf9b8738512df5fd673c7150ebf097b0bd43e4e3bfe054aafa89339eebb3f23b2b19339e04bc5ad0a6fc09a79ce71bffcacba485dbbbc4d0226f1cf7ffd33ac28f8d5e68db76150506e0c945e5c3ece3b2d7c0c4aa3c591e3385807910d83d27d1f996fed58ca4f78f5bd5eaf74fb14d9719d49fe1db7fd0a944e6b61b58b7cf47594b066918c05de10ae9dfc5fbff9d5134f3c316bc427b5cb7d131b670fc5a2fff5dcdfe55b66b474de6f8b43fc1e94575c48b42da596475e1e847c73e0c481246a0732fd4782f231e5635036a13aa09499bffb68e0c40008e4e07e05ca46b3c07aa0b46ab7a58a5604405c7a70aec97f41d9d8a31c1a3ceb4da245179cfb13288f53e5398ff1ac87faa977c0879f833220c34f41d9e87d540f83d2f593abf48752fb653b8926a2f840715e33545858e863507a6fd3ce711c6a0b50de0f2fbf1166bf1cf0919d6f6a623f161414740828af9787bbd24372744199da008cf870a9ba21e974baecec6cff0565d1c922759c9acd6733d94c068b41a2a960329a23269329140af57abdd1f8e8af8ae3500d284b8f95763c28ddf7e5390738120d9dc5a13158011ff466ecc7848484e2e2629f81f2689e2288cbd8dd2545a7d3c3c3c35bb4b57d014af77d778239015ffedd44ed23b1589c9fff888795da0fd86b40f9454783d275439260a6d1e864c7d5168d468b888868feb7f7714079b6248ccbeaeadb1fd6d2bf4099e9cea4d169e49bd0ae9248244dfb4aff016578e1611a9dfc6a36cccad4d4541f8032314c44b6368bc56a51e755fb82d2fe859d1bc4257bc5078a8b8beb14a09486c77748b6151616c6e7f3fd7c272a148af606a5b5c4c8e7b2c8f7054a4b4bf31750661833c8fef08da45269a700255f2cf7fdc661329979797972b9dccf772250decccdf8bd1794969681b2d858c866311fda38741a9fd3028fcf62d078ec40c8dc131313fd05943189316d600718f4dd24777f94783c5e13d9b7ff8092231037b88ba3f3a31bc58794cf13f1bac24ee472b9cddc8c972a123cf7b1b8a34a2d452ddafea6a24216f32150860573be7784357f256355fc73251a02cab69456af6d83cf634d14040b080a1ff91d2b2a2a6a1b505a8e68d2aca159ce829287ae25cab21d08cdaed4a459328d656d0b4a5ab56a0fd72ed1666835091aef6883f5f1534a95fc3c6fad1f5706839194942491485aba553512764a98205ecd67faa49ffdf14169359bce95a75c70263716a7ec891c565dff78c4a0d0867093c304229e87a1c1026662a820295420e1d720555dbd1da2143c4ca2ea331934d40f957208289bd105b9cf5e76b2ac89884a8baab372ca1865f6feecf4ca74fc57c5aa3c7e41c24f2d4fcdd99f13951bc56032620a62720ee48895e2ec7dd9701940a4f55b6bfef17cd4474d02c4c704a5fbaedbfd5353e1bae58ad04728aa955498547b52b231852a0fd785bb6eba9a6ea7b110ab64753be6a214862306ec5f6a34ef685ed9b5b2c22f0b8d678cc161c10c16a3f8ab62d35953eea1dc90881054487624179d2a42a439d3d83c36ca4d674ca86fbe68c62164fbce66bf6c2f38515078a290cd677b41896f85582c6ed126d5c9b90772e4e04582a61380f254593af2f11f2ae3ee37fd48f08a085ebd53de47f3145f1428b32283ce16ab65412c79100b9f3a355c78cae8f986a6850b510125e0637eb488022528599116a29110503e4a96328bf3a2b3e99b4c620a63ea7b87822f0a70c4e320c6d14c67d2718827d993c292c37064838c343a2dbe381eac8c2d8af59c2ea7ed4e294d0992079104bc4d40f9c8a8b859a150523c54442547791f2aecbeefd6a7e8150fe4bce16cdd7d471275031d85a0a1179421da10fc58625f0b438460224a22d223d4f1ea9aaed850a9e37b47d6de2c04067020e1c0c04f2937888ba3054ab22585a5846176fc24279726b77a7b8607738009c49e4c9956c615f399ee4c19d8511c2f294b09e6b1e9c0475586cc958e55e088799ea9e5a9c10814a284cda4e5e9459817f5f96c860f40d9ccc75336084a808fea76c44f82214a94ad0bfaaa587d2c4f79a5d493921fca55509713050b582142cf89a0b326f519a39ac5e8dc5f485f80d2f33cca6bae47beadbb3e2821d8076a00348485745c76808fba6c1d22383c18e522a5089e02df13aa5ab23d59182c24287c2c50eeab0125f5a8f326a2f26a656c56b287854a6576694eed4959e5850aa50a5362d2e251ade9761a0b9152f6485052fd9502a9a00694691108269b094a4ad412e369238e0d4c55e81570940065cec11c6f5300655c711c2a4719a212ad89de93390505052d3a99c3a0d332b44204188161fc64537d79c849a395bc202e43c06160202d42782c5f8944df9624cdd4067d59a8420e0b6816c749c01770c795117230b766b9306be014c2911c4c95602a46af958553292d8fcbb9ee8a01fe1e19f7f7e81a0365952dbfdc52d858d84d863a7d94f820674ceacaf49058150f9f2552c6c5280ca3412fba640b05194be225ee0c19caed4952fc3ce037031f13f6138e92e226016593a0a49e707edb6ddb67b3ed6d387409ba3a2b87af0132234da206c935b2a4c8ac48c0145e32ad220d199636530bfb5072ae449ba12d395f129e1a8e595007e915be48002b0162eb40897d517323f9a9b2124b49d391527e36dcfc5584fd9b426b79edf26cc7a108fb77e1e6b359f6438f6ca4b1e00aea5ec497604ec83b9287541abfa0306fd8d1c83938024e6a592ab28d2059105fc2c701803ae995e9402a8e10a4e7f9c7f2c14741b000938ca78c9817890805caec7dd9a8804484c3af490ce9747a6868684b2f0f022c10de5124a4a0614d83b4ddc855e11f0144500325a08952cc8635e330e97bb364fbb3e5ceb490bc6811023eb4a693218845b10c88a14af6657b9ee3f0934b4b1187cfe5dcaa8a6ee6edcc77ddba1bae18ef596f2f289bbe60080709f36150e273c1fcea15bcdc285814365c22fec357666a85b09651722e7e27407cd4490d17b099f4302907bf1fb093206994824740d92c5036fdbada086d449d95637158f002d4bd8c18e00a3d5759226fc2304fc4c30f374af0c5c0f701251ca1e74047215fcc47216621407c5c509e7cf47918ef7b200aadcedae5d98ec3547996e368ab4fe6f0f8ed785e0e874d4655862a5605ced6e9f01108047500d1b45462f66183026149946a241c5848782e582d8cc27921cb3f57e2193e9eaf84cd044790a403a380664a98e06b8ba6205a74daa8b25657f06211b6119310a6b89ad34a9805a3688a3a6d024779b932e1ba2bb63971aa2cdd663679376cab41d965e54fa08c8820fb8380f2a1eb28dbf3aa6ffcd6c29f265812e4510f65d92c16cb68342a148a166c4f165d216251c163d1990c9a7754587d97349f4d8717930a98f80f8ca21cae10a3229e6718be12292d066442cf709bf751d617012501251101e563098e32282808b8f4ff9d48404940494440d931a0a4d3e96ab59ac7e311501250fa14949e77795fab795dad1f839246a3e398a0b562b64ef7e0061f8032c77e902acf2c3ddea1a0a4ed6ee1c387e025b1715a947a13501250763028e94c76506466131f40a4cf6bea600a89e0489a75071553200db57ec30a92b5740b0a23d254c6d381044aabdb5a74bcc8b0cf603d6c6d352873ed071e80f28b0e04255bac12c716056a5a40404940f9a0c75da157169ee0ab62d9929aab8839c1e118e529a2e94c0e932756177fe51955c6543b4236571ee5a92c52525e2f38d9214db4a284c1f55c684263b0d02082c664d75f166a0ac2925119d0ac3117c2104f6b6225352f57aeabbd26741617cbe548c39479471bdcb882d0e4e09452048323a0a04f8d0a23d2a90a7c4d424d055ef5ead119d468506456cdc757c55025de55a2464551b90fb64f1455e245bc34c9e6a9109d5ff3759269a90ad43681240966596a59b2e3646af9d906233a35a7e6a61a6d546ad9e9c6aa5111ebbade2250a2bce9066b479d5b18b1c165597b8353cbe5d9fb2471264f6f228319a4cb9167edc38e66f2443836308cad17a4cb9665b8b1cb64997b34968ba82f084d6ae65782c160c4c7c78b4422024a02ca4e034a8126117e4da8cde0ca223d5ff2389322ef08464332aa588260804c63be80510f7a8019361f031855e61f0738501092ee0a4973a204a001a79479c724f12592b86255e1970caeb03e2815b987445106cfec82604053917734489b29cf3d0857826f29d5380aab1fb8cd03a3518e510c34b871651955142cb09e9e6f204750f38ed3dc830fa8574695c0f85024a546b102de55a24a608da9126a54653c458d8ae38c35af6955e8a912adcbf3e2564dc979afe3a62a00ca544978f98d88cadb54b50643a54baab9a546a5d1965f6de6cb5e1e09ca62b325d97921baea66f35f20c312d631f83451741e8e016c49fc07fb82a272b0ad30805f02cf36a1d1c14a85e1300ae92c0ef5b3ea79f42f83d5fcee1180322525a515f77a13501250765ceacde601373f1b4c552cbe03aaa253701674b6272f53188ed4cab3942020c815e6f89e230df5e4c5e1695e407082c3c24aafa03e02d5bcc6b03628295f06bfc69347e1fba62a3a89ca308c21e995809db2e00ba036d4760954e26b12457a036573bc5c0b0c50866595533726aa635223ddf71e89b338d7d51cfb4193d9da34285121baea568bdeb4550f94bb414698688f1957c7e3770b1b5096e9c6fe42d4f8741a1d878738a6b0e69090a83dde93a4de6d0a4afc906464fcfc50c4c8c848a3d1e81d0d090971381c014658bf07258b075ae170c7a10f0e2215052bf9aa388080ca25011d7c730461296022b24e497c31a68223f083d5c96f120ab9321dbe2d80a0da7416bc40be8c6a4cfe4396a13a4d736312ac0766098acc441d900e8b4672876c4e1c6b9426dbb102c02546518e0124e36819ae964aaeebf67bf2256c8906517d9ac8d315408d7af368264f5c5381c1a24e0c51a32c61cd5d6b0c6e1055427fd057f0a042c8830ac20715380f7e2dd49e0a4135d70662c56a2ab0b8de6e3ba1429b5b525e60753518c6aa4ae30963fec17cf3b146ebd48e224b79fdbdd9042863aa7e6c4eb3081e5ff870873507db5c96b5c7f303997b103f605c7914f63570899f1679ce017c3479f67efc3684d92f4b122c48ccb10ba80aa0677dec36dc5bcd64e6e6e6ca643202cac640a9d7eb636363bda36ab53a3d3ddd3b2a168b0d06038c3901a50fcf7ad368f00e60166885648aa78cc630d8e43150d567334104204c1c53802f098317248ace473a8cf4993ac90300c16b88e34c3080680a7c0170313b32e81a3679132e6e1052f2205d36be8da8806a2026e6c2e2d038471a06e2a04d2c2b080d561b160fbe31ea61681152bcc039eb5d5573d6bbfc4c79abbf8a4d8032d675bd9527736874ec41962098ea3ef6fc5ae0c787c5c50053108cc30381611a838d5f1a6a2af55b8261ecdf666e1c3a9d8e43512068f14d41d8a4b5f10acf05abe51d8d8989494a4a0a0c5092d4bb2b5f1ed485d45941e913d168340e87d30a438415ae7d515176767654d4cf4f0e8c8f8f4f4d4d25a024a0ec64a0e4ab623dc6f3410445e5d01b3a154e40d95a50eea74099517aa27381b215b7309293390494010b4ab658c995eb7e0e5924d5934840d926a034d8f6d680b2ec64ab41d98afcb74d1ca5442261b3fdfd5793c7e3b537288b8b8b61ae0925a1f4f474927a93d4db4f41e9ff67543a504dbf21ae4d400969341ab2a9f16bd1c4f78580b28b82d25a69ad01e5571d0cca848404b2b31a536c6cac0f40693018fcfff920feb9a95b05ca2b2eea1d2c04940494cd072552bf909010b2bfea4b2291984c261f8012caccccf4ffb79cb793180c865eafc771e82350565ea924a024a06c2928a9f309c8fee8743ad96b94b029542a552b32c1568312321a8d292929ba2ea6b8b8b8fcfcfc566f64024a02ca568232c6753dca7d27aef24a4b5bcbcbcb4b4e4e4ee8f2c246c0a6689dc1791c5012f91128b5da86dfeb2d128982827ebe5a185980542af58eb2d9ec16bd078aa873394aa2f61001652706654c4c4c83df6aa7d369369bbda3b9b9b9070e1cf08eeaf5fa0b172e10f6b5480281a0891eaeb605657a6d4759f5a3ce7d2fce75957c8b082809285b09caacac2c1a8dbc8ddb1752a9544decae3601659ecd4d8132adecf4cf1d8e96f2428bb3c85246be4504940494ad042524168b09c57c7036202323a343404944404940d906a0ccc9c921176db5b7b45a6dd36703ac150f4079ae8d4169b494c24e1a2d0ef22d22a024a06c3d28a904bccb5eb4e5032f191515f5c873a656a775cf7d0f289d179c6d084a723287809280b2cd40e9f946994c8989891a8d4646d44652281440645e5e5e73761701250165dd43c26cda63cbdb6fcf0da4a8b016746e501275acda0994c5664b6af95749ce8ba4d7b27381f2a03de756959eaa1f48717f8feefbcaf8524b110125911f8192a8338272afcd70d7ad0b3c4a7ae39a2bd6622e6e8f8dfc442be6a9fcc1034a7cfd08280928893a1128e1b9029892541c72e4f80d28bfafa44ea41250761150e65b6b5eac965a7eb626f52eb1009a29e5e7bc97a03f52696979adbb5b4fa7cbcccd2d8a8ffff90b909959909a6a688fcd653215474565b66246ac5e5e5e519b7cde760225acd64f6e7dc083f2abf254024aa28e016581b5f20128bfaa014a0b4fe6180c4583077381a1562c7dda3429971bfbd65bdbbc25cb97ab468ee4b7ed864a4ccce5f16281e0dffc66492b667ffdf5ad627142ed924993c4b1b1d9be07a5db967fb63cb5ac5e6f9dcd6cbae38ef2139cddae083b992bbc57a5ad53feb529f8315bbee04c26a024f22b50ded4edb91febbad69c1676ecd02d5ca8d06852fbf4614e9b269932450c74824d2346f03fff9c25952616141867cc08eed78fb56c990ac34b97aafaf665cd9c195c58687ce38dad6c76cc0b2f6c9c3a15334a72730b2950a20e662c2c340d1ac4a1dcdc860de1132688860de36112e61d32849b9353a856a70e1cc8193a9407abb86d5be4f0e1fc59b342d2d3f3478f1660e95ea3fae187bb9e7a6a5d4848d2af7fbd64e3c670aca74291bc648972ec58e18a15eae8e8ace1c379683c33333f3c3c6ddcb8a0be7d99583a5666f2643150fedc731b44a2f8b56b43b1dad44ad2e9fab97365be07e53e9b01c360621d5cd607e5fe6456ef0ffe35aa4fb769437be429d6d521ce1d57c48ce13d07f57c0b15867cfa760c67f16322ec6cbe68e39ca1cb27f7af8aa77d55207efd857ffc6053d6a913ba6b6e335bfb228b5fa8da1070a0444d0b897ad1febf3496728bfb9e1b3babe2eb8a36042556bdd05a81f2426bb3f80bb26cda14219124002840e49831423005ffb76ed5a6a4189e7c720d18faf4d3eb51213838312929f71fff58cbe1c4804420e02f7eb190c58a7ef1c58d18061f41430a9432591248873aa3470ba92477f6ec109483bfbffdedd2ecec824f3ea1d368516fbfbd3d2c2c8dcf8ffbf8e3dd8b172b070c60c3d88e1f1f04bc627600945ac379f364f0807094bffad5e2f4f4bc5dbb749f7dc6004c816fd4fff4533a28d9bb3703ecd36a33366f8e007cc1d6b56bc3f029f089f0b9607bf141b044ac12000de662893e0165620df8ec862a5bfe17a5993fc3ae1a97a51663638e72549ff7aa99183e77f46776dd761d63c18d320dec9e9eb508388be32e411c4a639747ef8c622ecc95afc5e825b33c2764cd5587eac7728d51b349cf5a78ae5082460cf27528cf94ae06738f65f23ca7564ad5a9a21505caf5379da1c0eeeae903c1caab76d5a2f17d6e9687ce1cf1c99e043a1afca6da45c2606a76cc46a04d6addd06c046ddebe2426653cbf2d0989e52ede93c8a01a17ad9f32beff87a87f225bd0f941692e711c76547c57e1bae1aafab18a449dc066a9b854e138e2f040b3fd4079b71a94dfb42d285b26f068cb162d38f8ca2b9bc11dd83d184c7849d010fef17ffe67398c215257900e5c83dd53ab53e0e65e7b6d8b5e9f458112b92d6684a94439054aa3d104b309132a97d77c37303b2aa4a5e5fdee77cb30dabb37132006c212137394ca14b40050826b98044a4e9c2802e6d0541d5052a93796080e0294581c46df7967fba2458aa54b95f0a498119e94c1d0bff9e6b6050b14336648b162afbeba19eb1f11910efb89d5868dc55abdfbee761f80f2bc33a569f375b71a974e6b6183a00425012f80f2400a6beee85e576cca5bced005637b1fcfe283621fbcfedc334ffe1fe088cac065b77f3dcb5f3309c0020d315756f0ea74c92a54fedeaa48095a31bcd7bb18de306bc8c4811f5d2f55af9b393851b02c9abd68ebfc1187d339f84f2d1438c6ec00e59209fd30fbfa99434ee4082e1aa5d9216bd0c89421dd51a7346a0773f9b834f14ae9a669e1bbe79e2b10af9a3a0014566d9f35aaaf07ee61bbe6626d31cbf92249e706a5d96aaebc5c539344d3810d65b6993b17284d66bbd16c37996dcd6961dd3a20490d50fefdef6bc0231834d846584278ae9e3d692b576a60c1e0d1403dd0332bab0038c370f7eebb3332f229503ef5d45a78ba1e3d7627271bbc7d9400dfcb2f6f02319b0025a2470f1a9a82e3f382323c3c1dcb457821cbe3c502bb3131590d82522088c33a23908357bbd46df0c800253277b40c74fefdef6b8382e2f1d1b0fe1f7db42b2121078bc3a80f4079ae3ce5d17d8255fa13a519f54139b277b771fd3f58337dd0de4406462ddaadf1bc2525e15b0ad59eac967294498265b09935f5fb74bbe7aee95884b903bcc60ff8f0cd979e3a932782f1dc3c779864c35453e826f0b748bdf1fdd79e43e354c09f7a4129db32035e12a0bc649661149340436a1216448172cd8c41433f7d9b9a77d9a4cfd53b6617876e4639967e388d8301ab76ab60cda44048bd9d5f3b09019b1f1e90993b0d28a93ecac866f75122991d32840bcf05b705ffe53dab8301a3b166b8b818c3262a89c6ffea61cf485191a97a52b177466a2039391749f79a35a1b5cf595315304b89e751dec5540bd4bcb52bd419a6545dbf66de3a4bac539f6a995a73aa9c9a975a6daa1aa8add1a4fa009407ecb967cad3bce1edb2a4e256951ec9b8d56caa9f7ac327767ffbc51cd95a7849aa0449eeda1983d7ce1874d7150124ed5e3c7ad39ca1c6d04d18c55467cc2eaabe2d721b46d7cf1a92c05f9a1cb4fca3375fc857aea7cc207be578f9d699e06f45ec2ea4d8284470564e80fd04d7a41ba7c57016037cf0ad9f7ffc3ac00a4fba73d1288a7db541698fdc86a9d9c16b62d88be022916ecf1bd30b8e329e07573f13155082f6317bc8e6e9972d0a7f0725326bb3c3dcc4390412cd8d7b7bac95d64e054acf59ef98aa1bcd6c04de0d2e92c98c6eab8f86d690b9535cf343e1f3b6ee2cff638a3a99538dc868b848f0b1b19339e70b25706a080a7c54e8590b61d62868c67216632a7267a4e728c995ada5eaa7885660f4667968ae7c2d92e83cc57a38500c47d0e6d975db5382966318793ae08861c49739c2fb6e2d688bc202e5fa5b1561df95c8343b661fcfe46548577d5b12e25d3a127624d40f4efe88d1a051b389aa70d1148c4cbc48b3f1a63394aa00178c2cfe44b6c06b72fd1794aeeb2ef76d77d9a9328be3a16eb6d263a5847d2d8dd22f4a3b0b288bcd966a47f96fbdfb36b9b4c0af0450deac46a4dd6c6ad1e54130989be60cebf9ce4b14287d1c4733b8aba70d5c3773b0e5f196ee8fa034dbcc0025355c75bbaa362ecb4e97d5a180ed8a2d716f2222f35866d5ddaafa98705c755015d20ea7b9efbbeb57400bed0729fb157b830b6d3050d370ca60bc68b45fb57b1874bba2fc667913f59bb9e6d880fe09ca428b930265b2f3bcb730a6ea47024a3f14805807918d811239efa83eddbc31ecb377de7df599b75f79baef87afd52ef74d0cecf12616fd69b7575a312f20ebd7a0acba595527bfa6708964bcfc4c5d70a41d4a7beed5e716ee58b868e722fcaf4fa5ac2fb2e66d99f7e21b2fae0b5ad7204947cc1ad17ea01cbf687cd3b0ab1d70fcf808b337cc9ebc7c324655852a969ed544fd66ae397e5dfc1594e50494010050ffb9e0bcfdc28f40693f64a79e8bd158b8aeba9c171b3893d367549f1a70cc1c01b27c3eeef3d2eba5e64be63e23fbc873e59e87cbde2c1f34691006f2cfe677efdf7deee6b943a60c41cdaa7b55a90753fff2e45fd002d8e4bae38289634631074e1c0860e59dce4bda97d47d4077ba963e6bfdace5ace5e234718f813d30fbe8b9a323ed9195772ac7ce1f3b75e5d41d9a1d63178ccdf932c7f4b509d5fa8fefbf55b1d579d3997b2af7af4ffdb5d7f05ee3168ec33a54fe54c98be70d9e3c78cee639c037a2e7a09edb94dbe66f9bbf70e7425440b3d927b2cb7f2c8fb481157b50f3d5775fc5bac557c563144b1f3275c8f435d3b38e6761342825885af30d920d18b55cb6ac15aced37a6df06f186b21b65ed0ecab207a0fc96809280b206943f3a23beb6849e2fd1045eec2f8cce6e48f9f9f98ff3c2cb275a375bd9c932d70d1762cfbd871de5adaad213a5667b038e1201dc6c916dd928dd387be36c38ca55dc55c5df148359db55db6b9ec2fd00948849cb26018ea8b692b3126eb4366711a0e7a839a336876c5ebc7bf1e7633fa74aa6ac98527aa334f7642ec0fa4e8f7700c48a5b15f3b6ce2b3a5f849297df7e19597fc9b7254884e11f176c5fb059b679fcc2f16b856b29d8017c54e3920c094887c6973397f71cdc1325d24c29e068fbc166386d00a693f7274f5e36192b409131243b64a766a777dd807e51aa089f1450aef30b8198b96ee69c4d733075eaaaa95887760765a9c57da71a949708280928a36e5644e4e945020ea30b3ee85a2a9582983e05a557b5fb283d887c70316083a0fc74e8a7ca7c65ca81142aefcefe227bbd683d7c56e1b9c20641095f898115ec15fa323d06fa8eee8b191140156604e0d09a224fa12a5051a0142409bccb82c1845da5708c2502943071dea9c0a2305988d9e50679c29e0494c0bac2df518def0edfbd84b6846a5c9623a340b92b6c17352fc80e0ea226403c63ed0c94a0ce0ef50e8f95bee32af9ae047c0cce0ae627f2874e1b4acd8235f76ca2bb55580de01576955a748c33868092c867a0bc5ea1d3c9b85df9bd004c26333333b36340e9beedae8dc8c64009d85119282786e32d841fa4125244823b01c92f52608006aef0d9579e5d4a5f8a44f5cd8fde8401440541a260e8d4a1c88eb9715cebf756d8b101e3078c993706d5907abff6de6b6f7cf806da4fda9b84cac8855173f88ce13b4377224f47eafd97bf7b960e9f88a9897b1391c2039de3178f47a68c12a00d5c1b337f0c2d82e6b8e6002891d7036af3b6cc43eafd56f7b7a8e43aaa340a7cfc6cd867c3670e47fb58ae279bbe64414d201ec93e300ac3081003f44f3efd247e0c50610d7f0d6c2f4aa2cba3338e66c04b029d13974cacd3b3494049d4aea02c490c21ef501189444dbcdeb9bd40693f68375b1bb88eb24147593f56f3568332ed7172a676b6db59828092a85d41191cc425a0845a91803fd14e7ba5014759aa47bee98ddd61bbfffb0ffffd9fbffacf853b16d62e6f938065fb8f5ffec79ffef227b8d7366fbc0d03269a8092c8473215b2594c4249282929c97f41c94fe46f916d21513b64b9b24e01ca224b1905ca24e7d76d024a93d95a54fdb6db000ba3d9eeb79c2c3616b21e0665a48cfb9d2db4057c09159c36aa020094898989fe0b4a129d37f5365a4a9b094aa3c561b0ef2b6efc6948f9565762c5b7982bca7d3710e34e9ceb6ab6e370b16f9fd5ea301b1d964784c594cf62d67594470c0aa980a996b0b92c3a46f96cba4acc46f0aa473d3d7a3c06a68608599844d5a7d3682811f39904946d0ccaaabb55f6cbf6e2af8a8b4e1691682272cb72d39ba19c9c9ca2a222ff0465a1d5a973df8dabbc926bdf5f1f9739f6834009d55440c7fd94f2733e6365a9c578c31573c71dd5745c7346721fe0cfaba3798aaf8ad58ee4e09345aa202e233c98638c159b1324c7f21498aa57f0be2c5415c74b4e142af3f4220a943a39f758be3256c527a06c3350baefb9b3f7654bd4120693417a46da501c0e273434b4a0e0d1ef32b6382cee9f3ca0acfcbeb27d40f953b1d9e28d026ba56ecf3d0a1671953fd4c62532d3ae41c99ac8761cf10d289bf39835cf332c2a2278f54009f051de302d4298a30b8a51f280ce23798acbf630141ecc91c35162202c9883c0c019931a48e530e924f56e3350829251b951341a8d70ad9dc4e7f37373739bde116687b95d410920c6b86e7823baa6f0e778804b735ad9e9ae43c9eab7095dc32f872f4179c51577b932beb1b8501acb613de457980cda1705cabc6851b0905595218b53f3cf9ad4d10a1e70f9b545031a96a70617c688e13433b4c278359fcda41dcf57c26fe6478b3a352bfd0b94c98e6442c9f69650286c3a0d6f3f5066961e8f735d692635529ce741cc2e054a386b6c375f82b2c2da548681e384f9701f254c62657a88214ae44c0d0107e9b4dd40a4332dc49e2c2d4d094e091770587464e215692180237019a3e25912a540244a52c38504946d20eb312b8bcb2220f381a2a3a33b0494507ad9497dd5ad87c27dbb0e2f6033ab4f6e58305067d2769d7d21330ab133ba5cebbe5f672a37e3283515b1415db84a9a3960eaaac7e7d7d48d120406b0c45dd1cead5aab30e74b8c8655dc96169d6f62c620c3a9962eabc852e6cfa0ecb2f22350a6e5a791fde11b4924928e026503575c7a4ee6dc7b1891e607a97a5d506e0a35bdf651bfe5c2e471cb98f3e9da3a53676e558c5cb0fd85373f5a264c7ab7d77094bcd767d4e38332a4e4db5e63e661603e4d3b6373c89c9d1aac03467959c707cf5cd7c48cad583a012501e523149d104df6876fc4e3f18c4663fb82d2eca80165c5374dd72cb05620e58c755da75c64ed49f54129337ff7d9e8b91808affce9d311b3fa8c5f44a16aa3bae8a5777a2c132472d20ebfd77734acdf9c5da1287ffe8d0ffb4f5efed9a8392bc569308098f7cd1e03c72cd9fde18009ecd443ace4fd98fd83fee3462edc21b75c96165d18347d4df7215326ad1584bbee68ca6e8c5fc1ea3e78ca27c36750a004859770e3502ecc3d89d1d18b77fdf5e997baf519b53a380ba3709a5850efb1f3578ad331ba535ff6c7bf3c89a943666dc0a8dc7c69f4e2ddef7f3e168b60a51c24a024a0accea32badcef3ce16853e43fff89f27ae388e2fe593fddab4b85c6e13dd946d024a93d9467df3132bbe7b14282ba3dc7732cabeacffd2b10641f9e473aff619b7f0f349cbb6eb1c61ce5b8017a0098fc94ad95fe3e3aa41490d77eb3d525b750fa3dd874ca592e597dffd44e5b8865922aaee82629f8c98d967dc82f7fa8d012b35e53fc233a2f117defc30d8f4f502866ea3a628d27d9f91b887022510397b87bae7f019737787d77794c2dc531357f1064c59f146f7fef51d25da079db12ccc4eb95d02caae0e4a8bc3527abcc5ef7588298ca9b37232ad2cd9911c5f128fff21e19e9bf339024e6c516c4a694a6852289d41d7666a53ca528432212a6833b47c31bfe45c49e69e4c54e0897864ef760a507a53efe8aa9b99a55fd4c66583a084e30b365d0c75dea24ad6c90df368111357f3bd70ac0d4a2faaa8018012b4f2b6f6f9a4a5bb629c52e34576da216ec6d16173366dd7d945f967def96c58b0f1e2525efc5a59aed67d6f87be0ca0449b03a7ad0e75de84f7a4b829c8f9b21a94f7d102cae13d05d9276054dfea39886affa38113235c77d5a5d7438abf99b25e049aa3a620e7c4eed80a024a02ca92f273e5ad784d587d503239cca29345a189a12285a8e04401c868386c48b227852587157c5110991dc9e17352cb53d32ad2004a369f8d0ae995e9b248195fc2c730d9bbad04a5dd5c75dbf3b8f8ca2b6d00ca98aa1fd3ca4e371129cef3608d9714d5b83c4ee1b23e28a7ac17c312bed777143feb3855026ff8c1e76341286a148eefa5b77bf41ebb00b9f32a692686b74498b745da30b0949f00c0bdf44e4f18c9995b15a82c2ef86ad4c29d488787ced9b423ca018bda6fc212a4ea2841f60daa02c13d874d1f317fdbabeff7021631a9df84c530b354ee8c454f5e2b44e5b14b1932f3253850f85638dc57dfefbd35c2820a1b54053d864e45ae8dac1c6e74faa660acea80a9ab96f0e2092809284b9c176a9e556edf67b73aadcd8cc8b8c8faeb673862a006720ee430980cc7f70e8032a12401a188f6dc0910240f2abf512e081650d592edc9c26021d9af8f054a5b0d285d575d8f07cafbad3e7f025c66951e8ba97789659d80b983dd43560b2c06c6154204945d119496f2165c3dab8dd2d63d39ab9658bfb12aa214c210a1f98219e9369c63cec19c38535cded1bc88f408759cbaf0cb427d9e1eff55319e7bef319ce1ca40ea9de9ce247bb70341596cb6eaab6eb7f672c2fb099597f26cee3aa05439ae4e5ac3af1deff61afec4134ffcfab7bf838fab33c99f635e751727012501656b4019a18da8fb7d0ee2864484c02d22adc600cc230a918687848788d562184c0c078705b379d553659ea9c8b8251a89344cca1170c8deed4050a2997cab2bdfe67e64e4380e3db885d18bc83d0df6518655dcdaa6b50640d0e25c9d1a94ec6afddc45c664e288f28ed2e9741e8f1760778ef81328232208c2020894cdd5839339352eb2e9b3de011f9d02944ea773efdebdded1ecececf3e7cf7b47232323af5fbfcee17008289b7132a71a94d60a2b012501e523419958f16d1d44d6016598e37b79f6bee094b2808fa898f8e8c695909060301848ea1d28a0fcea01282b092809285b2f8032a2e2a6202c65377902c00321a595cbe5858585049404941d203a8bc353e8694c764b676409659ce03002ca76b959abe22a57ae23dfd2fa128bc54ddc5b4540d9e540496771a5c98e263e802ca3aa89a97c4d224fd9ac3b23191c81b2e00b5690aca55b901312a12c3c1168a0bce517a054a7d961a1c8b7b441c5c4c4b437284d26138b459e53e3517272b25f8352a4cfd358be0e4e7678f22f0fcef8e2984269b25d9a6865708338d2d030fb254cc5288d4e478924be045383b499343a8346672af28e2af28ea0025bacf69cad1329a5091669a2852dd1d45f161af1b49c6417842679721c0653189186798374d9742687cee64be28b83d1b82e078d53889426d944d105206c4081d26aaeba590dca1b1d0c4a9132d2f71b87c160e05b219148fc7c274aa5d2566fd833e5693fb9f5880aeb235278ffdf0ebe4837e9f456740dfb1494ac20b93cf7204b10cce0782e2387bb94e71ce0caa3402b94805f707398ca14483dbd3774265716c957c729f38e79c848a389a30b501315e84c3630aa2efe4a14958b124dc979a4ccf541298e33b2c52ab8548e54238e2d92e71ce4abe36599ee900c17e0c80dd1a271ac0f57a6650a8255c6539ce070a019cd1250b687b841c10d76d2b5ebfda900657c7c3c725b3fdf893c1eafbd1d258494933c22562e97171717fb77eacde6d54eae911ac30f2af38f834d4cbee7b74e6138f273a2ad8e57159d8225d4982fc06ca244189ec6d724d4e4c8d2b050dbb7989d8a6ab6d60525957a03a63c7994c2705896b987aa0c53c953e855c6d33098eae2b31816681251e8f9de32d9cafc630494ed218ea0015ad119f4d0a4465f04a88c51cab4b2c7dc3e4c26d3ffe9809df8388e927a2bce231d2500111e1ede9559191414d49c17a8743428991cb5e92c127000911b12810164bbf07aa0154be8794c06bc9e24c11c925681bc581c6bc42840196afb0e859e5f5d4534788749981d60458e1c9c528a16803678d587fb288530a770a0f09ef08ca8260c4f55159d1445e7cbb3f7c3c9829eb2acbd80a9a72b20b58cc917632aec245a0e737ccf692897efc4a0fcd1034afcb7382c1d18dca0baa014297008e895d14a6a34322b32223d22ca1015961246a3c3f4d3b3f666655465a08e30c49382c07beab27508bed873fbbfdea057c5a8e43a394a5001d534891a14864484d4a624f22c99ac65b4e5b33d0ff13e6250eccd92d57f2197bf81d26636955a8c0873c9a38d1258999494141c1ccce170d85d4942a150a7d335ffad7c1d7cd69bc99722a146460cf786241ac3488191477b490a807282c3e82c2e526fd8464e48045ba2f19e89c630eaa311aadb11c932465922457d2223a146c6ed49b1311012e15db4a771361fe570a95c4fe36a6ef5546ad16c911295993c71c080d273cbc045a73fbc8c57a296d75df320ae42afc8de9f4d8d8277855f160276f1c5f1e01d5899684d8c33c5c922651c0187cd67179d2c8aca8dd2e5e84c674c826001105976b52ccd9986caa02dda410575bc3af7502eaca8b7434aa3d120b16d41b64ea7a545080ba2c540248661bf382c3a934e633168ecea17c5301934947098743a6d373515e5080cd0abbd1a2a6318f57d034a221f885c47d9e9f568505ef053507aa8c462784119a20d89cef75cd520900a921dc918f03c01205e4d4d0d0e0f765c7664edc9a2224816048ce51fcbf73695644b9247791621d148d22ad2bc7da0b0122dba2c263c9873caa842ecc902a2b9623ef3b04171a25079b24875be44a310b1d22384ee4cd9a15c8525512ae6312f983588ef1d61678c6a639c5829629f36aa6045cf9ad4091abe0f40596a2972590b10167331211a01655342feaec83de40d79ce01d84602ca9a2fd2b1d28a6f2a3a3c82e42175d65ca69585a7861b4f1b43134379625e4c614ce69e4ca013857947f3602135099a4c776624fef664c242167f551c5d108ddc1ca044da1e9a146a3a6bc2bc54ae0d50169f2b46e5c2138561c93529088bc5321a8d0a85a265978f8409103f77ff07b18ee72bbd0e314ac1db972d3f98abf8b2d0f3e89692788952cc469e0e8f093eeecf969f2a5201a35f1428cf16ab7d00cae69fcc216a4f509e7d004a5707801239b8509b814096dd543da44034fa43411ca59f892b08aa7bfe314a0e2652c197f0917487a58431d94c24cee129e11c3e077e10c3a09e58e5e90c6171589e3ac961707ab093a84ccd8b1c9c022555997ade8ad7510a0482965e685d1f94308fdec41ce63144c88a92734f1428eb83d2991652102d4235b5841d11c225a0ec2aa02c3b5d4681d2e6b6f91e94ac2079cd3ba1d22b4996dda941c9e7b7a3c70767cd17cc390773d471ea3a17cd858686b668d15a19f758be1201f6e9153ca9808981e3d5a3999141f8452e8e972019df972d43616e9408352bd343ca5383f3f422b8c81825cf911c8ccaa893a30bf201280fda73be2a4f45382c464234024a024a02cac6330a3a8d23e0206048eb5c1bd48ab3de9debf2202202caead43b221df188d49b80b26b83b22b5f47494440494440f9586230180909091d72678e3551ba374bc66733da1b94471d59df542421ca2c4584685d16949e7b193d4123ef17ebeaa06420b56ee1bd001d78aff769a3ea863342c463b63728c9c99c4e0c4aad56dbe001a1d7eb6b4fd26834f8c1f78ee280cecc7ce8f5384c815463f91a21892b264c6cec3bf6380fe9ea3050e2a78fcda7b3b80c36dffb403c1a83595dc8a9ee766462129dc9f684e7622f1a5716e9797e0aea335af0141c3a9dde21a9b754c09407b118745a7b83f26c79ea3db70ef1c85b1889fc0e947171710d1e10393939696969de5154831bf28eaad56aa7d3494ee6b4480281a01537f9b79f4c665bae7d7ffda873791010a9369e0eb57d27cfdeaf2a3a855f4496305855f8a52c6bafca783a283293230d55169e084e2d57188e84a455008e21e92e4dc9795946155f1ddffc0e4a1c722121211dd037caf0dccc436bf6af5dab37b8dd6c2ab714212c0dddc2886363f972752b0e90c242d3279fd065b2e4a95325dec21d3b22d7ae0d6ddb03a6a0c0387dba74c102f963b6939c9cbb73a7ae9381323737b74d7ec659c290f0f26b0869929d30b141858686fa0f25f36c7b52cbbf6af00532f59ff0141495c35344edae7e008ae721782965eae273c0a232ff78a8ed52354c399e7bf0132dd4832cd912b524ced4b29381747a7878387e4b7cbf5fce16ab6f574688db3ff56e5ac1c18953a64892930d4141f12a558a5e9fe9f9313315cbe5c902016c8a09a3b1b1d94c667446463e8653520c0c4634a0833adbb747b258d11f7eb84ba94c898ecec2d4f9f3e5132688c4e284ac2c4f9a8fb98c460f834343d3349a5494a7a7e76140ad4e2df13c2ad82414c66141682a22221d0321214940365a4378d9bd6a95e67fff772526d1685128cfc9294c48c8d9b143979696979999cfe5c662def0f074b4cce1c400df98252c2c0df5d12c02c37c7e9cc100c7657aefbd1dd427ea34a0843ae467bcab89c160c031f90f2853cbcf36f6a6ad4781325d12575cfd2852264ba4e0ca3de54cbe5859f0853c7b1ff5f608801230f5dcbf2fd7d1d9cdba7d1bbfd648f93be4c9de0772e4e74b3441dc763f99e3301b9dd64244838e72e6cce0ad5bb5c0cddfffbe76f3e68877ded90e902d5fae1a368c376f9e6cc0003640f3ecb31b5007048c8bcbfee73fd76dd912316a942035d5f0c4130b014aaae4adb7b6a126054aa06df56a0d2af7ec49a3b299c993c5185ebc58f9d7bfaedeb429fcf9e7376229438670e7ce950d1fce5fb448317b76c8fbefef0449376e0c1f33463872a4002b43ade1ead5a17ffef32a40f0b7bf5d8ad540b3986bc912e5534fad05dcffefff5661e9fff8c7da59b382d1e0b46952acd2e0c15cd01fcda2fe071fec5cbf3e0c9f054d7dfcf16e9d2ec3a7a0345bcd569715e1bd53d871d4e12969f68d8cf9f9f92d7a180151cbcf73d1626363fdaa2bc70b4af8ca8cd213b5832b103de4f5d83c984779cefedd9ec7eb1dc630832b042b3dc3b987c431055c9916859ce03094203d47ea4d63b2ab33f1c321e9950c4eb34c228bc582d368e92d8c6db47776d39b9d533d0e28bf2a4fbdbf27f27e2327737af4c06112055076ebb603a3c8a32966c191c185fdf2978b72730bfbf563f5eac5006ef2f28ac68e157efa291d40ccce2ea040f9c107bb30e3c489221452a00443d11ac8b56b574daa0b50ce9913121f9f036f88d1eedde1e5f51846e330922fbfbc090b05da30095c7bfdf5ada02a084ecd0bb708162725e5fee10f2b309a9e9e8f3a4b97aac04d2cfdf9e737a0f05fffda22952682ad58d5fefdd968102d8c1d1b049f8b0f88427c4054c3a7800bf62d282dd58fe7ba5febb906f73de1fcdad982442c2f2f3838983c2bb43dc4e1705af1ea0f9f81b2c0eaf287cb8370ec89c5e256bc02e1871f7ec08f9077f4f8f1e3858585de5187c3b167cf9ea65bd0c9b9f16a7e339f21d47e67bda74f976edb16098e00467c7e2c10269325c1b24d992206193ff9840e20ce9b274712fdd453eb12137360d3d8ec18e009e93305ca679e598fdc166c5528922950c245c28aa24e7ebeb11628657540d9bb3773ddba30a0194cf48272f972355ac05ac17836084a2c05586430f47ff8c372fc8739ad034aa070e8501ed61311159509a46ed8100e7452cbf5b5a3f458faa38e3a0f8071df73b7e88e6faa2f39232343a7d3a9d56a552d452645aa1e2a68446a4d48681442ae895011552b3c3c3c2121e1315fddd7454049a7d3954a2530d4d219eb3c73082bcf66b36bff4a3db24d9ff5511e76645f7026234a1bba8e52248a07a700cab7dfde8efff077f84a1614184146e4ada02452e7d0d0d4356b4223233330acd767ae5d1baa54a6141599c0a098986cd846e01278a5ba172512cfcff3ca95ea71e3826af7840270393985d4a91e000e5e0f8d6fdba6c582b0382c1775a88e4b64d9a86034d674266664e46fda14017b8b75a08881f5c45c582892fd2d5bb428041c4152ac21e635998a85c278ac159a452348e701cac4444fa72aac6847f4515a4aa867be7aa3e29b8a3659aaa5cce2beedb6945b1e59b3c8521ee5bea373df4b765e20d728f8bffc0d94801dd29a0eb985313d42581023e634efb9bfed7732c7682c869b831d1b32a4cd1681d6e028e11ffdead8034929d476c0c91cc711c7e3d8c9c6e43ce7e9f72c3f57fee86b142ce5ba3df7f1c54b765e2418ead4a01489441dd24781bc1bbed2ffaff122078f3feb11a0f4f454dea86a633b596a01733de4bdfb68534940d94941995f0f946ab57a775792294e5c9116c263378bd10a85a22d526ff2f4a00e02e5cfa6f2de9eb6b293de270137c7541250762ea5959da640996773d799949999e9ffceae0d75c6a4be59d1ac3e4a1a8d969696d64e2773887c044aca547aeca4b90d9667b6992b7fa8a4de0b5875abaaf2fb4ab3dd4c401910c27e34d702e51eaaa4768da8a8a8ae7309843c88a591b01f790b23368856ab7d9ceddef4e541443e02a5c7541e76b4e83d108f6eb0fa7c7ae9b152d2471918325a1cb1aeeb31ae1b51ee9f28504657ddc46852bdbd969292229148ba94b56cfad2a5a4a4a4c7fd363579c139511b8372faf4e9ffd12aad5dbbb69d41790f5fbc24e7d7646ff9b3929d17eadd8d733fd77ea0c1cac55d403f54c6dda9d2959a8b9aa8d3265bfeabf214e2287d07ca4993263dd12aad58b1a2fd40596429d3b9efe25b9758f12dd95bfe2cef4f9a37e25c578adba4bfa673ea8a2beeae3baab4fd9f1149fa28092809283bafa96cd44e125012501250761828615e0aac1506db5e836d9f6f22cfb607abd7e6bbc46e36b96d79fb6c061fc45e9bc1692d6c2bd7576875eadc35a632ae1276d2424049404940e947a03499ad0915df51a77d7c1951eebb196527da707f54580b6f564553c7bd6fe2de1edda9b2f4b65aff94f273d496c9711ceae25f2d024a02ca0e066571bdeb4e32cabef43122bd013ac349b5f941efcbf8c91de530b7cdb5cad42da7b1ae6bc5662b012501250165478232cfe64eacf82edf56e5c525ec644781b2a5ee096b6c35173716972a127c0fcabb6e5db9a5cd1eb1015399e3384cbe5a0494810cca3163c6444444d0e9f49494944d9b366dddba75e9d2a51c0e47ad566767673ff3cc337ffce31f3332329292927c05ca52ead23cbdfba7f8cacb54c0b05056ce8bcbf8caef3b1094d92de1c25e9b01c9756371cfadeb14a034994c8646949357949b97dfd8d40e7fbd0f7e8d8e95667d559edade71bb4a7f7f8feebc3365bf3dd7af4059692df8b22cc3075bc06771b63cf5a823cb6e36fa0e942fbcf0c2b56bd766cf9e1d19193971e2c4a953a7f6efdf7ff9f2e5efbdf7dece9d3b29322e5cb870e8d0a1be0125206832db635d571be7d4fd24e7d7714d55f02350e25086cbf877f5556f0dc6bf3b225a014a8d46d3bafc63d5aa551d4849d8f9af2b927cbc79b15bf135f60750e2e39f294f03beffdd41475abbc66db7de6dcbf31d28c3c3c38b8a8a1a04e55ffef29769d3a651a0fcf0c30f7bf6ecd9fea0f428ce75a5b1732969e5678c1647677194f831c71ebde04c6eacc2779d24f56e3528712c752028613aee54ff50f9382e5526f803288f96660524226bf7b6b793afac0bca0913261c3870c0f360ddc8c837de78a3acaccc66b37dfae9a76161616eb73b39391918b55aad20697171f1f4e9d37d03cae212737189c51b06fbbe28f71d0a915405024a02ca661d7816e3bd8ef053df57c6fb0c9476b3c9666ef8e1b5d75cb1810d4ac417a599be00e56f7ef39b3ffde94fbffded6f7ff7bbdf61f47ffee77f7efffbdfffe217bff8c31ffef0a76aa1fc4f0ff4eb5fffda37a0ac23a3d961b43c342f05caf0d22b1af345df47527e69762d190c0693c9d46a505e2f0fdf9f2d77a686f82cca524392e2a262aa151b1b9b9e9efec8bbeb0828fd16947b6d865b55fa13a519f6877169359b7eea0837ede338e74ce98a67bd9b9b9b977d2d084da23339343aa323e22131180c8140909595d50a501e2b89910a981dfeb086d0d0d0a6594940e9b7a0dc673350a3b7aaa26be31236b34eb7c355bbaa3c7a27625f12f3a7caf0ba5dab6eed9e4406550171a148faf8db018d9cc811a0e5af0ac4eb660cbe591e5aa742f8ee79cded91ac08bb5eaa6e60118d7fb908284bd4b199fef66c18a150d80a50c66b957ef2601bf86202ca4e01ca2fcb3228027e5b9178de9952e70a332f2eeb83f2b421e8b5e7ffc15a3e8eb97cdcba9983efb8221eea90a98a5838aecfa4411fa1c282b1bd856b273fe64688e12cde306b086dc9182cee5645d8d8cfdfffc1a6ac8b396373715caadf21db3c8380b2650a0e91fb1b28612d8b8a8a9a06a5b9a4c4622eae1d2ab9d44fd63f2323e391a0fcd39ffef4cf7ffef3ef7ffffbf3cf3fffb7bffdedc9279ffccb5ffef28f7ffce399679e79f1c5177ffdeb5ffff297bf7ca15a0494edfab980c8a657e06655f417a599f54f648deaf31e35b0624a7f1d63c1d0cfdebe6496c3a98deafb5e9260591c778964c35480f28b2cfe8114161837ecb3771205cbe68fed6d8ed8f2b52918789d3cf8632d7d3ea8ba7dc1c82983bb4f1af4f18ce19f602eb499235b3b67d4674b27f6b36ab782899be60cbb57a5453967e58453b9c299233ed9387be8d4a13db05cf8d932fd8e517dba8de8dd6dc3eca1a8f363b946b57dd6b8fe1fec5c34ea4cbee8ae2b02d5a60dedb163e128d1fa29a8b0687cdf375e7c0ab3d822b70538285dd75d15df55b449848485f82128ebbf28b13628f1a53d5d9676a32aa676e895824e04cae1c3875fb87001f6b3aaaa8a7a43d6ca952b31292828c866b301a0fffddfff9d9b9b9b9090e03fa0bc59a9b5244823655c8d94e3b3504ab8410f141c1c1c1313d3582f76ebf44d45127e00a8a87ff50ff878b63c15c75e7d508eecd32d68dd64c4fa5943e02843364fff324778d9aa08de341d53014a90f1bdd79ebd6c9153f5fb7ef85a45ec2ea4cca024e0085b076c0df9f4ed7385924369ec95530788374ccd0e5e3361c08747d2b9fd3f7e9db77a227bc5f83e1ffecba2dd0a50528de8590bd3c42b01cae2b0cdf7aa22e03473656ba94937ca34538674c7806ccb8cf9637ac1c662aec983bb63f6d05d7391b353744605c057b06652977094d48bc2db24e43abf73940c3afdb025e55cf943f14df5457cd4be3ce4c8f1dc6aedd6e1f0f546b492df8940f9dc73cfeddbb74f20104445458d1f3f7efaf4e9fdfaf5032bdf7df75db4f01ffff11ffff55fff357ffe7cf0f457bffa1575eaafa32f0f2a4ad306f9c3e6c5166bc3cf556629aab0165071acd635401422a9bb83eaa7ded58eb29b397ccba15436e5f5ce174998cbc6c9b7ce3c992ba44089b868f430b18e0345806211b47980ddd04fdf3e9327022837cf1d062f690add846a95b1bbe78de985a908837cdd25b30c800307816378c6efad0a80f294c1b3144bc4d648c6823aa0447a0e478975436b25619ba3d98bd2c52befe3fb521541ad9b3d721bbf1a94b79ca1f7dcda400665f99972abcbda26219549fd1094df96eaebffe2ddaa8a3eeac8f682f244e9433c0a0909e944a0444ead52a90c0603bef6a3468ddab265cbecd9b3172f5efce1871f3299cc975e7a492c166374cc983113264ca02e26eb58509a8a0af81c869f7461b7d5837beb883a9973b716221b3b99b33f99f5cc93ff0756aa77ccf616c21202521ec8ba2246f47af7a3375f9837ba17608412a4de547dcad3c1392e1adf0729f0fbaf3f475f3a76e39ca1f09e48c0678dfc744cbff7c13ec5d6993386f79c3eace7eae903af3a3c278e168ced3d7f4cef24e1b2133982979efe2bb2f285e3fac0cf7a4fcb7841090fbb63e1c8b19f7f505d61ca35877acbbce120efe2097de146a93351cb267d0eeb0a3a5fb6287c07cac99327fbec5e8b36efa3944afd0e9448bd1da61cb72daf4e54586bf2f10000e5d0a143e3e2e266cd9ab56cd9b2dffffef7482ac1cd279f7c127c4ca8167e44916652c3bd7af5f23d285dd6fc3db63c6f9419331ff9121bdf88cfe7b76df6ed158eb16a44d6bdeeba4147593f60092f1aa51d75710f9ce9b605231eebc47a7b83f2719e7a4f40d9cc3ecada0a0050faf9596f6cdbba17c4948533031d948da93e281d51db33a5abbd11b66bee7fffd76f7ef18b5fc0e8d52ef74d30968dfd8f5ffce2b517fea1672d6ce9bc3e75943eed536f0b501a2da50556171562a98c809280b28ea80b65bead48fcda9944c597d6380601e583c895af051c0320be290e21a06c5806dbbe38d755dd9efb5470e53a024a02ca0641e9a89584161414f8c90b20fd0194011904940f29bdec64e49e7fc7baae27545e42086461049404940494cd01e51d97f6b451e54c0b71244b032ff2e255fa7a8a8e8e4e4e4e6efafb18c8a0f43e8d82f4511250125036079417cd9a3029c73fba1f7c2d369b1d1717d7a541191c1cdc29eecc792428552a959fac7f76763601658081f25b7b8484cfdcdd8545a3d1e2e3e3bb2e28232222fc6d97f078bca63f4283a04c4949c1beecf0950f0a0a6afa51e404949d1194993ac9ee2e2f2e97db8ac7ec07082891e48ac5629adf08263f2d2dad15a08492929290808b3a48d88c80605ede239e149d989838bc55c22208283b049456b351c86313503eb25b29904159527d1d684e4e4ea61f282b2babe9a4bb6950121150b68b8c856cd6437937329716755622d5a10544e7267ee6bb2e283b9d08287d0f4ae45cc8bcfce1bb0ae7de4eb730362693b190f530282365dcab65e12de04ba8e0825943404940e917a0b4994d6e5bde3ebbc107b1d76668c317d5fa3f28a19898980eef0566301829296df920ee83f6dc238eeca6639f25a38ea3848e18142a315bafe009aa6f8117f19851721e4685dc9a3be2654256b4921726e56012559f41a7452b780a119b809280b2c340e9b416deac8af6e5eb18efb97527cbd2bb0e28a1acacacb8b8b8d80e12169d9b9bdbb607d2dd665c497eb32282c7aadbed70344f71aa485518233e63524b054cb5989d15196488127d59e87980748286ff4581325b17742c5f991f2da24019a7e6efcb926b655c024a02ca0e03a5f7b1fe81f1ee3aff046580a999c74c83a004f884d55e323954901b254a0d179c2c52819e3f383c77701cca55504e5329622bab2de45993fab451c566d248ea4d40d991a0fcee518faaf693b7301250fa212891191c75643716fb2de96cd6438f98e3b2e8c0a235511a1ecc39982347c60d5f19afe6a74508bfb586067119b624cfbd2e4a31bb28569c1c2600344f1478ac256611f11804949d089447bc2506fbbec48a6f635cd77d16b1aeab29ce734596b2d67d049bd98423fbba2bf6fbca786f74c87bf208280303944dbfd7bba8a888c97ca88f5225669b13242060719c2422844ba3ed06318be325053162901129368b41cbd406a10ecc268f4d8f9471f3a2456c26bd245e82a904949d0094a9e56701caccd22fa8d13cdb1edd9e7b1df252ef98aa1b26b3b5759fe27869a6f709fe5474c87304ba1428cdd52fe4809d3fecc8f6411cb0e7d67e7aae5f81b2cbaaeb8232d979b143284905cc6ceb3e85dd6cf43ec19f8a1f2ae30928db15945f9665dcf7ed0f12b2843db63c024a02ca0e00655af919102abdec14325f445ce5950e04651b76957ef7f0bb460928db169436b3e9b65beffb2dfc6d4522012501650780d260db1bebbada81706c3f50de7169bf2c541dc891fb2cf6652bd293e312ab959494d4b617aff8152803f275b5049404944d09784aacf88e0abdfba7c000e5296bacb2a32fe5a5d1689191910100cae3a599487b6fb862aebb62a9c07087f402135012507618286b2bbef2fbc00065a2ce2f1eb346a7d31ff95c8c4ea16bae587f78ec360125012501655b825225f7972710b7e2092b7e289bd964af1515d642927a137569506a2c17250966714c81ef4315191f5e4b111111c9c9c98f7ce401bec327ca32aeba626b4794524040d98e071ee9a324eacaa0d4151ea0b3fce8e6d3e674f35177e6dc75eb7e72ebbd11ade41350b62f28ddba0b668d2b3dc499eabb284956c63c507c7cbcc160f01f500a85c2a0a0a09f6fd7e1722512897794c562858484f8c3c3a40928db40324da4bfed0c1c944d3f709002e5a9b27487d9e80d79483001653b1e78666365869cc9a075f8b1919a9aea27a0b4d96c4ea7d33b9a9e9e7ee2c409ef2832a46fbef986c3e11050060228c9cbc508289b2553a144c0f287cd0bd746526f024a024a024abf90b9a4d8522b8a0af23bdc4e526ac3279c1350062c286d7b6cae6baeca2b95ce0bce368990d010024a02ca3aaab4167c5f19ff63558c37be71e89874024a02ca4e024aa8ec64194c655b855c2727a024a0ac23eace9c9fdc51de7365974bb55d1694c5c5c56c3679b99847ade820ee30505aca2db6bdb6b68a6079300125016583a02cb51499ab1f1a64f6bc5c2c3ff05e2ed64c504272b99c5012b6baa0a0a0d380b26d45fa2809281b0365c0bf85b1f9a0c43e6530185d1c94111111add8c89d1894f95657b6e3281541c1cac000a552e92f1f242b2b8b8032c0400925242474d99e4a1a8da656ab5bb7d93b2b28b31d47f455b7bd371172e5bac000656262a23f5cdc8baf71735e4d4e40d9e94009190c069d4e87345cda6584442d3434343d3dbdd5af08eeaca0a45e059158f16d7ad9298430441d18a0c48e8c8989090a0ae2759c6432594e4e4e0074c8105012b5953a3728bd4fa308983e4a22024a024a02caf602a542a1f0375032188ce6dcc24840494049404940e92350a6a4a4f8db7dfb2a95aae98fd01828cd25251673b1efa2a4b8eb80121e9fc5f28b5b18854261abfbcb082809285b094a283535156c523c905e2d0957052b3a424aa552afd73fd22f34084abbd978b932de976fbfba55a53f68cfe922a0049bfc24f9d06ab56df531092809285b00ca3afaaa3cd5cfbfff0d82f24c799aef9f9678dbadb7994d5d019490d16804a4241289b88324954aa3a3a3dbca4e125012507645507e579148dec2d8aea0aced2e3b446dfe3109280928031f94572ae370a07be366553401a56f40193022a024a07c486ab57ad2038d9eb660c8ccf563a7cef596d068b4ce05ca03f6dcbbee287f78f5150165d701a5c55c7cc491fd6d45e25557dc35576c60c40f95f1e79d2955b67c024a8fb66cd9f244e31a306040edca67cb534122eac8b8e84cfea132aee938539ee6e38f632929aeb41660256bc7d58e786b2001651701a5d56cea90be1ddfc43db7ee6869160165cb40e9b216e037133f35c86d9bb39591f39afde04299efaabfdb04940494ed01ca9365e9814ac91a56ee69af2339604109ea955a8c081c3d97eca1270a554dc7917c4d7a5a5a7e7e7e8783f29e5b7ba534eca245e3b3386f0e2d3264e4542b3737b753dfe59d959595fa4087f335178dd2ecf4246a343333b38b83f2c7aa98c00625e2cbb20c02ca16809262257c6545490e97456ffe65c06d75bf44eb74be343e51c3a7d33af2e279369b9d9090d049a9f1eaabaf3676843cf7dc73010f4aa7a5f0a823cb6a6e2037b2994d77fca34fbc5de3bc338580b265a03c60cfbde68a3d658b6fd18d65466347666a99b19acefb70537fd04b2fbdd4d811f2f4d34f073c28ab6cf9188073042e2d0fe3b23e282f1a83a3980b11e9e295d74bd575d3d82a6daa68055501713095fdd87d88da7d494cab76eb5d57c4891cc188deddea2f94b5627c335bc3bcdf1687d42fbfe04c26a06c19280f3bb2cf94a7151616762250aa15e475b504948f0b4a6fb7fb31e0f241cf7b7d507e531cf2e11bcf270b97c77217cf1bd3eb7645581dae6d9b3f62cdf441a8c0583656b876f2638252b47e0a67e584d09d73564ce98fd199233ef9c1a66c756b00ae60cd2402cac007258ee083f6dc8bcee4da11a91012501250b64815d6c2db6e3d1871bf3aea9fa5a4dc6583a9f7a83eef5103aba60ed031177cfcd60b97cc3298b54fbbbd92245816c75db271f6d019c33f39932f3a5f28a12d19f3e64bff0cde341d8ccb90acfada14bc6ee6e0c9833fe6ad9ef85365386a7ed6ed95813dde1cdeeb9dcd7387a14dcd8ed9a8397f6cef44c1324079ebbce1d4b2d0c2be642626cd1af9e994c1dd41cf1fcb43cbf43b46f5e936bcd7bbd387f5449dcb16057de998719f7fb07adac0bd490c409cbd72fcd421ddd7cf1cb276c660545834beef1b2f3e85596c91db0828db0094269349ad564b9a27ad56db1ef74e34a883f69cfaf774c7a878049404942d92b9a4a4e9fb14eeedd19d2a4bb73704ca91bdbb2d18d767dd8cc1c01072edf0dd73911d8389ea1db33115a05c30b6f7b0cfdef9deaaa0ea0fe8fec6570562d404b96e3a432319f301acee6fbd78365f74288d0d564a364c2d546f1cddefbd8ad85ddddf7e11b3cf1fd3fbbdd79e2b09dbec05a58eb12057b616a0443a7fdf1d99a75817c3594c4dba51a69932a43b06e061c77efe01d60dd506f77c2b3b644d4ad072945f75a8e04c89a36c3d28070e1cd82028fdf6e35077e69c2d4f45c6e40d854c4a404940d952507e5b9178a5320e71dd1553e7d2c2af9d49d4d9f0461c65b78ba660a4c0f7dd5a8cfe605320dd86c5fbb624840225e266792835b5b60345a0a625622b1039baef7b67f23ca0849104284da19b50ed483a77c5940167f3c50847d476000e59fc85222950b864623ffc07015d71bb91e0674857a58957d601a56ccb0c2cfa8251fa658ec019b32b5db22a6cd75c00fa66b5f7448532fd4e3859acd8f92209fc2c01e5cf32180cf18dabfe171ba00486aa9fc793809fdca60369afb92340495e2e4640d986f2f6515288acac75c1507d50ee4f66f578fb25b092f28f54a8b6cf0ad9341d03775c11538776effff11bf346f7bae50c4509526faa3e326e8c9647ef5c3ab1dfb2499f8fefff2167e5f81d0b470eeaf99668dd147070f9e4feb08d59c1ab678ffc14c15d35010404f230e3d2499f9746ed3891234076bf6bf1e845e3fbc4b017ddae08af03ca1fcb35f22d33c6f5ff00b4adae10a6d83a1359fccaa903805d4f97823374e7a25113077e045c5eb5ab08285baf724be1f795f1575d71cd7bda98af2f3827a024a06c0f50d6476463a0ac13f065c7b3f89be60c3d6d08f2fd653d40e4d10cae2974b3b83ab36e751050b646567371a9a5e8b451b52753d67454642812e2e3b3b3b3092809283baf1c16636523979dd70765027f297fcd246f6c9937fcb7bffe1536d4d8cfdfaf5dee9b5838ae0f16fdea737fa72f1ddbd279cf174a08285b2f8bb9789fddb0c79cc16234f7fa6d8140e0b30bce0928db43ddba75fb63237afdf5d74bbab01a4cbdadda6d0110571d24f57e3c125d73c59eb425f8e7e5410494441d0bca800c02ca16cbcfafa324a024ea1050de704638534332b4c238153ff042ab14c9ea49a9546ab5dac7e958eb12a06cfe7bc7daf0dd78ad03a55c2ef7135006ea2324ba38288fe629f86cc6eeaeaab0b0b0d65d281df8a0c476d1ebf5e1cd537c7cbc2f7b06ea83322626c61f8e27168bd5f44bc9893a2328cf96847158f4dd5d5b3a9d8e80b2015096549f0aac7d51778361f7f9dbb51a0425fc6c6868289bcd66769c0402416a6a2a214be08132214cb4bbcbab752620c04179ae3cc56929bc55157d6f8faee9b8e28af3870bce2915151515769c3af6417344ed246b8991c76111504269696904943fabd462bc5491d0cc279cfbc905e74444eda46263219bc5accd0b2e8b2e0f6a013af91c46b03010509b98984840d9c00fa92339d8a017351dd95192f0b0b00eefa384ec66d31e5bde7e7bae4fc200c76d2614e902321515b2980f815225667f670b6d41ef9e9c7bb6584d401968b29b8d5f96651cb326d39afdbcf00e3feb5d612df4f11b6befefd19d2c4b271c090039cc4687a5d1b018f3eb80123a6250246af8300a4a311bdf12fccfd105e54689c0504ca5d376472b78989a122e508ad8547d1683869228398f803270fa282f57c61f30a775a2eb28cf39537c7f8dee4fee28fca810d07462445a8cfbec867bf59edaf7d083292b2278f54e791fcd531cc891c7abf9278b5480a384cf8c55f1934205a78d2a4ccdd605edcd9245cab8f89f1fed391174244f911519644e908474e61c9c80b22e283bdd05e7e42d8c44add0f1d2ac47bf67b42150c22152170cc5a9f986285151acf8ac49bd3f5bfe4369180a0f632ad33355c46382a118c0d43346159b4927a977a081b2a8a8884e6fee7ef5fdbdde48b47fa88cf74687dc6446401930a0bc5219f74d45528371d611cf613d74a9b998cf3c57a23994abc8d00a4f15a9c2a41c184918464b82e47b47985ac22e8c11c372c260ba3365a8230f62c178268709f6e7c835123601654081120319191909cd93ef9f1ee40f41401930a03c68cf69ac0e1c03f3e13e4aa98099122640c60d148a781e868a79cce450419c8a9fa0e1874a39288908e1a28e5ec1a3d3690a111bc693c9a0a124ac7a2a0165a7175ce4849183a68c1a3065ca14ff5c43abd9546e2972988d18f0c6a54a927a13f908945d5604943f6bead4a9d45308fff8c73f76a2d5267d94440494049404948f06e5cd8a8863f9cabd59329f853b4b9e9618ebed7fc8cacaf2d91bd688082809283b52cb962d7bba5a6fbcf146275aed13965885a8832fbca0d168111111849504940494810fca4eaa449dd21f8e24b0322f2f8fec0e024a024a02ca8e97d913c5b5432527afab2522a024a0247a20bbd9f46559c655576ced88520a08288908280928896ad4e07594314a1e01251101250125d143a024efcc21ea58502a954ab5fae76702492492c8c848ef288fc78b898969febd6d0494440494440108cabcbc3ca3d1e81d8d8f8fafaaaaf28e82a1478e1c61b3d90494440494049424f526a9370125012501250125012501250125012501250125012501250125d16381b2b8b898cbe5124ab6eed826a024a024a0ec12a084341a0da12487c381b926a0ecdca0542a957e723c656565917de4ffa26ee83a5e9a49811207557549c332180c0176febaa5a2d168b1b1b1add8ce0494fe05caa4a424eccb0e3f9e040281cf5e8941d46ad9cca6cb9509575d71de17d2fd58158dd16f2b12ade6869f69929999c9e7f3bb2625190c865eaf6fddd35e0828fd0b94d88bf1f1f162b158d071522814b01e6407750a9d2d4fad7f7fd797654d759b984ca6e4e4645d17535c5c5c7e7e7eabb73301a57f819288a8452ab518ebbc67e956959ebc53b3cd45404940491450a6b2693b4944401920a07459f35178b22cdd07812f1556a3b1fe2ca24e2187c578f781a924769280b24b80f291afb16f8ff8a622c94cf64740984a62270928bb04282f3a937dff72b13beea8524b11d9239ddd54123b494019b0a044fe6b339bbc415e574bd46a5349ec240165c082f28ec708447be39e5b474049d4988283835736a2f5ab97ad59b5bcc1496bd7ae25af8a23a0ecac3a68cf01a16ebbf537aba2bd414049d484860e1dfa44abd48a9bf6880828fd57df5590d49b88809280928880928880928092e83141f9b545638c13a745087d16a911c250b542552d8d46131b1b4b6ef426a02422a0f45fed2bd473591dff2227994c663299c8ee20a02422a0f447e9c3e47ef2a8959c9c1cb23b021b944a65cad6adda9c9cc2f8f816efeb9898ec0f3ed8b96b97aea4fa492e5a6d3a06de7f7fa74693eaadf3d9678cfcfc16a4269f7e4a974a13070fe6b258d1b5cb93927233331b7d9e456262ee8b2f6ef28e4e9e2c6ed14209283b816c665399a5a876a86512f2e05ea2a641f9ca2baffced6f7f7bf3cd379f7aeaa937de78e3f7bfff3dfe631825cf3fff3c2afcbffff7ff30fce4934f36014ad0ad7f7f764c4cd66baf6de9d99356506004ece6cc09e172634da6e2f5ebc3b8dc98e5cb55809477169d2e73de3c1993196d30146196679e591f1e9e86f28d1bc3fff6b73562710280b57d7be4a2450a8a9b33670683590241dcfcf9f2909024ef154a6873f162a548148f12acc0b265aa75ebc272730bdf7a6b9b5018ffc927f49d3b756861e142058d160588ffe31f6bc78d0b2a2a3201a0d3a74b43433d2c0e0ff7548888488f8bcbfef39f571a8d26cc05e8a3e5ddbba30828034715d6c2ef2a12efba75b52346c927a0246a1a9430fb49494960dff2e5cb0f1e3cf8f2cb2f1f387060f4e8d15555552841855ebd7a1d3d7a74d0a0414d80322fafe8d967d717169a3efa681740969191fffaeb5b81b3debd992c56ccdb6f6f9f3b570668befdf6367013f5c1a037dfdc06c73760001b34c42c98313bdb730e10d59e7d76437a7a1e40b962851ac47cf2c93528ffe52f172995c9e0a950188772cae8198dc5efbcb35d2249183488131d9dc560e8b76dd3bef7de0e40b936283117dc2e001a1999f1d453eb68347d72b261d3a67050f5cf7f5e959090839591c992faf66502d6bffffdf251a304582bb44fa7ebc78c111250068ea80bce6f57e9afb962bd11a514105012350d4a8140003f181919f9f1c71fa7a7a7a3242525e597bffc65686828bc240ce67ffee77f52e57ffad39f1a032592d9dffd6e1906c09acd9b234243d3801e8cce99239b3a550250f2f971707cfff99f8b6136511e1595f9ca2b9b51b274a96aec582166c18c54530016266100a05428928154cc4581124b59b8500eeb8a5980e612cf53d68b7ef5ab2568272bab00981e3e9c0f220f19c29d34495c1b94f0adc8c1fbf461eaf599cf3fbf51a54a0110df7d773ba0fc8b5f2ce4706250198da4a7e7c393fefad74b7af4d80d638bf631090427a00c34509277e610b51494128964ce9c39df7fff3d40999696f6eaabaf5a2c96dffce6375151512fbdf49248247afbedb7e13afff77fff173bb1315016161afff5af2d7079132688c68f1721f3fdf0c35dc89a3ff860a75a9d0a50c2a3211307c2a8bb7a80cb1e3d680b16788c248c676d50c2f4c100c2e5d507657272eed8b141b0932fbfbc2935d5f33468f853784918d2f7dfdf89b4ba7bf7dd3366483ffb8c3e7e7c506d5062412032eab0d93158b1b56b43b1d0d75fdf8235fcc31f96a3591422cb061f91a423f5c6fa63cd015fcc8b949f8092809280b2ab8392c7e361076ddab4e985175ef8e4934f6024c1cd37df7c53fb40f3e7cfa706944a65132773264e148189b0786010f805c787ac19192e260194f0744a658ad1f8f3c50fa0aa44929898e8e9b544b5b0b0346f77a746938ad41bd6323bbb00c9b540108772fcc730927a24daf8ef6da7a8c884255225587a7070525a5a1e2c2d1687420c00a9e0325a835b04a53115ed63004486b14505cc05326246ac33d60aab8da690c8a7a418805d344e4049404940d9d541d95667bd93927279bc86dfb4356b564878787a67dc4448c0a94e55024a024a024a024a721da54f45404940494049404944404940494049404940494049404940494049404940d98540a9d168c82d8c4404940494444d81123e8ec160743825838383c943310828890828fd14945056565644444458c7293a3a9a7caffc53b1b1b1f2964ba1509057411050061a28898888082889082889880828890828898808288908288988082889082889888808283b48c9c9c9ca078a0f159545ef4c0d17784bf2f3f3c926222222a0ecea9a3b776e1317bb69b55ab2898888082809280928898808288908288988082889082889880828890828898888082809288988880828092889888808280928898888082809288988880828bba6366edcf84a237af5d557636363c926222222a02422222222a02422222222a02422222222a0242222222222a02422222222a02422222222a02422222222a02422222222a02422222222a02422222222a02422222222a0242222222222a02422222222a02422222222a0242222226a6ffd7ffe28a0a64b8381640000000049454e44ae426082}}\par
Interpreter states contain several fields dealing with imported modules of that particular interpreter, so we can talk about that when we talk about importing.\f0
\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In addition to managing imports they hold bunch of pointers related to handling Unicode codecs, a field to do with dynamic linking flags and a field to do with TSC usage for profiling. Thread states have more fields but to me they were more easily understood. Not too surprisingly, they have fields that deal with things that relate to the execution flow of a particular thread and are of too broad a scope to fit particular frame.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Take for example the fields recursion_depth, overflow and recursion_critical, which are meant to trap and raise a RuntimeError during overly deep recursions before the stack of the underlying platform is exhausted and the whole process crashes. In addition to these fields, this structure accommodates fields related to profiling and tracing, exception handling (exceptions can be thrown across frames), a general purpose per-thread dictionary for extensions to store arbitrary stuff in and counters to do with deciding when a thread ran too much and should voluntarily relinquish the GIL to let other threads run.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Naming}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Discuss naming, which is the ability to bind names to an object, like we can see in the statement \f3\fs20 a = 1\f1\fs24  (in other words, this article is roughly about what many languages call variables). Naturally, naming is central to Python\rquote s behaviour and understanding both its semantics and mechanics are important precursors to our quickly approaching discussions of code evaluation, code objects and stack frames.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 That said, it is also a delicate subject because anyone with some programming experience knows something about it, at least instinctively (you\rquote ve done something like a = 1 before, now haven\rquote t you?).When we evaluate a = b = c = [], we create one list and give it three different names. In formal terms, we\rquote d say that the newly instantiated list object is now bound to three identifiers that refer to it. This distinction between names and the objects bound to them is important. If we evaluate a.append(1), we will see that b and c are also affected; we didn\rquote t mutate a, we mutated its referent, so the mutation is uniformly visible via any name the object was referred to.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 On the other hand, if we will now do a \f3\fs20 b = []\f1\fs24 , a and c will not change, since we didn\rquote t actually change the object which b referred to but rather did a re-binding of the name b to a (newly created and empty) list object. Also recall that binding is one of the ways to increase the referent\rquote s reference count, this is worthy of noting even though reference counting isn\rquote t our subject at the moment.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A name binding is commonly created by use of the assignment statement, which is a statement that has an \lquote equals\rquote  symbol (=) in the middle, \ldblquote stuff to assign to\rdblquote  or targets on the left, and \ldblquote stuff to be assigned\rdblquote  (an expression) on the right. A target can be a name (more formally called an identifier) or a more complex construct, like a sequence of names, an attribute reference (primary_name.attribute) or a subscript (primary_name[subscript])\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Name binding is undone with the deletion statement del, which is roughly \ldblquote del followed by comma-separated targets to unbind\rdblquote \f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Finally, note that name binding can be done without an assignment as bindings are also created by \f3\fs20 def, class, import (and others)\f1\fs24 , this is also of less importance to us now.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Scope is a term relating to the visibility of an identifier throughout a block, or a piece of Python code executed as a unit: a module, a function body and a class definition are blocks (control-blocks like those of if and while are not code blocks in Python). A namespace is an abstract environment where the mapping between names and the objects they refer to is made (incidentally, in current CPython, this is indeed implemented with the dict mapping type). The rules of scoping determine in which namespace will a name be sought after when it is used, or rather resolved.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 You probably know instinctively that a name bound in function foo isn\rquote t visible in an unrelated function bar, this is because by default names created in a function will be stored in a namespace that will not be looked at when name resolution happens in another, unrelated function.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Scope determines not just when a name will be visible as it is resolved or \lquote read\rquote  (i.e., if you do spam = eggs, where will eggs come from) but also as it is bound or \lquote written\rquote  (i.e., in the same example, where will spam go to). When a namespace will no longer be used (for example, the private namespace of a function which returns) all the names in it are unbound (this triggers reference count decrease and possibly deallocation, but this doesn\rquote t concern us now).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Scoping rules change based on the lexical context in which code is compiled. For example, in simpler terms, code compiled as a plain function\rquote s body will resolve names slightly differently when evaluated when compared with code compiled as part of a module\rquote s initialization code (the module top-level code). Special statements like global and nonlocal exist and can be applied to names thus that resolution rules for these names will change in the current code block, we\rquote ll look into that later.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 When Python code is evaluated, it is evaluated within three namespaces: locals, globals and builtins. When we resolve a name, it will be sought after in the local scope, then the global scope, then the builtin scope (then a NameError will be raised). When we bind a name with a name binding statement (i.e., an assignment, an import, a def, etc) the name will be bound in the local scope, and hide any existing names in the global or builtin scope.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This hiding does not mean the hidden name was changed (formally: the hidden name was not re-bound), it just means it is no longer visible in the current block\rquote s scope because the newly created binding in the local namespace overshadows it.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We said scoping changes according to context, and one such case is when functions are lexically nested within one another (that is, a function defined inside the body of another function): resolution of a name from within a nested function will first search in that function\rquote s scope, then in the local scopes of its outer function(s) and only then proceed normally (in the globals and builtins) scope.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Lexical scoping is an interesting behaviour, let\rquote s look at it closely:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 $ cat scoping.py ; python3.1\par
def outer():\par
    a = 1\par
    # creating a lexically nested function bar\par
    def inner():\par
        # a is visible from outer's locals\par
        return a\par
    b = 2 # b is here for an example later on\par
    return inner\par
\par
# inner_nonlexical will be called from within\par
#  outer_nonlexical but it is not lexically nested\par
def inner_nonlexical():\par
    return a # a is not visible\par
def outer_nonlexical():\par
    a = 1\par
    inner = inner_nonlexical\par
    b = 2 # b is here for an example later on\par
    return inner_nonlexical\par
>>> from scoping import *\par
>>> outer()()\par
1\par
>>> outer_nonlexical()()\par
Traceback (most recent call last):\par
  File "<stdin>", line 1, in <module>\par
  File "scoping.py", line 13, in inner_nonlexical\par
    return a # a is not visible\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As the example demonstrates, a is visible in the lexically nested inner but not in the call-stack nested but not lexically nested inner_nonlexical. I mean, Python is dynamic, everything is runtime, how does inner_nonlexical fail if it has the same Python code and is called in a similar fashion from within a similar environment as the original inner was called?\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Further more, we can see that \f3\fs20 inner\f1\fs24  is actually called after \f3\fs20 outer\f1\fs24  has terminated: how can it use a value from a namespace that was already destroyed?\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Once again, let\rquote s look at the bytecode emitted for the simple statement \f3\fs20 spam = eggs - 1\f1\fs24 :\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> diss("spam = eggs - 1")\par
  1           0 LOAD_NAME                0 (eggs)\par
              3 LOAD_CONST               0 (1)\par
              6 BINARY_SUBTRACT\par
              7 STORE_NAME               1 (spam)\par
             10 LOAD_CONST               1 (None)\par
             13 RETURN_VALUE\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Recall that BINARY_SUBTRACT will pop two arguments from the value-stack and feed them to \f3\fs20 PyNumber_Subtract\f1\fs24 , which is a C function that accepts two \f3\fs20 PyObject * pointers\f1\fs24  and certainly doesn\rquote t know anything about scoping.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 What gets the arguments onto the stack are the \f3\fs20 LOAD_NAME\f1\fs24  and \f3\fs20 LOAD_CONST\f1\fs24  opcodes, and what will take the result out of the stack and into wherever it is heading is the \f3\fs20 STORE_NAME\f1\fs24  opcode. It is opcodes like this that implement the rules of naming and scoping, since the C code implementing them is what will actually look into the dictionaries representing the relevant namespaces trying to resolve the name and bring the resulting object unto the stack, or store whatever object is to be stored into the relevant namespace.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 For example, take \f3\fs20 LOAD_CONST\f1\fs24 ; this opcode loads a constant value unto the value stack, but it isn\rquote t about scoping (constants don\rquote t have a scope, by definition they aren\rquote t variables and they\rquote re never \lquote hidden\rquote ).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Fortunately for you, I\rquote ve already grepped the sources for \lquote suspect\rquote  opcodes ($ egrep -o \lquote (LOAD|STORE)(_[A-Z]+)+\rquote  Include/opcode.h | sort) and believe I\rquote ve mapped out the opcodes that actually implement scoping, so we can concentrate on the ones that really implement scoping. Note that among the list of opcodes I chose not to address are the ones that handles attribute reference and subscripting; I chose so since these opcodes rely on a different opcode to get the primary reference (the name before the dot or the square brackets) on the value stack and thus aren\rquote t really about scoping.\f0 \par
}}{\pard \nisusnos {\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls3\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet }{\f1 We should discuss four pairs of opcode:\line \f3\fs20 LOAD_NAME and STORE_NAME\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 LOAD_FAST and STORE_FAST\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 LOAD_GLOBAL and STORE_GLOBAL\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 LOAD_DEREF and STORE_DEREF\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls4\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f3\fs20 \line \f1\fs24 \line \f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 I suggest we discuss each pair along with the situations in which the compiler chooses to emit an opcode of that pair in order to satisfy the semantics of scoping.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This is not necessarily an exhaustive listing of these opcodes\rquote  uses (it might be, I\rquote m not checking if it is or isn\rquote t), but it should develop an understanding of these opcodes\rquote  behaviour and allow us to figure out other cases where the compiler chooses the emit them on our own; so if you ever see any of these in a disassembly, you\rquote ll be covered.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 I\rquote d like to begin with the obvious pair, \f3\fs20 *_NAME\f1\fs24 ; it is simple to understand (and I suspect it was the first to be implemented). Explaining the \f3\fs20 *_NAME\f1\fs24  pair of opcodes is easiest by writing rough versions of them in Python-like psuedocode (you can and should read the actual implementation in \f3\fs20 ./Python/ceval.c: PyEval_EvalFrameEx\f1\fs24 ):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 def LOAD_NAME(name):\par
    try:\par
        return current_stack_frame.locals[name]\par
    except KeyError:\par
        try:\par
            return current_stack_frame.globals[name]\par
        except KeyError:\par
            try:\par
                return current_stack_frame.builtins[name]\par
            except KeyError:\par
                raise NameError('name %r is not defined'\par
                                 % name)\par
\par
def STORE_NAME(name, value):\par
    current_stack_frame.locals[name] = value\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 While they are the \lquote vanilla\rquote  case, \f3\fs20 *_NAME\f1\fs24 , in some cases they are not emitted at all as more specialized opcodes can achieve the same functionality in a faster manner. As we explore the other scoping-related opcodes, we will see why. A commonly used pair of scoping related opcodes is the \f3\fs20 *_FAST\f1\fs24  pair, which were originally implemented a long time ago as a speed enhancement over the \f3\fs20 *_NAME\f1\fs24  pair.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 These opcodes are used in cases where compile time analysis can infer that a variable is used strictly in the local namespace. This is possible when compiling code which is a part of a function, rather than, say, at the module level (some subtleties apply about the meaning of \lquote function\rquote  in this context, a class\rquote  body may also use these opcodes under some circumstances, but this is of no interest to us at the moment; also see the comments below).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 If we can decide at compile time which names are used in precisely one namespace, and that namespace is private to one code block, it may be easy to implement a namespace with cheaper machinery than dictionaries. Indeed, these opcodes rely on a local namespace implemented with a statically sized array, which is far faster than a dictionary lookup as in the global namespace and other namespaces.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In Python 2.x it was possible to confuse the compiler thus that it will not be able to use these opcodes in a particular function and have to revert to \f3\fs20 *_NAME\f1\fs24 , this is no longer possible in Python 3.x (also see the comments).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Let\rquote s look at the two \f3\fs20 *_GLOBAL\f1\fs24  opcodes. LOAD_GLOBAL (but not STORE_GLOBAL) is also generated when the compiler can infer that a name is resolved in a function\rquote s body but was never bound inside that body.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This behaviour is conceptually similar to the ability to decide when a name is both bound and resolved in a function\rquote s body, causing the generation of the \f3\fs20 *_FAST\f1\fs24  opcodes as we\rquote ve seen above:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> def func():\par
...     a = 1\par
...     a = b\par
...     return a\par
...\par
>>> diss(func)\par
  2           0 LOAD_CONST               1 (1)\par
              3 STORE_FAST               0 (a)\par
  3           6 LOAD_GLOBAL              0 (b)\par
              9 STORE_FAST               0 (a)\par
  4          12 LOAD_FAST                0 (a)\par
             15 RETURN_VALUE\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As described for \f3\fs20 *_FAST\f1\fs24 , we can see that a was bound within the function, which places it in the local scope private to this function, which means the \f3\fs20 *_FAST\f1\fs24  opcodes can and are used for a. On the other hand, we can see (and the compiler could also see\u8230 ?) that b was resolved before it was ever bound in the function.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The compiler figured it must either exist elsewhere or not exist at all, which is exactly what \f3\fs20 LOAD_GLOBAL\f1\fs24  does: it bypasses the local namespace and searches only the \f3\fs20 global\f1\fs24  and \f3\fs20 builtin\f1\fs24  namespaces (and then raises a \f3\fs20 NameError\f1\fs24 ).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This explanation leaves us with missing functionality: what if you\rquote d like to re-bind a variable in the global scope? Recall that binding a new name normally binds it locally, so if you have a module defining foo = 1, a function setting foo = 2 locally \ldblquote hides\rdblquote  the global foo.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 But what if you want to re-bind the global foo? Note this is not to mutate object referred to by foo but rather to bind the name foo in the global scope to a different referent; if you\rquote re not clear on the distinction between the two, skim back in this post until we\rquote re on the same page.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 To do so, we can use the global statement which we mentioned in passing before; this statement lets you tell the compiler to treat a name always as a global both for resolving and for binding within a particular code block, generating only \f3\fs20 *_GLOBAL\f1\fs24  opcodes for manipulation of that name.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 When binding is required, \f3\fs20 STORE_GLOBAL\f1\fs24  performs the new binding (or a re-binding) in the global namespace, thus allowing Python code to explicitly state which variables should be stored and manipulated in the global scope. What happens if you use a variable locally, and then use the global statement to make it global? Let\rquote s look (slightly edited):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> def func():\par
...     a = 1\par
...     global a\par
...\par
<stdin>:3: SyntaxWarning: name 'a' is assigned to before global declaration\par
>>> diss(func)\par
  2           0 LOAD_CONST               1 (1)\par
              3 STORE_GLOBAL             0 (a)\par
  3           6 LOAD_CONST               0 (None)\par
              9 RETURN_VALUE\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The compiler still treats the name as a global all through the code block, but warns you not to shoot yourself (and other maintainers of the code) in the foot. Sensible.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We are left only with \f3\fs20 LOAD_DEREF\f1\fs24  and \f3\fs20 STORE_DEREF\f1\fs24 . To explain these, we have to revisit the notion of lexical scoping, which is what started our inspection of the implementation. Recall that we said that nested functions\rquote  resolution of names tries the namespaces\rquote  of all lexically enclosing functions (in order, innermost outwards) before it hits the global namespace, we also saw an example of that in code.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 So how did inner return a value resolved from this no-longer-existing namespace of outer? When resolution of names is attempted in the global namespace (or in builtins), the name may or may not be there, but for sure we know that the scope is still there! How do we resolve a name in a scope which doesn\rquote t exist?\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The answer is quite nifty, and becomes apparent with a disassembly (slightly edited) of both functions:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 # see the example above for the contents of scoping.py\par
>>> from scoping import *\par
# recursion added to 'diss'; you can see metablogging->tools above\par
>>> diss(outer, recurse=True)\par
  2           0 LOAD_CONST               1 (1)\par
              3 STORE_DEREF              0 (a)\par
  3           6 LOAD_CLOSURE             0 (a)\par
              9 BUILD_TUPLE              1\par
             12 LOAD_CONST               2 (<code object inner ...)\par
             15 MAKE_CLOSURE             0\par
             18 STORE_FAST               0 (inner)\par
  5          21 LOAD_CONST               3 (2)\par
             24 STORE_FAST               1 (b)\par
  6          27 LOAD_FAST                0 (inner)\par
             30 RETURN_VALUE\par
\par
recursing into <code object inner ...>:\par
  4           0 LOAD_DEREF               0 (a)\par
              3 RETURN_VALUE\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We can see that outer (the outer function!) already treats a, the variable which will be used outside of its scope, differently than it treats b, a \lquote simple\rquote  variable in its local scope.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f3\fs20 a\f1\fs24  is loaded and stored using the \f3\fs20 *_DEREF\f1\fs24  variants of the loading and storing opcodes, in both the outer and inner functions. The secret sauce here is that at compilation time, if a variable is seen to be resolved from a lexically nested function, it will not be stored and will not be accessed using the regular naming opcodes. Instead, a special object called a cell is created to store the value of the object. When various code objects (the outer function, the inner function, etc) will access this variable, the use of the \f3\fs20 *_DEREF\f1\fs24  opcodes will cause the cell to be accessed rather than the namespace of the accessing code object. Since the cell is actually accessed only after outer has finished executing, you could even define inner before a was defined, and it would still work just the same (!).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This is automagical for name resolution, but for outer scope rebinding the nonlocal statement exists. nonlocal was decreed by PEP 3014 and it is somewhat similar to the global statement\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f3\fs20 nonlocal\f1\fs24  explicitly declares a variable to be used from an outer scope rather than locally, both for resolution and re-binding. It is illegal to use nonlocal outside of a lexically nested function, and it must be nested inside a function that defines the identifiers listed by nonlocal.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 There are several small gotchas about lexical scoping, but overall things behave as you would probably expect (for example, you can\rquote t cause a name to be used locally and as a lexically nested name in the same code block, as the collapsed snippet below demonstrates):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> def outer():\par
...     a = 1\par
...     def inner():\par
...             b = a\par
...             a = 1\par
...             return a,b\par
...     return inner\par
...\par
>>> outer()()\par
Traceback (most recent call last):\par
  File "<stdin>", line 1, in <module>\par
  File "<stdin>", line 4, in inner\par
UnboundLocalError: local variable 'a' referenced before assignment\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This sums up the mechanics of naming and scoping.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Byte Code}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The compilation of Python source code emits Python bytecode, which is evaluated at runtime to produce whatever behaviour the programmer implemented. I guess you can think of bytecode as \lquote machine code for the Python virtual machine\rquote , and indeed if you look at some binary x86 machine code (like this one: 0x55 0x89 0xe5 0xb8 0x2a 0x0 0x0 0x0 0x5d) and some Python bytecode (like that one: 0x64 0x1 0x0 0x53) they look more or less like the same sort of gibberish.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The bytecode and these fields are lumped together in an object called a code object, our subject for this article.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 You might initially confuse function objects with code objects, but shouldn\rquote t. Functions are higher level creatures that execute code by relying on a lower level primitive, the code object, but adding more functionality on top of that (in other words, every function has precisely one code object directly associated with it, this is the function\rquote s \f3\fs20 __code__\f1\fs24  attribute, or \f3\fs20 f_code\f1\fs24  in Python 2.x).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 For example, among other things, a function keeps a reference to the global namespace (remember that?) in which it was originally defined, and knows the default values of arguments it receives. You can sometimes execute a code objects without a function (see eval and exec), but then you will have to provide it with a namespace or two to work in.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Finally, just for accuracy\rquote s sake, please note that \f3\fs20 tp_call\f1\fs24  of a function object isn\rquote t exactly like \f3\fs20 exec\f1\fs24  or \f3\fs20 eval\f1\fs24 ; the latter don\rquote t pass in arguments or provide free argument binding (more below on these).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 If this doesn\rquote t sit well with you yet, don\rquote t panic, it just means functions\rquote  code objects won\rquote t necessarily be executable using eval or exec. I hope we have that settled.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A piece of Python program text that is executed as a unit. The following are blocks: \f3\fs20 a module, a function body, and a class definition\f1\fs24 .\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As usual, I don\rquote t want to dig too deeply into compilation, but basically when a code block is encountered, it has to be successfully transformed into an AST (which requires mostly that its syntax will be correct), which is then passed to \f3\fs20 ./Python/compile.c: PyAST_Compile\f1\fs24 , the entry point into Python\rquote s compilation machinary.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 You absolutely can\rquote t run this code meaningfully without its constants, and indeed 42 is referred to by one of the extra fields of the code object. We will best see the interaction between the actual bytecode and the accompanying fields as we do a manual disassembly:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 # the opcode module has a mapping of opcode\par
#  byte values to their symbolic names\par
>>> import opcode\par
>>> def return42(): return 42\par
...\par
# this is the function's code object\par
>>> return42.__code__\par
<code object return42 ... >\par
# this is the actual bytecode\par
>>> return42.__code__.co_code\par
b'd\\x01\\x00S'\par
# this is the field holding constants\par
>>> return42.__code__.co_consts\par
(None, 42)\par
# the first opcode is LOAD_CONST\par
>>> opcode.opname[return42.__code__.co_code[0]]\par
'LOAD_CONST'\par
# LOAD_CONST has one word as an operand\par
#  let's get its value\par
>>> return42.__code__.co_code[1] + \\\par
... 256 * return42.__code__.co_code[2]\par
1\par
# and which constant can we find in offset 1?\par
>>> return42.__code__.co_consts[1]\par
42\par
# finally, the next opcode\par
>>> opcode.opname[return42.__code__.co_code[3]]\par
'RETURN_VALUE'\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In addition to dis, the function show_code from the same module is useful to look at code objects:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> diss(return42)\par
  1           0 LOAD_CONST               1 (42)\par
              3 RETURN_VALUE\par
>>> ssc(return42)\par
Name:              return42\par
Filename:          <stdin>\par
Argument count:    0\par
Kw-only arguments: 0\par
Number of locals:  0\par
Stack size:        1\par
Flags:             OPTIMIZED, NEWLOCALS, NOFREE\par
Constants:\par
   0: None\par
   1: 42\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We see diss and ssc generally agree with our disassembly, though ssc further parsed all sorts of other fields of the code object which we didn\rquote t handle so far (you can run dir on a code object to see them yourself). Code objects are immutable and their fields don\rquote t hold any references (directly or indirectly) to mutable objects. This immutability is useful in simplifying many things, one of which is the handling of nested code blocks.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 An example of a nested code block is a class with two methods: the class is built using a code block, and this code block nests two inner code blocks, one for each method.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This situation is recursively handled by creating the innermost code objects first and treating them as constants for the enclosing code object (much like an integer or a string literal would be treated). Now that we have seen the relation between the bytecode and a code object field (co_consts), let\rquote s take a look at the myriad of other fields in a code object. Many of these fields are just integer counters or tuples of strings representing how many or which variables of various sorts are used in a code object. But looking to the horizon where ceval.c and frame object evaluation is waiting for us, I can tell you that we need an immediate and crisp understanding of all these fields and their exact meaning, subtleties included.\f0 \par
}}{\pard \nisusnos {\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls5\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet }{\f1 Identity or origin (strings)\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_name\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A name (a string) for this code object; for a function this would be the function\rquote s name, for a class this would be the class\rquote  name, etc. The compile builtin doesn\rquote t let you specify this, so all code objects generated with it carry the name <module>.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_filename\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The filename from which the code was compiled. Will be <stdin> for code entered in the interactive interpreter or whatever name is given as the second argument to compile for code objects created with compile.\f0 \par
}}{\pard \nisusnos {\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls6\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet }{\f1 Different types of names (string tuples)\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_varnames\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A tuple containing the names of the local variables (including arguments). To parse this tuple properly you need to look at co_flags and the counter fields listed below, so you\rquote ll know which item in the tuple is what kind of variable. In the \lquote richest\rquote  case, co_varnames contains (in order): positional argument names (including optional ones), keyword only argument names (again, both required and optional), varargs argument name (i.e., \f3\fs20 *args\f1\fs24 ), kwds argument name (i.e., \f3\fs20 **kwargs\f1\fs24 ), and then any other local variable names. So you need to look at co_argcount, co_kwonlyargcount and co_flags to fully interpret this tuple.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_cellvars\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A tuple containing the names of local variables that are stored in cells (discussed in the previous article) because they are referenced by lexically nested functions.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_freevars\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A tuple containing the names of free variables. Generally, a free variable means a variable which is referenced by an expression but isn\rquote t defined in it. In our case, it means a variable that is referenced in this code object but was defined and will be dereferenced to a cell in another code object (also see co_cellvars above and, again, the previous article).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_names\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A tuple containing the names which aren\rquote t covered by any of the other fields (they are not local variables, they are not free variables, etc) used by the bytecode. This includes names deemed to be in the global or builtin namespace as well as attributes (i.e., if you do foo.bar in a function, bar will be listed in its code object\rquote s names).\f0 \par
}}{\pard \nisusnos {\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls7\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet }{\f1 Counters and indexes (integers)\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_argcount\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The number of positional arguments the code object expects to receive, including those with default values. For example, def foo(a, b, c=3): pass would have a code object with this value set to three. The code object of classes accept one argument which we will explore when we discuss class creation.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_kwonlyargcount\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The number of keyword arguments the code object can receive.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_nlocals\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The number of local variables used in the code object (including arguments).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_firstlineno\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The line offset where the code object\rquote s source code began, relative to the module it was defined in, starting from one. In this (and some but not all other regards), each input line typed in the interactive interpreter is a module of its own.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_stacksize\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The maximum size required of the value stack when running this object. This size is statically computed by the compiler (./Python/compile.c: stackdepth when the code object is created, by looking at all possible flow paths searching for the one that requires the deepest value stack. To illustrate this, look at the diss and ssc outputs for a = 1 and a = [1,2,3]. The former has at most one value on the value stack at a time, the latter has three, because it needs to put all three integer literals on the stack before building the list.\f0 \par
}}{\pard \nisusnos {\par
}}{\listtext {\pard \nisusnos \nowidctlpar\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet \tab }}}{\pard \nisusnos \nowidctlpar\ls8\ilvl0\li720\lin720\fi-720\ri0\rin0\tx220\tx720 {\f1 \bullet }{\f1 Other stuff (various)\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_code\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A string representing the sequence of bytecode instructions, contains a stream of opcodes and their operands (or rather, indexes which are used with other code object fields to represent their operands, as we saw above).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_consts\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A tuple containing the literals used by the bytecode. Remember everything in a code object must be immutable, running diss and ssc on the code snippets a=(1,2,3) versus [1,2,3] and yet again versus a=(1,2,3,[4,5,6]) recommended to dig this field.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_lnotab\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A string encoding the mapping from bytecode offsets to line numbers. If you happen to really care how this is encoded you can either look at ./Python/compile.c or ./Lib/dis.py: findlinestarts.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_flags\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 An integer encoding a number of flags regarding the way this code object was created (which says something about how it should be evaluated). The list of possible flags is listed in ./Include/code.h, as a small example I can give CO_NESTED, which marks a code object which was compiled from a lexically nested function. Flags also have an important role in the implementation of the \f3\fs20 __future__\f1\fs24  mechanism, which is still unused in Python 3.1 at the time of this writing, as no \ldblquote future syntax\rdblquote  exists in Python 3.1. However, even when thinking in Python 3.x terms co_flags is still important as it facilitates the migration from the 2.x branch. In 2.x, \f3\fs20 __future__\f1\fs24  is used when enabling Python 3.x like behaviour (i.e., from \f3\fs20 __future__\f1\fs24  import print_function in Python 2.7 will disable the print statement and add a print function to the builtins module, just like in Python 3.x). If we come across flags from now on (in future posts), I\rquote ll try to mention their relevance in the particular scenario.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 co_zombieframe\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This field of the PyCodeObject struct is not exposed in the Python object; it (optionally) points to a stack frame object. This can aid performance by maintaining an association between a code object and a stack frame object, so as to avoid reallocation of frames by recycling the frame object used for a code object. There\rquote s a detailed comment in ./Objects/frameobject.c explaining zombie frames and their reanimation, we may mention this issue again when we discuss stack frames.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The above codeobjects list is not exhaustive. More can be added based on need and usage. This completes the codeobjects explaination, next will be frameobjects.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Core of Python\rquote s Virtual Machine, the \ldblquote actually do work function\rdblquote  \f3\fs20 ./Python/ceval.c: PyEval_EvalFrameEx\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Last hurdle on our way there is to understand the three significant stack data structures used for CPython\rquote s code evaluation: the call stack, the value stack and the block stack. All three stacks are tightly coupled with the frame object, which will also be discussed today.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In computer science, a call stack is a stack data structure that stores information about the active subroutines of a computer program\u8230 ? A call stack is composed of stack frames (\u8230 ?). These are machine dependent data structures containing subroutine state information. Each stack frame corresponds to a call to a subroutine which has not yet terminated with a return.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Since CPython implements a virtual machine, its call stack and stack frames are dependant on this virtual machine, not on the physical machine it\rquote s running on.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Python tends to do, this internal implementation detail is exposed to Python code, either via the C-API or pure Python, as frame objects (\f3\fs20 ./Include/frameobject.h: PyFrameObject\f1\fs24 ).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We know that code execution in CPython is really the evaluation (interpretation) of a code object, so every frame represents a currently-being-evaluated code object. We\rquote ll see (and already saw before) that frame objects are linked to one another, thus forming a call stack of frames. Finally, inside each frame object in the call stack there\rquote s a reference to two frame-specific stacks (not directly related to the call stack), they are the value stack and the block stack.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The value stack (you may know this term as an \lquote evaluation stack\rquote ) is where manipulation of objects happens when object-manipulating opcodes are evaluated\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We have seen the value stack before on various occasions, like in the introduction and during our discussion of namespaces.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Recalling an example we used before, \f3\fs20 BINARY_SUBTRACT\f1\fs24  is an opcode that effectively pops the two top objects in the value stack, performs \f3\fs20 PyNumber_Subtract\f1\fs24  on them and sets the new top of the value stack to the result.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Namespace related opcodes, like \f3\fs20 LOAD_FAST\f1\fs24  or \f3\fs20 STORE_GLOBAL\f1\fs24 , load values from a namespace to the stack or store values from the stack to a namespace. Each frame has a value stack of its own (this makes sense in several ways, possibly the most prominent is simplicity of implementation), we\rquote ll see later where in the frame object the value stack is stored.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Python has a notion called a code block, which we have discussed in the article about code objects and which is also explained here. Completely unrelatedly, Python also has a notion of compound statements, which are statements that contain other statements (the language reference defines compound statements here). Compound statements consist of one or more clauses, each made of a header and a suite. Even if the terminology wasn\rquote t known to you until now, I expect this is all instinctively clear to you if you have almost any Python experience: for, try and while are a few compound statements.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In various places throughout the code, a block (sometimes \ldblquote frame block\rdblquote , sometimes \ldblquote basic block\rdblquote ) is used as a loose synonym for a clause or a suite, making it easier to confuse suites and clauses with what\rquote s actually a code block or vice versa.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Both the compilation code (./Python/compile.c) and the evaluation code (./Python/ceval.c) are aware of various suites and have (ill-named) data structures to deal with them; but since we\rquote re more interested in evaluation in this series, we won\rquote t discuss the compilation-related details much (or at all).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Whenever I\rquote ll think wording might get confusing, I\rquote ll mention the formal terms of clause or suite alongside whatever code term we\rquote re discussing. With all this terminology in mind we can look at what\rquote s contained in a frame object.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Looking at the declaration of \f3\fs20 ./Include/frameobject.h: PyFrameObject\f1\fs24 , we find (comments were trimmed and edited for your viewing pleasure):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 typedef struct _frame \{\par
   PyObject_VAR_HEAD\par
   struct _frame *f_back;   /* previous frame, or NULL */\par
   PyCodeObject *f_code;    /* code segment */\par
   PyObject *f_builtins;    /* builtin symbol table */\par
   PyObject *f_globals;     /* global symbol table */\par
   PyObject *f_locals;      /* local symbol table */\par
   PyObject **f_valuestack; /* points after the last local */\par
   PyObject **f_stacktop;   /* current top of valuestack */\par
   PyObject *f_trace;       /* trace function */\par
\par
   /* used for swapping generator exceptions */\par
   PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;\par
\par
   PyThreadState *f_tstate; /* call stack's thread state */\par
   int f_lasti;             /* last instruction if called */\par
   int f_lineno;            /* current line # (if tracing) */\par
   int f_iblock;            /* index in f_blockstack */\par
\par
   /* for try and loop blocks */\par
   PyTryBlock f_blockstack[CO_MAXBLOCKS];\par
\par
   /* dynamically: locals, free vars, cells and valuestack */\par
   PyObject *f_localsplus[1]; /* dynamic portion */\par
\} PyFrameObject;\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We see various fields used to store the state of this invocation of the code object as well as maintain the call stack\rquote s structure. Both in the C-API and in Python these fields are all prefixed by \f3\fs20 f_\f1\fs24 , though not all the fields of the C structure PyFrameObject are exposed in the pythonic representation.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We already mentioned the relation between frame and code objects, so the f_code field of every frame points to precisely one code object.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Insofar as structure goes, frames point backwards thus that they create a stack (f_back) as well as point \ldblquote root-wards\rdblquote  in the interpreter state/thread state/call stack structure by pointing to their thread state (f_tstate), as explained here. Finally, since you always execute Python code in the context of three namespaces (as discussed there), frames have the f_builtins, f_globals and f_locals fields to point to these namespaces.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Before we dig into the other fields of a frame object, please notice frames are a variable size Python object (they are a PyObject_VAR_HEAD).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The reason is that when a frame object is created it should be dynamically allocated to be large enough to contain references (pointers, really) to the locals, cells and free variables used by its code object, as well as the value stack needed by the code objects \lquote deepest\rquote  branch.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Indeed, the last field of the frame object, f_localsplus (locals plus cells plus free variables plus value stack\u8230 ?) is a dynamic array where all these references are stored. \f3\fs20 PyFrame_New\f1\fs24  will show you exactly how the size of this array is computed.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f3\fs20 co_nlocals\f1\fs24 , \f3\fs20 co_cellvars\f1\fs24 , \f3\fs20 co_freevars\f1\fs24  and \f3\fs20 co_stacksize\f1\fs24  \endash  during evaluation, all these \lquote dead\rquote  parts of the inert code object come to \lquote life\rquote  in space allocated at the end of the frame. As we\rquote ll probably see in the next article, when the frame is evaluated, these references at the end of the frame will be used to get (or set) \ldblquote fast\rdblquote  local variables, free variables and cell variables, as well as to the variables on the value stack (\ldblquote fast\rdblquote  locals was explained when we discussed namespaces).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Looking back at the commented declaration above and given what I said here, I believe you should now understand \f3\fs20 f_valuestack\f1\fs24 , \f3\fs20 f_stacktop\f1\fs24  and \f3\fs20 f_localsplus\f1\fs24 .\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As you can maybe imagine, compound statements sometimes require state to be evaluated. If we\rquote re in a loop, we need to know where to go in case of a break or a continue. If we\rquote re raising an exception, we need to know where is the innermost enclosing handler (the suite of the closest except header, in more formal terms).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This state is stored in \f3\fs20 f_blockstack\f1\fs24 , a fixed size stack of \f3\fs20 PyTryBlock structures\f1\fs24  which keeps the current compound statement state for us (\f3\fs20 PyTryBlock\f1\fs24  is not just for try blocks; it has a \f3\fs20 b_type\f1\fs24  field to let it handle various types of compound statements\rquote  suites). \f3\fs20 f_iblock\f1\fs24  is an offset to the last allocated PyTryBlock in the stack. If we need to bail out of the current \ldblquote block\rdblquote  (that is, the current clause), we can pop the block stack and find the new offset in the bytecode from which we should resume evaluation in the popped \f3\fs20 PyTryBlock\f1\fs24  (look at its b_handler and b_level fields).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 A somewhat special case is a raised exception which exhausts the block stack without being caught, as you can imagine, in that case a handler will be sought in the block stack of the previous frames on the call stack.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 All this should easily click into place now if you read three code snippets. First, look at this disassembly of a for statement (this would look strikingly similar for a try statement):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> def f():\par
...     for c in 'string':\par
...             my_global_list.append(c)\par
...\par
>>> diss(f)\par
 2           0 SETUP_LOOP              27 (to 30)\par
             3 LOAD_CONST               1 ('string')\par
             6 GET_ITER\par
       >>    7 FOR_ITER                19 (to 29)\par
            10 STORE_FAST               0 (c)\par
\par
 3          13 LOAD_GLOBAL              0 (my_global_list)\par
            16 LOAD_ATTR                1 (append)\par
            19 LOAD_FAST                0 (c)\par
            22 CALL_FUNCTION            1\par
            25 POP_TOP\par
            26 JUMP_ABSOLUTE            7\par
       >>   29 POP_BLOCK\par
       >>   30 LOAD_CONST               0 (None)\par
            33 RETURN_VALUE\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Look at how the opcodes \f3\fs20 SETUP_LOOP\f1\fs24  and \f3\fs20 POP_BLOCK\f1\fs24  are implemented in \f3\fs20 ./Python/ceval.c\f1\fs24 .\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Notice that \f3\fs20 SETUP_LOOP\f1\fs24  and \f3\fs20 SETUP_EXCEPT\f1\fs24  or \f3\fs20 SETUP_FINALLY\f1\fs24  are rather similar, they all push a block matching the relevant suite unto the block stack, and they all utilize the same \f3\fs20 POP_BLOCK\f1\fs24 :\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 TARGET_WITH_IMPL(SETUP_LOOP, _setup_finally)\par
TARGET_WITH_IMPL(SETUP_EXCEPT, _setup_finally)\par
TARGET(SETUP_FINALLY)\par
_setup_finally:\par
    PyFrame_BlockSetup(f, opcode, INSTR_OFFSET() + oparg,\par
               STACK_LEVEL());\par
    DISPATCH();\par
\par
TARGET(POP_BLOCK)\par
    \{\par
        PyTryBlock *b = PyFrame_BlockPop(f);\par
        UNWIND_BLOCK(b);\par
    \}\par
    DISPATCH();\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Finally, look at the actual implementation of \f3\fs20 ./Object/frameobject.c: PyFrame_BlockSetup\f1\fs24  and \f3\fs20 ./Object/frameobject.c\f1\fs24 :\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 PyFrame_BlockPop:\par
\par
void\par
PyFrame_BlockSetup(PyFrameObject *f, int type, int handler, int level)\par
\{\par
   PyTryBlock *b;\par
   if (f->f_iblock >= CO_MAXBLOCKS)\par
       Py_FatalError("XXX block stack overflow");\par
   b = &f->f_blockstack[f->f_iblock++];\par
   b->b_type = type;\par
   b->b_level = level;\par
   b->b_handler = handler;\par
\}\par
\par
PyTryBlock *\par
PyFrame_BlockPop(PyFrameObject *f)\par
\{\par
   PyTryBlock *b;\par
   if (f->f_iblock <= 0)\par
       Py_FatalError("XXX block stack underflow");\par
   b = &f->f_blockstack[--f->f_iblock];\par
   return b;\par
\}\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 If you keep the terminology straight, \f3\fs20 f_blockstack\f1\fs24  turns out to be rather simple. We\rquote re left with the rather esoteric fields, some simpler, some a bit more arcane. In the \lquote simpler\rquote  range we have f_lasti, an integer offset into the bytecode of the last instructions executed (initialized to -1, i.e., we didn\rquote t execute any instruction yet).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This index lets us iterate over the opcodes in the bytecode stream. Heading towards the \lquote more arcane\rquote  area we see f_trace and f_lineno. f_trace is a pointer to a tracing function (see sys.settrace; think implementation of a tracer or a debugger). \f3\fs20 f_lineno\f1\fs24  contains the line number of the line which caused the generation of the current opcode; it is valid only when tracing (otherwise use \f3\fs20 PyCode_Addr2Line\f1\fs24 ).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Last but not least, we have three exception fields (f_exc_type, f_exc_value and f_exc_traceback), which are rather particular to generators so we\rquote ll discuss them when we discuss that beast (there\rquote s a longer comment about these fields in ./Include/frameobject.h if you\rquote re curious right now). On a parting note, we can mention when frames are created. This happens in ./Objects/frameobject.c: PyFrame_New, usually called from ./Python/ceval.c: PyEval_EvalCodeEx (and ./Python/ceval.c: fast_function, a specialized optimization of PyEval_EvalCodeEx).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Frame creation occurs whenever a code object should be evaluated, which is to say when a function is called, when a module is imported (the module\rquote s top-level code is executed), whenever a class is defined, for every discrete command entered in the interactive interpreter, when the builtins eval or exec are used and when the -c switch is used (I didn\rquote t absolutely verify this is a 100% exhaustive list, but it think it\rquote s rather complete).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Looking at the list in the previous paragraph, you probably realized frames are created very often, so two optimizations are implemented to make frame creation fast: first, code objects have a field (co_zombieframe) which allows them to remain associated with a \lquote zombie\rquote  (dead, unused) frame object even when they\rquote re not evaluated. If a code object was already evaluated once, chances are it will have a zombie frame ready to be reanimated by PyFrame_New and returned instead of a newly allocated frame (trading some memory to reduce the number of allocations).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Second, allocated and entirely unused stack frames are kept in a special free-list (./Objects/frameobject.c: free_list), frames from this list will be used if possible, instead of actually allocating a brand new frame. This is all kindly commented in ./Objects/frameobject.c.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 ./Python/ceval.c: PyEval_EvalFrameEx is important function in the Python interpreter.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Well, as I said, this switch can be found in the rather lengthy file ceval.c, in the rather lengthy function PyEval_EvalFrameEx, which takes more than half the file\rquote s lines (it\rquote s roughly 2,250 lines, the file is about 4,400).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 PyEval_EvalFrameEx implements CPython\rquote s evaluation loop, which is to say that it\rquote s a function that takes a frame object and iterates over each of the opcodes in its associated code object, evaluating (interpreting, executing) each opcode within the context of the given frame (this context is chiefly the associated namespaces and interpreter/thread states). There\rquote s more to ceval.c than PyEval_EvalFrameEx, and we may discuss some of the other bits later in this post (or perhaps a follow-up post), but PyEval_EvalFrameEx is obviously the most important part of it.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Having described the evaluation loop in the previous paragraph, let\rquote s see what it looks like in C (edited):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)\par
\{\par
    /* variable declaration and initialization stuff */\par
    for (;;) \{\par
        /* do periodic housekeeping once in a few opcodes */\par
        opcode = NEXTOP();\par
        if (HAS_ARG(opcode)) oparg = NEXTARG();\par
        switch (opcode) \{\par
            case NOP:\par
                goto fast_next_opcode;\par
            /* lots of more complex opcode implementations */\par
            default:\par
                /* become rather unhappy */\par
        \}\par
        /* handle exceptions or runtime errors, if any */\par
    \}\par
    /* we are finished, pop the frame stack */\par
    tstate->frame = f->f_back;\par
    return retval;\par
\}\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As you can see, iteration over opcodes is infinite (forever: fetch next opcode, do stuff), breaking out of the loop must be done explicitly.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 CPython (reasonably) assumes that evaluated bytecode is correct in the sense that it terminates itself by raising an exception, returning a value, etc. Indeed, if you were to synthesize a code object without a RETURN_VALUE at its end and execute it (exercise to reader: how?1), you\rquote re likely to execute rubbish, reach the default handler (raises a SystemError) or maybe even segfault the interpreter (I didn\rquote t check this thoroughly, but it looks plausible).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In order for you to be able to get a feel for what more serious opcode implementations look like, here\rquote s the (edited) implementation of three more opcodes, illustrating a few more principles:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 case BINARY_SUBTRACT:\par
    w = *--stack_pointer; /* value stack POP */\par
    v = stack_pointer[-1];\par
    x = PyNumber_Subtract(v, w);\par
    stack_pointer[-1] = x; /* value stack SET_TOP */\par
    if (x != NULL) continue;\par
    break;\par
case LOAD_CONST:\par
    x = PyTuple_GetItem(f->f_code->co_consts, oparg);\par
    *stack_pointer++ = x; /* value stack PUSH */\par
    goto fast_next_opcode;\par
case SETUP_LOOP:\par
case SETUP_EXCEPT:\par
case SETUP_FINALLY:\par
    PyFrame_BlockSetup(f, opcode, INSTR_OFFSET() + oparg,\par
               STACK_LEVEL());\par
    continue;\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 We see several things. First, we see a typical value manipulation opcode, BINARY_SUBTRACT. This opcode (and many others) works with values on the value stack as well as with a few temporary variables, using CPython\rquote s C-API abstract object layer (in our case, a function from the number-like object abstraction) to replace the two top values on the value stack with the single value resulting from subtraction.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As you can see, a small set of temporary variables, such as v, w and x are used (and reused, and reused\u8230 ?) as the registers of the CPython VM.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The variable stack_pointer represents the current bottom of the stack (the next free pointer in the stack). This variable is initialized at the beginning of the function like so: stack_pointer = f->f_stacktop;\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In essence, together with the room reserved in the frame object for that purpose, the value stack is this pointer. To make things simpler and more readable, the real (unedited by me) code of ceval.c defines several value stack manipulation/observation macros, like PUSH, TOP or EMPTY.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Next, we see a very simple opcode that loads values from somewhere into the valuestack. I chose to quote LOAD_CONST because it\rquote s very brief and simple, although it\rquote s not really a namespace related opcode.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 \ldblquote Real\rdblquote  namespace opcodes load values into the value stack from a namespace and store values from the value stack into a namespace; LOAD_CONST loads constants, but doesn\rquote t fetch them from a namespace and has no STORE_CONST counterpart (we explored all this at length in the article about namespaces).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The final opcode I chose to show is actually the single implementation of several different control-flow related opcodes (SETUP_LOOP, SETUP_EXCEPT and SETUP_FINALLY), which offload all details of their implementation to the block stack manipulation function PyFrame_BlockSetup; we discussed the block stack in our discussion of interpreter stacks.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Something we can observe looking at these implementations is that different opcodes exit the switch statement differently. Some simply break, and let the code after the switch resume.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Some use continue to start the for loop from the beginning. Some goto various labels in the function. Each exit has different semantic meaning.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 If you break out of the switch (the \lquote normal\rquote  route), various checks will be made to see if some special behaviour should be performed \endash  maybe a code block has ended, maybe an exception was raised, maybe we\rquote re ready to return a value. Continuing the loop or going to a label lets certain opcodes take various shortcuts; no use checking for an exception after a NOP or a LOAD_CONST, for instance.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 If you look at the code itself, you will see that none of the case expressions for the big switch are really there. The code for the NOP opcode is actually (remember this series is about Python 3.x unless noted otherwise, so this snippet is from Python 3.1.2):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 TARGET(NOP)\par
    FAST_DISPATCH();\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 TARGET? FAST_DISPATCH? What are these? Let me explain. Things may become clearer if we\rquote d look for a moment at the implementation of the NOP opcode in ceval.c of Python 2.x. Over there the code for NOP looks more like the samples I\rquote ve shown you so far, and it actually seems to me that the code of ceval.c gets simpler and simpler as we look backwards at older revisions of it.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The reason is that although I think PyEval_EvalFrameEx was originally written as a really exceptionally straightforward piece of code, over the years some necessary complexity crept into it as various optimizations and improvements were implemented (I\rquote ll collectively call them \lquote additions\rquote  from now on, for lack of a better term).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 To further complicate matters, many of these additions are compiled conditionally with preprocessor directives, so several things are implemented in more than one way in the same source file. I can understand trading simplicity to optimize a tight loop which is used very often, and the evaluation loop is probably one of the more used loops in CPython (and probably as tight as its contributors could make it). So while this is all very warranted, it doesn\rquote t help the readability of the code. Anyway, I\rquote d like to enumerate these additions here explicitly (some in more depth than others); this should aid future discussion of ceval.c, as well as prevent me from feeling like I\rquote m hiding too many important things with my free spirited editing of quoted code.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Fortunately, most if not all these additions are very well commented -actually, some of the explanations below will be just summaries or even taken verbatim from these comments, as I believe that they\rquote re accurate (eek!). So, as you read \f3\fs20 PyEval_EvalFrameEx\f1\fs24  (and indeed ceval.c in general), you\rquote re likely to run into any of these\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b \ldblquote Threaded Code\rdblquote  (Computed-GOTOs)}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Let\rquote s start with the addition that gave us TARGET, FAST_DISPATCH and a few other macros. The evaluation loop uses a \ldblquote switch\rdblquote  statement, which decent compilers optimize as a single indirect branch instruction with a lookup table of addresses. Alas, since we\rquote re switching over rapidly changing opcodes (it\rquote s uncommon to have the same opcode repeat), this would have an adverse effect on the success rate of CPU branch prediction.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Fortunately gcc supports the use of C-goto labels as values, which you can generally pass around and place in an array (restrictions apply!). Using an array of adresses in memory obtained from labels, as you can see in ./Python/opcode_targets.h, we create an explicit jump table and place an explicit indirect jump instruction at the end of each opcode. This improves the success rate of CPU prediction and can yield as much as 20% boost in performance.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Thus, for example, the NOP opcode is implemented in the code like so:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 TARGET(NOP)\par
    FAST_DISPATCH();\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 In the simpler scenario, this would expand to a plain case statement and a goto, like so:\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 case NOP:\par
    goto fast_next_opcode;\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 But when threaded code is in use, that snippet would expand to (I highlighted the lines where we actually move on to the next opcode, using the dispatch table of label-values):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 TARGET_NOP:\par
    opcode = NOP;\par
    if (HAS_ARG(NOP))\par
        oparg = NEXTARG();\par
case NOP:\par
    \{\par
        if (!_Py_TracingPossible) \{\par
            f->f_lasti = INSTR_OFFSET();\par
            goto *opcode_targets[*next_instr++];\par
        \}\par
        goto fast_next_opcode;\par
    \}\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Same behaviour, somewhat more complicated implementation, up to 20% faster Python. Nifty.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Opcode Prediction}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Some opcodes tend to come in pairs. For example, COMPARE_OP is often followed by JUMP_IF_FALSE or JUMP_IF_TRUE, themselves often followed by a POP_TOP.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 What\rquote s more, there are situations where you can determine that a particular next-opcode can be run immediately after the execution of the current opcode, without going through the \lquote outer\rquote  (and expensive) parts of the evaluation loop.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f3\fs20 PREDICT\f1\fs24  (and a few others) are a set of macros that explicitly peek at the next opcode and jump to it if possible, shortcutting most of the loop in this fashion (i.e., \f3\fs20 if (*next_instr == op) goto PRED_##op)\f1\fs24 .\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Note that there is no relation to real hardware here, these are simply hardcoded conditional jumps, not an exploitation of some mechanism in the underlying CPU (in particular, it has nothing to do with \ldblquote Threaded Code\rdblquote  described above).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Low Level Tracing}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 An addition primarily geared towards those developing CPython (or suffering from a horrible, horrible bug), Low Level Tracing is controlled by the LLTRACE preprocessor name, which is enabled by default on debug builds of CPython (see \endash with-pydebug). As explained in ./Misc/SpecialBuilds.txt: when this feature is compiled-in, PyEval_EvalFrameEx checks the frame\rquote s global namespace for the variable \f3\fs20 __lltrace__\f1\fs24 .\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 If such a variable is found, mounds of information about what the interpreter is doing are sprayed to stdout, such as every opcode and opcode argument and values pushed onto and popped off the value stack. Not useful very often, but very useful when needed.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This is the what the low level trace output looks like (slightly edited):\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f3\fs20 >>> def f():\par
...     global a\par
...     return a - 5\par
...\par
>>> dis(f)\par
  3           0 LOAD_GLOBAL              0 (a)\par
              3 LOAD_CONST               1 (5)\par
              6 BINARY_SUBTRACT\par
              7 RETURN_VALUE\par
>>> exec(f.__code__, \{'__lltrace__': 'foo', 'a': 10\})\par
0: 116, 0\par
push 10\par
3: 100, 1\par
push 5\par
6: 24\par
pop 5\par
7: 83\par
pop 5\par
# trace of the end of exec() removed\par
>>>\f0\fs24 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As you can guess, you\rquote re seeing a real-time disassembly of what\rquote s going through the VM as well as stack operations. For example, the first line says: line 0, do opcode 116 (LOAD_GLOBAL) with the operand 0 (expands to the global variable a), and so on, and so forth. This is a bit like (well, little more than) adding a bunch of printf calls to the heart of VM.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar\keepn {\f2\fs28\b Advanced Profiling}{\par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Under this heading I\rquote d like to briefly discuss several profiling related additions. The first relies on the fact that some processors (notably Pentium descendants and at least some PowerPCs) have built-in wall time measurement capabilities which are cheap and precise (correct me if I\rquote m wrong).\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As an aid in the development of a high-performance CPython implementation, Python 2.4\u8242 ?s ceval.c was instrumented with the ability to collect per-opcode profiling statistics using these counters.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 This instrumentation is controlled by the somewhat misnamed \endash with-tsc configuration flag (TSC is an Intel Pentium specific name, and this feature is more general than that). Calling sys.settscdump(True) on an instrumented interpreter will cause the function ./Python/ceval.c: dump_tsc to print these statistics every time the evaluation loop loops.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The second advanced profiling feature is Dynamic Execution Profiling. This is only available if Python was built with the DYNAMIC_EXECUTION_PROFILE preprocessor name.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 As ./Tools/scripts/analyze_dxp.py says, [this] will tell you which opcodes have been executed most frequently in the current process, and, if Python was also built with -DDXPAIRS, will tell you which instruction _pairs_ were executed most frequently, which may help in choosing new instructions.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 One last thing to add here is that enabling Dynamic Execution Profiling implicitly disables the \ldblquote Threaded Code\rdblquote  addition.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 The third and last addition in this category is function call profiling, controlled by the preprocessor name CALL_PROFILE. Quoting ./Misc/SpecialBuilds.txt again: When this name is defined, the ceval mainloop and helper functions count the number of function calls made. It keeps detailed statistics about what kind of object was called and whether the call hit any of the special fast paths in the code.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 Two preprocessor names, USE_STACKCHECK and CHECKEXC include extra assertions. Testing an interpreter with these enabled may catch a subtle bug or regression, but they are usually disabled as they\rquote re too expensive.\f0 \par
}}{\pard \nisusnos {\par
}}{\pard \nisusnos \nowidctlpar {\f1 That\rquote s the end of how eval loop operates.\par }}}